<!DOCTYPE html>
<html lang="zh-cn">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
图的应用 · inaho
</title>
  





<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">





<meta name="author" content="inaho">
<meta name="description" content="
  带权最小生成树
  
    
    链接到标题
  

如果要在 n 个城市之间建立通信网络，n 个城市之间最多有 n(n-1)/2 条道路，如何选择线路连通所有的城市，并且为了节省成本，要使连通的线路距离最短，假设有如下城市：

图中有 9 个城市{$v_0,v_1,v_2…v_8$}，图中各顶点之间的连线为此地的所有铺设的道路，现在要从这些道路中选择距离最短的线路，以便可以连通所有的城市，那么有如下三种选择。

这三种线路的距离各不一样，而方案三要比方案一的线路节省 62 公里的线路成本，如何选择一个最优的线路，也就是我们需要解决的问题。
对于 n 个顶点的连通网可以建立许多不同的生成树，每棵生成树都可以是一个通信网，最合理的通信网应该是代价之和最小的生成树，在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小生成树。
对于寻找连通图的最小生成树，一般有两种算法，普里姆算法和克鲁斯卡尔算法。



  普里姆算法
  
    
    链接到标题
  




  普里姆算法的构造过程
  
    
    链接到标题
  

设 G=(V, E) 是连通图，TE 是 N 上最小生成树中边的集合。
构造步骤：

初始化: $U=\{u_0\}(u_0 \in V), TE=\{\}$
在所有$u \in U, v \in V-U$ 的边$(u,v) \in E$中找到一条权值最小的边 $(u_0,v_0)$并入集合 TE，同时$v_0$并入 U。
重复过程二，直至 U=V 为止，此时 TE 中必有 n-1 条边，则 T=(V,TE)为 N 的最小生成树。




  普里姆算法举例
  
    
    链接到标题
  

">
<meta name="keywords" content="blog,developer,personal">






  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="图的应用">
  <meta name="twitter:description" content="带权最小生成树 链接到标题 如果要在 n 个城市之间建立通信网络，n 个城市之间最多有 n(n-1)/2 条道路，如何选择线路连通所有的城市，并且为了节省成本，要使连通的线路距离最短，假设有如下城市：
图中有 9 个城市{$v_0,v_1,v_2…v_8$}，图中各顶点之间的连线为此地的所有铺设的道路，现在要从这些道路中选择距离最短的线路，以便可以连通所有的城市，那么有如下三种选择。
这三种线路的距离各不一样，而方案三要比方案一的线路节省 62 公里的线路成本，如何选择一个最优的线路，也就是我们需要解决的问题。 对于 n 个顶点的连通网可以建立许多不同的生成树，每棵生成树都可以是一个通信网，最合理的通信网应该是代价之和最小的生成树，在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小生成树。 对于寻找连通图的最小生成树，一般有两种算法，普里姆算法和克鲁斯卡尔算法。
普里姆算法 链接到标题 普里姆算法的构造过程 链接到标题 设 G=(V, E) 是连通图，TE 是 N 上最小生成树中边的集合。
构造步骤：
初始化: $U=\{u_0\}(u_0 \in V), TE=\{\}$ 在所有$u \in U, v \in V-U$ 的边$(u,v) \in E$中找到一条权值最小的边 $(u_0,v_0)$并入集合 TE，同时$v_0$并入 U。 重复过程二，直至 U=V 为止，此时 TE 中必有 n-1 条边，则 T=(V,TE)为 N 的最小生成树。 普里姆算法举例 链接到标题">
 
<meta property="og:url" content="//localhost:1313/posts/yewvdflgtouwdrxf7wscztngnjc/">
  <meta property="og:site_name" content="inaho">
  <meta property="og:title" content="图的应用">
  <meta property="og:description" content="带权最小生成树 链接到标题 如果要在 n 个城市之间建立通信网络，n 个城市之间最多有 n(n-1)/2 条道路，如何选择线路连通所有的城市，并且为了节省成本，要使连通的线路距离最短，假设有如下城市：
图中有 9 个城市{$v_0,v_1,v_2…v_8$}，图中各顶点之间的连线为此地的所有铺设的道路，现在要从这些道路中选择距离最短的线路，以便可以连通所有的城市，那么有如下三种选择。
这三种线路的距离各不一样，而方案三要比方案一的线路节省 62 公里的线路成本，如何选择一个最优的线路，也就是我们需要解决的问题。 对于 n 个顶点的连通网可以建立许多不同的生成树，每棵生成树都可以是一个通信网，最合理的通信网应该是代价之和最小的生成树，在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小生成树。 对于寻找连通图的最小生成树，一般有两种算法，普里姆算法和克鲁斯卡尔算法。
普里姆算法 链接到标题 普里姆算法的构造过程 链接到标题 设 G=(V, E) 是连通图，TE 是 N 上最小生成树中边的集合。
构造步骤：
初始化: $U=\{u_0\}(u_0 \in V), TE=\{\}$ 在所有$u \in U, v \in V-U$ 的边$(u,v) \in E$中找到一条权值最小的边 $(u_0,v_0)$并入集合 TE，同时$v_0$并入 U。 重复过程二，直至 U=V 为止，此时 TE 中必有 n-1 条边，则 T=(V,TE)为 N 的最小生成树。 普里姆算法举例 链接到标题">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-06-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-06-04T00:00:00+00:00">
    <meta property="article:tag" content="数据结构">
      <meta property="og:see_also" content="//localhost:1313/posts/bzyiduql6opzodxxglncvrm0nvb/">
      <meta property="og:see_also" content="//localhost:1313/posts/pn4kd6n1eos5xyxutuaciqhfnjb/">
      <meta property="og:see_also" content="//localhost:1313/posts/qtnbdqineorsxpx02uucpayvnxh/">
      <meta property="og:see_also" content="//localhost:1313/posts/rfybd7gssoktinxwskock7atn8c/">
      <meta property="og:see_also" content="//localhost:1313/posts/lhqcd8fsiof6ckxbpvncx0vtnlg/">
      <meta property="og:see_also" content="//localhost:1313/posts/gafvd5ysioq746xujeocgxzln7b/">






<link rel="canonical" href="//localhost:1313/posts/yewvdflgtouwdrxf7wscztngnjc/">








<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>



  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  







 
<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
 









<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script src="//yihui.org/js/math-code.js" defer></script>
<script defer
  src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script> 

</head>






<body class="preload-transitions colorscheme-auto">
  



<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    
    <a class="navigation-title" href="//localhost:1313/">
      inaho
    </a>
    
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">文章</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">标签</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/">分类</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">关于</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/friends/">友链</a>
            </li>
          
        
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
<aside class="table-of-contents">
  <div class="toc-container">
    <h2>目录</h2>
    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#带权最小生成树">带权最小生成树</a>
      <ul>
        <li><a href="#普里姆算法">普里姆算法</a>
          <ul>
            <li><a href="#普里姆算法的构造过程">普里姆算法的构造过程</a></li>
            <li><a href="#普里姆算法举例">普里姆算法举例</a></li>
            <li><a href="#普里姆算法的实现">普里姆算法的实现</a></li>
            <li><a href="#算法描述">算法描述</a></li>
            <li><a href="#算法分析">算法分析</a></li>
          </ul>
        </li>
        <li><a href="#克鲁斯卡尔算法">克鲁斯卡尔算法</a>
          <ul>
            <li><a href="#构造过程">构造过程</a></li>
            <li><a href="#算法步骤">算法步骤</a></li>
            <li><a href="#算法举例">算法举例</a></li>
            <li><a href="#算法描述-1">算法描述</a></li>
            <li><a href="#算法分析-1">算法分析</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#最短路径">最短路径</a>
      <ul>
        <li><a href="#迪杰斯特拉算法">迪杰斯特拉算法</a>
          <ul>
            <li><a href="#求解过程">求解过程</a></li>
            <li><a href="#算法实现">算法实现</a></li>
            <li><a href="#算法步骤-1">算法步骤</a></li>
            <li><a href="#算法举例-1">算法举例</a></li>
            <li><a href="#算法描述-2">算法描述</a></li>
            <li><a href="#算法分析-2">算法分析</a></li>
          </ul>
        </li>
        <li><a href="#弗洛伊德算法">弗洛伊德算法</a>
          <ul>
            <li><a href="#算法实现-1">算法实现</a></li>
            <li><a href="#算法步骤-2">算法步骤</a></li>
            <li><a href="#算法举例-2">算法举例</a></li>
            <li><a href="#算法实现-2">算法实现</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#拓扑排序">拓扑排序</a>
      <ul>
        <li><a href="#拓扑排序的过程">拓扑排序的过程</a></li>
        <li><a href="#拓扑排序的实现">拓扑排序的实现</a>
          <ul>
            <li><a href="#代码实现">代码实现</a></li>
            <li><a href="#算法分析-3">算法分析</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#关键路径">关键路径</a>
      <ul>
        <li><a href="#关键路径的确定">关键路径的确定</a></li>
        <li><a href="#关键路径求解过程">关键路径求解过程</a></li>
        <li><a href="#算法实现-3">算法实现</a></li>
        <li><a href="#算法代码">算法代码</a></li>
        <li><a href="#算法分析-4">算法分析</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  </div>
</aside>
<section class="container post">
  <article>
    <header>
      <div class="post-title">
        <h1 class="title">
          <a class="title-link" href="//localhost:1313/posts/yewvdflgtouwdrxf7wscztngnjc/">
            图的应用
          </a>
        </h1>
      </div>
      <div class="post-meta">
        <div class="date">
          <span class="posted-on">
            <i class="fa-solid fa-calendar" aria-hidden="true"></i>
            <time datetime=" 2020-06-04T00:00:00Z">
              2020-06-04
            </time>
          </span>
          <span class="reading-time">
            <i class="fa-solid fa-clock" aria-hidden="true"></i>
            阅读时间：7 分钟
          </span>
          <span class="post-word-count">
            <i class="fa fa-pie-chart" aria-hidden="true" style="margin-left: 10px;"></i>
            101179 字
          </span>
        </div>
        

<div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
  <a href="/authors/lzy/">Lzy</a></div>
        

<div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a></div>
        

<div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
  <span class="tag">
    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </span></div>
      </div>
    </header>

    <div class="post-content">
      
      

<h1 id="带权最小生成树">
  带权最小生成树
  <a class="heading-link" href="#%e5%b8%a6%e6%9d%83%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h1>
<p>如果要在 n 个城市之间建立通信网络，n 个城市之间最多有 n(n-1)/2 条道路，如何选择线路连通所有的城市，并且为了节省成本，要使连通的线路距离最短，假设有如下城市：</p>
<p><img src="../static/E9PIb1ZxhopoKPx4c4vcSUSZn4e.png" alt=""></p>
<p>图中有 9 个城市{<code>$v_0,v_1,v_2…v_8$</code>}，图中各顶点之间的连线为此地的所有铺设的道路，现在要从这些道路中选择距离最短的线路，以便可以连通所有的城市，那么有如下三种选择。</p>
<p><img src="../static/VgYQb2kTIorCCExSrlocx6ijnGc.png" alt=""></p>
<p>这三种线路的距离各不一样，而方案三要比方案一的线路节省 62 公里的线路成本，如何选择一个最优的线路，也就是我们需要解决的问题。
对于 n 个顶点的连通网可以建立许多不同的生成树，每棵生成树都可以是一个通信网，最合理的通信网应该是代价之和最小的生成树，在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的<strong>最小生成树</strong>。
对于寻找连通图的最小生成树，一般有两种算法，普里姆算法和克鲁斯卡尔算法。</p>


<h2 id="普里姆算法">
  普里姆算法
  <a class="heading-link" href="#%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>


<h3 id="普里姆算法的构造过程">
  普里姆算法的构造过程
  <a class="heading-link" href="#%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95%e7%9a%84%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>设 G=(V, E) 是连通图，TE 是 N 上最小生成树中边的集合。</p>
<p>构造步骤：</p>
<ol>
<li>初始化: <code>$U=\{u_0\}(u_0 \in V), TE=\{\}$</code></li>
<li>在所有<code>$u \in U, v \in V-U$</code> 的边<code>$(u,v) \in E$</code>中找到一条权值最小的边 <code>$(u_0,v_0)$</code>并入集合 TE，同时<code>$v_0$</code>并入 U。</li>
<li>重复过程二，直至 U=V 为止，此时 TE 中必有 n-1 条边，则 T=(V,TE)为 N 的最小生成树。</li>
</ol>


<h3 id="普里姆算法举例">
  普里姆算法举例
  <a class="heading-link" href="#%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95%e4%b8%be%e4%be%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="../static/BnAGblzXyo1mdhxp5KbcKarKnof.png" alt=""></p>
<p>如上图所示，例如从 A 点出发，A-B 权值为 2，A-C 权值为 4，A-D 权值为 2，选择最小的边则选择 A-B，将 A-B 看作一个整体，选择 A-D、A-C、B-C 中权值最小的边 A-D。</p>
<p><img src="../static/WaU2bD5Y8omSQPxnExycxuwTnTe.png" alt=""></p>
<p>然后将 A-B-D 看作一个整体，继续选择 A-C、B-C、D-C 当中最小的边，直至所有顶点全部选完，这就是普里姆算法的大致思路，此图中有两个最小生成树，如下图所示</p>
<p><img src="../static/TqxSba4pZoiwknxzQtacIEd6nSf.png" alt=""></p>


<h3 id="普里姆算法的实现">
  普里姆算法的实现
  <a class="heading-link" href="#%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>假设无向图 G 以邻接矩阵存储，从顶点 u 出发构造 G 的最小生成树 T，要求输出 T 的各条边，为了实现此算法需要附设一个辅助数组 closedge，用于记录 U 到 V-U 具有最小权值的边，每个顶点 vi∈V−U，在辅助数组中存在一个相应分量 closedge[i-1]，它包括两个域，lowcost 与 adjvex，lowcost 存储最小边上的权值，adjvex 存储最小边在 U 中的顶点。</p>
<p>closedge 数组结构如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">VerTexType</span> <span class="n">adjvex</span><span class="p">;</span>        <span class="c1">//最小边在U中的那个顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ArcType</span> <span class="n">lowcost</span><span class="p">;</span>        <span class="c1">//最小边的权值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">closedge</span><span class="p">[</span><span class="n">MVNum</span><span class="p">];</span>
</span></span></code></pre></div>

<h3 id="算法描述">
  算法描述
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<ol>
<li>
<p>首先将初始顶点 u 加入 U 中，对其余的每一个顶点<code>$v_j$</code>，将 closedge[j]均初始化为到 u 的边信息。</p>
</li>
<li>
<p>循环 n-1 次，进行以下操作</p>
<ol>
<li>从各组边 closedge 中选出最小边 closedge[k]，输出此边</li>
<li>将 k 加入 U 中</li>
<li>更新剩余的每组最小边信息 closedge[j],对于 V-U 中的各边，新增加了一条从 k 到 j 的边，如果新边的权值比 closedge[j].lowcost 小，则将 closedge[j].lowcost 更新为新边的权值。</li>
</ol>
</li>
</ol>
<p>算法代码如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MiniSpanTree_Prim</span><span class="p">(</span><span class="n">AMGraph</span> <span class="n">G</span><span class="p">,</span><span class="n">VerTexType</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="nf">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>                <span class="c1">//k保存顶点u的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">!=</span><span class="n">k</span><span class="p">){</span>                    <span class="c1">//遍历除顶点u外所有顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]};</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 相当于
</span></span></span><span class="line"><span class="cl"><span class="cm">                closedge[j].adjvex = u;                //初始化为起始点
</span></span></span><span class="line"><span class="cl"><span class="cm">                closedge[j].lowcost = G.arcs[k][j]    //初始化为起始点到其余各顶点的权值
</span></span></span><span class="line"><span class="cl"><span class="cm">            */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">closedge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">lowcost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">//顶点u到自身的权值为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span> <span class="o">=</span> <span class="nf">Min</span><span class="p">(</span><span class="n">closedge</span><span class="p">);</span>                <span class="c1">//选出最小的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="n">u0</span> <span class="o">=</span> <span class="n">closedge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">adjvex</span><span class="p">;</span>        <span class="c1">//最小边的一个顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">v0</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>                    <span class="c1">//最小边的另一个顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u0</span> <span class="o">&lt;&lt;</span> <span class="n">v0</span><span class="p">;</span>                <span class="c1">//输出该边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="n">closedge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">lowcost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">//并入U集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>        <span class="c1">//重新选择最小边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">lowcost</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 id="算法分析">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>假设网中有 n 个顶点，初始化 closedge 的循环频度为 n，第二个循环频度为 n-1，第二个循环内有两个循环其一是在 closedge[v].lowcost 中求最小值，频度为 n-1，其二是重新选择最小权值的边频度为 n，所以该算法时间复杂度为<code>$O(n^2)$</code>，此算法适合求稠密网的最小生成树。</p>


<h2 id="克鲁斯卡尔算法">
  克鲁斯卡尔算法
  <a class="heading-link" href="#%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>普里姆算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树，而克鲁斯卡尔算法是以边为目标去构建的，因此需要使用图的存储结构中的<strong>边集数组</strong>结构，边集数组结构定义代码如下：</p>


<h3 id="构造过程">
  构造过程
  <a class="heading-link" href="#%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>克鲁斯卡尔算法的具体思路是： 将所有边按照权值从小到大排序，然后判断这个边会不会与之前选择的边组成回路。如果不会，就可以作为最小生成树的一部分，反之，舍去。</p>
<p>判断是否产生回路的方法为： 在初始状态每个顶点给不同的标记，遍历过程的每条边都有两个顶点，判断这两个顶点是否相等，如果相等说明他们处于一棵树中，如果继续连接就会产生回路。</p>
<p>假设连通网 N=(V,E)，将 N 中的边按权值从小到大的顺序排列。</p>
<ol>
<li>初始状态为只有 n 个顶点而无边的非连通图 T={V，{ }}，图中每个顶点自成一个连通分量。</li>
<li>在 E 中选择权值最小的边，若该边依附的顶点落在 T 中不同的连通分量上(即不构成回路)，则将此边加入到 T 中，否则舍去此边而选择下一条权值最小的边。</li>
<li>重复过程二，直至 T 中所有顶点都在同一连通分量上为止。</li>
</ol>


<h3 id="算法步骤">
  算法步骤
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<ol>
<li>
<p>将数组 Edge 中的元素按权值从小到大排序</p>
</li>
<li>
<p>依次查看数组 Edge 中的边，循环执行以下操作</p>
<ol>
<li>依次从排序好的数组 Edge 中选出一条边(U1U1,U2U2).</li>
<li>在辅助数组 parent 中分别查找 v1v1 和 v2v2 所在的连通分量 vs1vs1 和 vs2vs2，进行判断：
<ol>
<li>如果两者不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并两个连通分量。</li>
<li>如果两者相等，表明所选的两个顶点属于同一连通分量，舍去此边而选择下一条权值最小的边。</li>
</ol>
</li>
</ol>
</li>
</ol>


<h3 id="算法举例">
  算法举例
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e4%b8%be%e4%be%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>例如下图所示的网，初始状态下赋予各个顶点不同颜色的标记，对所有边的权值升序排序并进行判断。
首先是**(1,3)**边，由于顶点 1 和 3 标记不同，所以可以构成生成树的一部分，然后遍历所有的顶点，将与顶点 3 标记相同的顶点全部改为顶点 1 的标记.</p>
<p><img src="../static/VWLbbir0voYXk9x9eCec7a3Rnmf.png" alt=""></p>
<p>同理**(4,6)<strong>边与</strong>(2,5)**边也同样可以构成生成树的一部分，连接后更新相应顶点的标记，如下图：</p>
<p><img src="../static/Lue6b7imhoLCDfxruCocQsLYnwf.png" alt=""></p>
<p>然后最小为**(3,6)**边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点标记更改为顶点 1 的标记，如下图所示</p>
<p><img src="../static/To9jbNN2XorD9LxQd9CcS6Isnec.png" alt=""></p>
<p>继续选择权值最小的边，此时权值为 5 的边有三个，其中**(1,4)<strong>和</strong>(3,4)<strong>各自两顶点的标记相同，如果连接连接会产生回路，所以舍去。由于</strong>(2,3)**标记不同，可以连接，将顶点 2 标记相同的所有顶点的标记改为与顶点 3 相同的标记，当选取的边的数量比顶点数量小 1，说明最小生成树生成。</p>
<p><img src="../static/IeCFbFkLIom1ffxi0m0cnjlSnEf.png" alt=""></p>


<h3 id="算法描述-1">
  算法描述
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="kt">int</span> <span class="n">f</span><span class="p">){</span>        <span class="c1">//查找连线顶点的尾部下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MiniSpanTree_Kruskal</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Edge</span> <span class="n">edges</span><span class="p">[</span><span class="n">MAXEDGE</span><span class="p">];</span>            <span class="c1">//边集数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">];</span>                <span class="c1">//辅助数组用来判断边与边是否形成环路
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Sort</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span>                    <span class="c1">//对边集数组升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numEdges</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="nf">Find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">=</span> <span class="nf">Find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>        <span class="c1">//将此边的结尾顶点放入下标为起点的parent中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span> <span class="o">&lt;&lt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 id="算法分析-1">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>如果对存放在网中的边进行堆排序，对于包含 e 条边的网，上述算法排序时间为<code>$O(elog_2e)$</code>,由此克鲁斯算法的时间复杂度为<code>$O(elog_2e)$</code>，此算法更适合求稀疏网的最小生成树。</p>


<h1 id="最短路径">
  最短路径
  <a class="heading-link" href="#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h1>
<p><img src="../static/KZhxbGX4Ooi4Nwx0Sfqc8IoinSh.png" alt=""></p>
<p>我们在出门旅行时经常会面临选择路线的决策问题，比如从一个城市到另一个城市如何选择线路，或者在城市中从 A 点到 B 点如何乘坐交通工具能够最快到达目的地，我们所讨论的最短路径主要分为两种：</p>
<ul>
<li>对于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径，只需要从顶点对图做广度优先搜索到终点停止，所得的广度优先生成树上，从根顶点到目的地的路径就是最短路径。</li>
<li>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</li>
<li>两种常见的最短路径问题: 求从某个源点到其余各顶点的最短路径、求每一对顶点之间的最短路径</li>
</ul>


<h2 id="迪杰斯特拉算法">
  迪杰斯特拉算法
  <a class="heading-link" href="#%e8%bf%aa%e6%9d%b0%e6%96%af%e7%89%b9%e6%8b%89%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>本文讨论单源点的最短路径问题： 给定带权有向图 G 和源点<code>$v_0$</code>，求从<code>$v_0$</code>到 G 中其余各顶点的最短路径。</p>
<p>迪杰斯特拉算法是一个按路径长度递增的次序产生最短路径的算法。</p>


<h3 id="求解过程">
  求解过程
  <a class="heading-link" href="#%e6%b1%82%e8%a7%a3%e8%bf%87%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>对于网 N=(V,E)，将 N 中的顶点分成两组</p>
<ol>
<li>S: 已求出的最短路径的终点集合(初始时只包含源点<code>$v_0$</code>)</li>
<li>V-S: 尚未求出的最短路径的顶点集合(初始时为 V-{<code>$v_0$</code>})</li>
</ol>
<p>算法将按各顶点与<code>$v_0$</code>间最短路径长度递增的次序，逐个将集合 V-S 中的顶点加入到集合 S 中，在这个过程中，总保持从<code>$v_0$</code>到集合 S 中各顶点的路径长度始终不大于到集合 V-S 中各顶点的路径长度。</p>


<h3 id="算法实现">
  算法实现
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>假设用带权邻接矩阵 arc 来表示带权有向网 G，G.arcs[i][j]表示弧上的权值，如果不存在，则用一个非常大的数字代表正无穷，算法的实现需要引入以下辅助数据结构：</p>
<ol>
<li>一维数组 <strong>S[i]</strong>: 记录从源点<code>$v_0$</code>到终点 v1v1 是否已被确定最短路径长度，true 表示确定，false 表示不确定。</li>
<li>一维数组 <strong>Path[i]</strong>: 记录从源点<code>$v_0$</code>到终点 vivi 的当前最短路径上 vivi 的直接前驱顶点序号，初值为： 如果从 v0v0 到 v1v1 有弧，则 Path[i]为<code>$v_0$</code>，否则为-1.</li>
<li>一维数组 <strong>D[i]</strong>: 记录从源点<code>$v_0$</code>到终点<code>$v_1$</code>的当前最短路径长度，初值为: 如果从<code>$v_0$</code>到<code>$v_i$</code>有弧，则 D[i]为弧上的权值，否则为无穷大。</li>
</ol>
<p>长度最短的一条最短路径必为(<code>$v_0$</code>,<code>$v_k$</code>)，满足<code>$D[k] = Min\{D[i]|v_i \in V - S\}$</code></p>
<p>求得顶点<code>$v_k$</code>的最短路径后，将其加入第一组顶点集 S 中，每当加入新顶点到 S，对第二组而言，多了一个</p>
<p>中转顶点，从而多了中转路径，所以要对第二组剩余的各个顶点的最短路径长度进行更新。</p>
<p>原来<code>$v_0$</code>到<code>$v_i$</code>的最短路径长度为 D[i]，加入<code>$v_k$</code>之后，以<code>$v_k$</code>作为中间顶点的中转路径长度为: D[k]+G.arcs[k][i]D[k]+G.arcs[k][i]，若 D[k]+G.arcs[k][i]&lt;D[i]D[k]+G.arcs[k][i]&lt;D[i]，则用 D[k]+G.arc[k][i]D[k]+G.arc[k][i]取代 D[i].</p>
<p>更新后，在选择数组 D 中最小的顶点加入顶点集 S 中，然后重复上述过程，直至图中所有顶点都加入 S 中为止。</p>


<h3 id="算法步骤-1">
  算法步骤
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<ol>
<li>
<p>初始化</p>
<ol>
<li>将源点<code>$v_0$</code>加入 S 中，即 S[<code>$v_0$</code>]=true.</li>
<li>将<code>$v_0$</code>到各个终点的最短路径长度初始化为权值，即<code>$D[i]=G.arcs[v_0][v_i]$</code>.</li>
<li>如果<code>$v_0$</code>和顶点<code>$v_i$</code>之间有弧，则将<code>$v_i$</code>的前驱置为<code>$v_0$</code>，即<code>$Path[i]=v_0$</code>，否则<code>$Path[i]=-1.$</code></li>
</ol>
</li>
<li>
<p>循环 n-1 次，执行以下操作</p>
<ol>
<li>选择下一条最短路径的终点<code>$v_k$</code>，使得<code>$D[k] = Min\{D[i]|v_i \in V - S\}$</code></li>
<li>将<code>$v_k$</code>加入 S 中，即<code>$S[v_k]=true$</code>.</li>
<li>根据条件更新从<code>$v_0$</code>出发到集合 V-S 上任一顶点的最短路径的长度，若条件 D[k]+G.arcs[k][i]&lt;D[i]，同时更改<code>$v_i$</code>的前驱为<code>$v_k$</code>，Path[i]=k。</li>
</ol>
</li>
</ol>


<h3 id="算法举例-1">
  算法举例
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e4%b8%be%e4%be%8b-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="../static/VQiKbeW7FopRGJxytTZcZu3GnBh.png" alt=""></p>
<p>用上图进行举例，首先选取源点 D 并入 S 集中，然后更新从源点 D 到其余各顶点的距离，用 U 数组进行存储，然后在 U 中选取最小权值的顶点(C)并入 S 集中，此时 S 集有 D、C 两个顶点，继续更新 D 到其余各顶点的距离，此时 S 集中有 C 顶点可以作为中转点，所以 D 到 B 的距离可以更新为 13，D-C-E 的距离比 D-E 的距离长，所以 E 的权值不变，F 的距离根据 C 顶点中转，可以算出为 3+6=9.</p>
<p><img src="../static/UBB4b5vqhoXq9dxLIjoc2BLMn8c.png" alt=""></p>
<p>第三步在 S 集中继续选取最小权值的顶点(E)并入 S 集中，然后 E 作为中转点，更新 U 中其余顶点到源点的距离，第四步依然是在 S 集中选取最小权值的顶点(F)并入 S 集中，U 中更新其余顶点到源点的距离。</p>
<p><img src="../static/PPiqbp4SjoWXzmxBgNIckZh1n9e.png" alt=""></p>
<p>第五步和第六步与以上步骤同理，从 U 中选取权值最小的顶点并入 S 集，然后将此顶点作为中转点，更新源点到其余顶点的距离。</p>
<p><img src="../static/Bo22b7RNcoxQH7xrnf1cl6RrnFe.png" alt=""></p>
<p>通过以上步骤，U 集中的顶点已经全部并入 S 集，此时源点到其余各顶点的最短路径已经计算完毕。</p>


<h3 id="算法描述-2">
  算法描述
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ShortesPath_DIJ</span><span class="p">(</span><span class="n">AMGraph</span> <span class="n">G</span><span class="p">,</span><span class="kt">int</span> <span class="n">v0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">){</span>            <span class="c1">//对n个顶点初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>        <span class="c1">//记录v0到v的最短路径长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="n">MaxInt</span><span class="p">){</span>        <span class="c1">//MaxInt表示正无穷，如果有弧更新Path为v0,否则置为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">v0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>        <span class="c1">//将v0加入S
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">D</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>        <span class="c1">//源点到源点的距离为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历其余顶点，每次求得v0到某个顶点v的最短路径，将v并入S
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">min</span><span class="o">=</span><span class="n">MaxInt</span><span class="p">;</span>            <span class="c1">//初始化最短路径为无穷大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*遍历所有结点，如果顶点v0到vw没有确认为最短路径，
</span></span></span><span class="line"><span class="cl"><span class="cm">        并且v0到vw的路径比当前最短路径小，则更新最短路径。*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">w</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">v</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>            <span class="c1">//保存顶点位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">min</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>                <span class="c1">//设置顶点v0到v为确定的最短路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*更新从v0出发到集合V-S上所有顶点的最短路径长度*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">w</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*如果没有确认到vw的最短路径，
</span></span></span><span class="line"><span class="cl"><span class="cm">            并且v0到v的最短路径加从v到w的路径之和，
</span></span></span><span class="line"><span class="cl"><span class="cm">            小于当前从v到w的最短路径, 则对其更新*/</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span><span class="o">&lt;</span><span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">                <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">Path</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">;</span>        <span class="c1">//更改w的前驱为v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 id="算法分析-2">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>主循环一共进行 n-1 次，每次执行时间为 O(n)，所以算法时间复杂度为<code>$O(n^2)$</code>。</p>
<p>人们可能只希望找到从源点到某个终点的最短路径，但这个问题和求源点到其他所有顶点的最短路径一样复杂，所以使用迪杰斯特拉算法解决，时间复杂度依然为<code>$O(n^2)$</code>。</p>


<h2 id="弗洛伊德算法">
  弗洛伊德算法
  <a class="heading-link" href="#%e5%bc%97%e6%b4%9b%e4%bc%8a%e5%be%b7%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>迪杰斯特拉算法是解决单源点到其余顶点最短路径的问题，如果是求每一对顶点之间的最短路径，用迪杰斯特拉算法就需要将每个顶点都作为源点，然后共同调用 n 次算法，相当于在外层又套了一层循环，这种方式时间复杂度变为<code>$O(n^3)$</code>。</p>
<p>另一种求最短路径的算法是弗洛伊德算法，弗洛伊德算法的时间复杂度依然为<code>$O(n^3)$</code>,但其算法非常简洁优雅，此算法仍然使用带权的邻接矩阵 arcs 来表示有向网 G，求从顶点<code>$v_i$</code>到<code>$v_j$</code>的最短路径.</p>


<h3 id="算法实现-1">
  算法实现
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>算法实现需要引入以下数组:</p>
<ul>
<li>二维数组 Path[i][j]: 最短路径上顶点<code>$v_j$</code>的前一顶点的序号。</li>
<li>二维数组 D[i][j]: 记录顶点<code>$v_i$</code>和<code>$v_j$</code>之间的最短路径长度。</li>
</ul>


<h3 id="算法步骤-2">
  算法步骤
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>将<code>$v_i$</code>到<code>$v_j$</code>的最短路径长度初始化，即 D[i][j]=G.arcs[i][j]，然后进行 n 次比较更新。</p>
<ol>
<li>在<code>$v_i$</code>和<code>$v_j$</code>间加入中转顶点<code>$v_0$</code>，比较(<code>$v_i$</code>,<code>$v_0$</code>,<code>$v_j$</code>)和(<code>$v_i$</code>,<code>$v_j$</code>)的路径长度，也就是判断 G.arcs[i][0]+G.arcs[0][j]是否比 G.arcs[i][j]的路径更短，取最短的作为<code>$v_i$</code>到<code>$v_j$</code>的最短路径，同时更新 Path 数组对应的值。</li>
<li>循环将<code>$v_1$</code>,<code>$v_2$</code>…<code>$v_n$</code>都作为中转点，更新<code>$v_i$</code>到<code>$v_j$</code>的最短路径，经过 n 次比较后，就可以得到任意两顶点之间的最短路径。</li>
</ol>


<h3 id="算法举例-2">
  算法举例
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e4%b8%be%e4%be%8b-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="../static/Kf46bpThEoMqfQxRF8kcO60Jnac.png" alt=""></p>
<p>我们先用三个顶点的无向图举例，D0 表示初始的邻接表，P0 记录最短路径上顶点 vjvj 前一个顶点的序号。</p>
<p>我们发现如果用 v1v1 作为中转点，那么(v0,v1)+(v1,v2)=4，比(v0,v2)=5 更小，所以需要更新 D 矩阵的对应值为最短路径的长度，所以更新 D[0][2]=4，由于此图是无向图，因此 D[2][0]=4，由此得到 D1 所对应的矩阵，D 矩阵改变，P 矩阵也需要改变，由于现在 v0 到 v2 的最短路径经过 v1，因此 P[0][2]需要存储 v1 的序号 1，表明 v2 结点的前一顶点是 v1。</p>
<p>接下来如果我们用下面一个较为复杂的图来进行说明，首先还是对 D、P 矩阵进行初始化。</p>
<p><img src="../static/GzRGbm2ZVo3htqxRFS1clm8Onye.png" alt=""></p>
<p>我们依然首先以 v0 作为中转点，发现只有 v1 与 v2 是以 v0 作为中转点的，所以 D、P 矩阵的值不变，接下来我们使用 v1 作为中转点，v3、v4、v2 都可以以 v1 作为中转点，然后更新 D、P 矩阵的对应数据，我们更新以 v1 作为中间结点的数据代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>          <span class="c1">//n为图中顶点的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>  
</span></span><span class="line"><span class="cl">            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span></code></pre></div><p>那么如果我们需要更新以 vi(i=1,2,3…n)顶点为中间顶点的对应 D 矩阵的数据，只需要将循环中的 1 改为 i 即可，因此需要在外层在进行循环 i，可以得到以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">Path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">Path</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>    <span class="c1">//在循环的过程中顺便更新P矩阵的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span></code></pre></div><p>经过 9 次循环可以得到现在的 D、P 矩阵:</p>
<p><img src="../static/H1NQbQ0O7oGvnjxiziBcrScSn3g.png" alt=""></p>
<p>从上图的 D 矩阵可以看出(v0,v8)的最短路径为 16，从 P 矩阵可以看出从(v0,v8)需要经过 v1 中转，然后又从(v1,v8)看出需要经过 v2，从(v2,v8)需要经过 v4，(v4,v8)需要经过 v3，(v3,v8)需要经过 v6，从(v6,v8)需要经过 v7，然后从 v7 可以直接到 v8，那么 v0 到 v8 的最短路径就是 v0−v1−v2−v4−v3−v6−v7−v8，然后我们手动计算此路径长度为 1+3+1+2+3+7=16，和 D 矩阵相应的值一样，这就是弗洛伊德算法的过程。</p>


<h3 id="算法实现-2">
  算法实现
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ShortestPath_Floyd</span><span class="p">(</span><span class="n">AMGraph</span> <span class="n">G</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>                <span class="c1">//初始化矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">MaxInt</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">){</span>        <span class="c1">//如果i与j之间有弧，则将j的前驱置为i，否则置为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">Path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//计算任意两顶点之间最短距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>        <span class="c1">//更新D[i][j]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">Path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">Path</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>            <span class="c1">//更改j的前驱为k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h1 id="拓扑排序">
  拓扑排序
  <a class="heading-link" href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h1>
<p>一个无环的有向图称作<strong>有向无环网(Directed Acyline Graph)</strong>，简称 <strong>DAG 图</strong>。
有向无环网是描述工程进行过程的有效工具，一个工程可以被分为若干个称为活动的子工程，子工程之间有约束关系，比如前一个工程完成后才能进行下一个工程，如下图所示：</p>
<p><img src="../static/N4UybOa8aoPR2SxlwtPcgNWUnSh.png" alt=""></p>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 <strong>AOV 网(Activity On Vertex Network)</strong>。</p>
<p>在 AOV 网中，若从顶点 vivi 到顶点 vjvj 有一条有向路径，则 vi 是 vj 的前驱，vj 是 vi 的后继，若 &lt;vi,vj&gt; 是网中的一条弧，则 vi 是 vj 的直接前驱，vj 是 vi 的直接后继。</p>
<p>在 AOV 网中不应该出现有向环 ，因为存在环意味着某项活动应以自己为先决条件，这是矛盾的，对于给定的 AOV 网应该先判断网中是否存在环，检测的方法就是对 AOV 网进行拓扑排序，若网中所有的顶点都在它的拓扑有序序列中，则该 AOV 网中必定不存在环。</p>
<p>拓扑排序就是将 AOV 网中所有顶点排成一个线性序列，该序列满足: 若在 AOV 网中由 vi 到 vj 有一条路径，则在该线性序列中的顶点 vi 必定在 vj 之前.这样的拓扑序列不止一条，例如上面的工程图有如下两个拓扑有序序列：</p>
<p><code>$$ V0，V1，V2，V3，V4，V5，V6，V7，V8，V9，V10，V11，V12，V13，V14，V15，V16 $$</code></p>
<p><code>$$ V0，V1，V4，V3，V2，V7，V6，V5，V8，V10，V9，V12，V11，V14，V13，V15，V16 $$</code></p>
<blockquote>
<p>拓扑序列只要保证前一个结点一定是指向后一个结点，而不指向之前的结点就好。</p></blockquote>
<p>构造拓扑序列时有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环的 AOV 网，如果输出顶点数少了，就说明这个网存在环，不是 AOV 网。</p>


<h2 id="拓扑排序的过程">
  拓扑排序的过程
  <a class="heading-link" href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f%e7%9a%84%e8%bf%87%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<ol>
<li>在有向图中选一个无前驱的顶点且输出它。</li>
<li>从图中删除该顶点和所有以它为尾的弧。</li>
<li>重复步骤 1 与步骤 2，直至不存在无前驱的顶点。</li>
<li>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点为拓扑序列。</li>
</ol>
<p>以之前的流程图为例，可以构造出以下的 AOV 网：</p>
<p><img src="../static/N92QbSL4ooCBFKxKQ6ZcfkRYnre.png" alt=""></p>


<h2 id="拓扑排序的实现">
  拓扑排序的实现
  <a class="heading-link" href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f%e7%9a%84%e5%ae%9e%e7%8e%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>进行拓扑排序的过程需要删除顶点，所以使用邻接表会更加方便，因此需要为 AOV 网建立一个邻接表，考虑到算法过程需要查找入度为 0 的顶点，所以需要在原顶点表结构中，加入一个入度域 in，结构代码如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">EdgeNode</span><span class="p">{</span>        <span class="c1">//边表结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">adjvex</span><span class="p">;</span>                    <span class="c1">//邻接点域，存储该顶点对应的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>                    <span class="c1">//存储权值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>        <span class="c1">//指向下一个邻接点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">EdgeNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VertexNode</span><span class="p">{</span>        <span class="c1">//顶点表结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">in</span><span class="p">;</span>                        <span class="c1">//入度域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>                    <span class="c1">//顶点域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">firstedge</span><span class="p">;</span>        <span class="c1">//边表头指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">VertexNode</span><span class="p">,</span><span class="n">AdjList</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AdjList</span> <span class="n">adjList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numVertexes</span><span class="p">,</span><span class="n">numEdges</span><span class="p">;</span>    <span class="c1">//图中顶点数和边数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">graphAdjList</span><span class="p">,</span><span class="o">*</span><span class="n">GraphAdjList</span><span class="p">;</span>
</span></span></code></pre></div><p>在算法中，还需要用栈来处理入度为 0 的顶点，目的是为了避免每个查找时都要遍历顶点表找有没有入度为 0 的顶点。</p>


<h3 id="代码实现">
  代码实现
  <a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>在删除顶点和以它为尾的弧的操作，可以不必真正对图的存储结构进行改变，可用弧头顶点的入度-1 的方式来实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">TopologicalSort</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">gettop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">//栈指针下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">//输出顶点的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>            <span class="c1">//存入度为0的顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历所有顶点将入度为0的顶点入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">gettop</span><span class="o">=</span><span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">];</span>    <span class="c1">//出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">gettop</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++</span><span class="p">;</span>                <span class="c1">//统计输出顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">//遍历此顶点的弧表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">gettop</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">in</span><span class="p">)){</span>    <span class="c1">//将k号顶点邻接点的入度-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>            <span class="c1">//如果为入度为0则入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">)</span> <span class="k">return</span> <span class="n">ERRPR</span><span class="p">;</span>    <span class="c1">//如果输出顶点数小于总顶点则说明有环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 id="算法分析-3">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>对于有 n 个顶点和 e 条边的有向图而言，建立求各顶点入度的时间复杂度为 O(e),建立零入度顶点栈的时间复杂度为 O(n)，所以总的时间复杂度为 O(n+e).</p>


<h1 id="关键路径">
  关键路径
  <a class="heading-link" href="#%e5%85%b3%e9%94%ae%e8%b7%af%e5%be%84">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h1>
<p>在 AOV 网中，我们用顶点表示活动，用弧来表示活动间的优先关系，AOE(Activity On Edge)网与 AOV 网不同，AOE 网用顶点表示事件，用弧来表示活动，权表示活动持续的时间，通常 AOE 网可用来估算工程的完成时间。</p>
<p>在一个工程计划中，通常需要判断哪些活动是影响工程进度的关键，由于现在大多数工程采用流水线管理，对于没有先后关系的子工程可以在同一时间进行，那么进行时间最长的子工程将决定下一个子工程的开始时间，因此将其称为关键活动，关键活动的延期会导致整个项目的延期。</p>
<p>由于整个工程只有一个开始点和一个完成点，正常情况下，网中只有一个入度为零的点，称为源点，也只有一个出度为零的点，称为汇点，如下图所示:</p>
<p><img src="../static/MMEXbxz22oCdOxxGH20c4gPineb.png" alt=""></p>
<p>v0 即为源点，表示工程的开始，v9 是汇点，表示工程的结束，顶点 v0,v1,v2,&hellip;,v9 分别表示事件，弧 &lt;v0,v1&gt;,&lt;v0,v2&gt;&hellip;&lt;vi,vj&gt; 都表示一个活动，用 a0，a1，&hellip;，ai 表示，它们的值表示活动持续的时间。</p>
<p>在 AOE 网中，一条路径各弧上的权值之和称为该路径的带权路径长度，要估算整个项目的完成时间，就要找一条从源点到汇点的带权路径长度最长的路径，称为关键路径，关键路径上的活动称为关键活动。</p>


<h2 id="关键路径的确定">
  关键路径的确定
  <a class="heading-link" href="#%e5%85%b3%e9%94%ae%e8%b7%af%e5%be%84%e7%9a%84%e7%a1%ae%e5%ae%9a">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>为了确定关键路径，需要定义四个描述量:</p>
<ol>
<li>事件的最早发生时间 etv(earliest time of vertex): 即顶点 vk 的最早发送时间</li>
<li>事件的最迟发生时间 ltv(latest time of vertex): 即顶点 vk 的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li>
<li>活动的最早开始时间 ete(earliest time of edge): 即弧 ak 的最早发生时间。</li>
<li>活动的最晚开始时间 lte(latest time of edge): 即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间。</li>
</ol>
<p>由 1、2 可以求得 3、4，然后再根据 ete[k]是否与 lte[k]相等来判断 ak 是否是关键活动。</p>


<h2 id="关键路径求解过程">
  关键路径求解过程
  <a class="heading-link" href="#%e5%85%b3%e9%94%ae%e8%b7%af%e5%be%84%e6%b1%82%e8%a7%a3%e8%bf%87%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<ol>
<li>对图中顶点进行排序，在排序过程中按拓扑序列求出每个事件的最早发生时间 etv。</li>
<li>按逆拓扑序列求出每个事件的最迟发生时间 ltv。</li>
<li>求出每个活动的最早开始时间 ete。</li>
<li>求出每个活动的最晚开始时间 lte。</li>
<li>找出 ete 与 lte 相等的活动，即为关键活动，由关键活动形成的由源点到汇点的每一条路径就是关键路径。</li>
</ol>


<h2 id="算法实现-3">
  算法实现
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<ol>
<li>
<p>调用拓扑排序算法，保存拓扑序列到 stack2</p>
</li>
<li>
<p>初始化每个事件的最早发生时间为 0</p>
</li>
<li>
<p>根据 stack2 保存的拓扑序列，按从前向后的拓扑次序，依次求每个事件的最早发生时间，循环执行以下操作</p>
<ol>
<li>取得拓扑序列中的顶点序号 k</li>
<li>用指针 p 依次指向 k 的每一个邻接顶点，取得每个邻接顶点的序号 j=p-&gt;adjvex，依次更新顶点 j 的最早发生时间</li>
</ol>
</li>
<li>
<p>将每个事件的最迟发生时间初始化为汇点的最早发生时间</p>
</li>
<li>
<p>根据 stack2 的值按从后向前的逆拓扑次序，依次求每个事件的最迟发生时间，循环执行以下操作</p>
<ol>
<li>取得拓扑序列中顶点序号 k</li>
<li>用指针 p 依次指向 k 的每一个邻接顶点，取得每个邻接顶点的序号 j=p-&gt;adjvex,依次根据 k 的邻接点，更新 k 的最迟发生时间</li>
</ol>
</li>
<li>
<p>判断某一活动是否为关键活动，循环 n 次，执行以下操作</p>
<ol>
<li>对每个顶点 i，用指针 p 依次指向 i 的每个邻接顶点，取得每个邻接顶点的序号 j=p-&gt;adjvex，分别计算活动的最早和最晚开始时间，如果两者相等，说明活动为关键活动，输出此弧。</li>
</ol>
</li>
</ol>


<h2 id="算法代码">
  算法代码
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e4%bb%a3%e7%a0%81">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>求事件的最早发生时间 etv 的过程，就是从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要调用一次拓扑序列算法来计算 etv 和拓扑序列列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">etv</span><span class="p">,</span><span class="o">*</span><span class="n">ltv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">stack2</span><span class="p">;</span>        <span class="c1">//stack2用来存储拓扑序列，以便后面求关键路径时使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">top2</span><span class="p">;</span>            <span class="c1">//用于stack2的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">TopologicalSort</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">gettop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>        <span class="c1">//用于栈指针下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>    <span class="c1">//用于统计输出顶点的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>        <span class="c1">//建栈将入度为0的顶点入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stack</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//将所有入度为0的顶点入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Gl</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//事件最早发生事件全部初始化为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">etv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>    <span class="c1">//事件最早发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">etv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">top2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">top</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">gettop</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">stack2</span><span class="p">[</span><span class="o">++</span><span class="n">top2</span><span class="p">]</span><span class="o">=</span><span class="n">gettop</span><span class="p">;</span>        <span class="c1">//这里原先是输出顶点序号，现在改为压入stack2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">gettop</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">in</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//求etv数组的每一个元素的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">((</span><span class="n">etv</span><span class="p">[</span><span class="n">gettop</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">etv</span><span class="p">[</span><span class="n">k</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="n">etv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">etv</span><span class="p">[</span><span class="n">gettop</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">)</span> <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CriticalPath</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">gettop</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ete</span><span class="p">,</span><span class="n">lte</span><span class="p">;</span>            <span class="c1">//声明活动最早发生时间和最迟发生时间变量 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">TopologicalSort</span><span class="p">(</span><span class="n">GL</span><span class="p">);</span>    <span class="c1">//求拓扑序列，计算数组etv与stack2的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化ltv(事件最晚发生时间)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ltv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ltv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">etv</span><span class="p">[</span><span class="n">Gl</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//计算ltv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">top2</span> <span class="err">！</span><span class="o">=</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">gettop</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">[</span><span class="n">top2</span><span class="o">--</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">gettop</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">ltv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">ltv</span><span class="p">[</span><span class="n">geettop</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="n">ltv</span><span class="p">[</span><span class="n">gettop</span><span class="p">]</span> <span class="o">=</span> <span class="n">ltv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//求ete，lte和关键活动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span> <span class="n">e</span><span class="p">;</span> <span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ete</span><span class="o">=</span><span class="n">etv</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>                <span class="c1">//活动最早发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">lte</span><span class="o">=</span><span class="n">ltv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>    <span class="c1">//活动最迟发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">ete</span> <span class="o">==</span> <span class="n">lte</span><span class="p">){</span>            <span class="c1">//两者相等，即为关键活动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;，&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;权值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h2 id="算法分析-4">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>在求每个事件的最早和最迟发生时间，以及活动的最早最迟开始时间，都要对所有顶点及每个顶点边表中所有结点遍历，因此算法时间复杂度为 O(n+e).</p>

    </div>


    <footer>
      






<section class="see-also">
  
    
    
    
      <h3 id="参见-数据结构相关文章">
        参见 数据结构相关文章
        <a class="heading-link" href="#%e5%8f%82%e8%a7%81-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9b%b8%e5%85%b3%e6%96%87%e7%ab%a0">
          <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
          <span class="sr-only">链接到标题</span>
        </a>
      </h3>
      <nav>
        <ul>
        
        
          
            <li>
              <a href="/posts/bzyiduql6opzodxxglncvrm0nvb/">课程实训</a>
            </li>
          
        
          
            <li>
              <a href="/posts/pn4kd6n1eos5xyxutuaciqhfnjb/">排序</a>
            </li>
          
        
          
            <li>
              <a href="/posts/qtnbdqineorsxpx02uucpayvnxh/">线性表和树表的查找</a>
            </li>
          
        
          
            <li>
              <a href="/posts/rfybd7gssoktinxwskock7atn8c/">散列表的查找</a>
            </li>
          
        
          
        
          
            <li>
              <a href="/posts/lhqcd8fsiof6ckxbpvncx0vtnlg/">图的遍历</a>
            </li>
          
        
        </ul>
      </nav>
    
  
</section>


      <div id="tcomment"></div>
    </footer>
  </article>

</section>





  <script src="/js/twiko.all.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      twikoo.init({
        envId: 'https://twikoo-inaho.netlify.app/.netlify/functions/twikoo',
        el: '#tcomment'
      });
    });
  </script>


    </div>

    <footer class="footer">
  <section class="container">
    
    ©
    
      2019 -
    
    2025

    
     inaho 
    ·
    
    

    
    技术支持 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  
</body>
</html>
