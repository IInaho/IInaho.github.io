+++
authors = ["lzy"]
title = "机器学习（线性模型）"
date = "2025-03-15"
description = ""
tags = [
    "机器学习"
]
categories = [
    "机器学习"
]
+++

## 线性模型

在机器学习中，线性模型是一类较为基础且重要的模型，主要分为以下几类：
### 线性回归模型
#### 一元线性回归

用于建立一个自变量 \\(x\\) 与一个因变量 \\(y\\) 之间的线性关系，其模型形式为 \\(y = \beta_0+\beta_1x+\epsilon\\)，其中 \\(\beta_0\\) 是截距，\\(\beta_1\\) 是斜率，\\(\epsilon\\) 是误差项。

通过最小二乘法等方法估计参数 \\(\beta_0\\) 和 \\(\beta_1\\)，使得预测值与真实值之间的误差平方和最小。

简单线性回归常用于探索两个变量之间的线性关系，例如根据房屋面积预测房价。

##### 一元线性回归例子
- **数据收集**：假设我们想研究某城市居民每月用电量（度）与家庭月收入（元）之间的关系。收集了以下部分数据：
|家庭月收入（元）|每月用电量（度）|
|----|----|
|5000|120|
|6000|150|
|7000|170|
|8000|200|
|9000|220|
- **模型建立与求解**：设用电量为 \\(y\\)，家庭月收入为 \\(x\\)，根据一元线性回归模型 \\(y = \beta_0 + \beta_1x + \epsilon\\)，使用最小二乘法估计参数。经过计算（具体计算过程省略），得到回归方程为 \\(y = 30 + 0.02x\\)。
- **结果解释**：截距 \\(30\\) 表示当家庭月收入为 \\(0\\) 时，每月仍有 \\(30\\) 度的基本用电量（这在实际中可能不太符合实际意义，只是模型中的一个参数）；斜率 \\(0.02\\) 表示家庭月收入每增加 \\(1\\) 元，每月用电量平均增加 \\(0.02\\) 度。


#### 多元线性回归
简单线性回归的扩展，用于建立多个自变量 \\(x_1,x_2,\cdots,x_n\\) 与一个因变量 \\(y\\) 之间的线性关系，模型形式为 \\(y=\beta_0+\beta_1x_1+\beta_2x_2+\cdots+\beta_nx_n+\epsilon\\)。

同样通过最小二乘法等方法估计参数 \\(\beta_i\\)，以最小化误差平方和。

多元线性回归可以综合考虑多个因素对目标变量的影响，比如根据房屋面积、房龄、房间数量等多个因素预测房价。

##### 多元线性回归例子
- **数据收集**：现在我们考虑影响某商品销售额（万元）的因素，包括商品价格（元）、广告投入（万元）和销售人员数量（人）。收集到以下数据：
|商品价格（元）|广告投入（万元）|销售人员数量（人）|销售额（万元）|
|----|----|----|----|
|10|5|10|100|
|12|4|8|80|
|8|6|12|120|
|9|5|10|105|
|11|4|9|90|
- **模型建立与求解**：设销售额为 \\(y\\)，商品价格为 \\(x_1\\)，广告投入为 \\(x_2\\)，销售人员数量为 \\(x_3\\)，根据多元线性回归模型 \\(y=\beta_0+\beta_1x_1+\beta_2x_2+\beta_3x_3+\epsilon\\)，通过最小二乘法计算（具体计算过程省略），得到回归方程为 \\(y = 200 - 10x_1 + 10x_2 + 5x_3\\)。
- **结果解释**：截距 \\(200\\) 是当商品价格为 \\(0\\) 元、广告投入为 \\(0\\) 万元、销售人员数量为 \\(0\\) 人时的销售额（同样，这在实际中更多是模型意义上的参数）；\\(-10\\) 表示商品价格每增加 \\(1\\) 元，销售额平均减少 \\(10\\) 万元；\\(10\\) 表示广告投入每增加 \\(1\\) 万元，销售额平均增加 \\(10\\) 万元；\\(5\\) 表示销售人员数量每增加 \\(1\\) 人，销售额平均增加 \\(5\\) 万元。


### 广义线性模型

#### 逻辑回归
虽然名称中有“回归”，但它实际上是一种分类模型，主要用于处理二分类问题。它通过将线性函数的输出经过sigmoid函数映射到\\((0,1)\\)区间，得到样本属于某一类别的概率。

例如，根据患者的症状、检查指标等特征预测患者是否患有某种疾病，输出的是患病的概率，通过设定一个阈值（如0.5）来判断类别。

#####  sigmoid 函数

Sigmoid函数是一种常用的数学函数，在机器学习、深度学习以及其他领域中有广泛的应用。

Sigmoid函数的数学表达式为：
\\[\sigma(z)=\frac{1}{1 + e^{-z}}\\]

其中，\\(z\\) 是函数的输入，可以是一个实数、向量或矩阵。

- **值域**：Sigmoid函数的值域是\\((0,1)\\)。无论输入 \\(z\\) 取何值，函数的输出都在\\(0\\) 和\\(1\\) 之间。这一特性使得sigmoid函数非常适合用于表示概率或进行二分类任务，例如在逻辑回归中，将输出解释为属于某一类别的概率。
- **单调性**：函数在整个实数域上是单调递增的。随着 \\(z\\) 的增大，\\(\sigma(z)\\) 的值逐渐趋近于\\(1\\)；随着 \\(z\\) 的减小，\\(\sigma(z)\\) 的值逐渐趋近于\\(0\\)。
- **可微性**：Sigmoid函数是可微的，其导数可以用自身来表示，这在梯度下降等优化算法中便于计算梯度。它的导数公式为：\\(\sigma'(z)=\sigma(z)(1-\sigma(z))\\)。

#### 对数线性回归
通过对因变量取对数，将原本可能是非线性的关系转化为线性关系，从而利用线性回归的方法进行分析和建模。

## 梯度下降

### 梯度

梯度是一个向量，它在数学、物理学以及机器学习等领域都有重要的应用。

#### 数学定义
在多元函数中，设函数\\(z = f(x,y)\\)在平面区域\\(D\\)内具有一阶连续偏导数，则对于每一点\\(P(x,y)\in D\\)，都有一个向量\\(\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right)\\)与之对应，这个向量就称为函数\\(z = f(x,y)\\)在点\\(P(x,y)\\)的梯度，记作\\(\nabla f(x,y)\\)，即\\(\nabla f(x,y)=\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right)\\)。其中\\(\nabla\\)是一个向量微分算子，读作“nabla”或“del”。

对于更高维的函数\\(f(x_1,x_2,\cdots,x_n)\\)，其梯度为\\(\nabla f=( \frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\cdots,\frac{\partial f}{\partial x_n})\\)。

#### 几何意义
- 梯度的方向是函数在该点处变化最快的方向，即函数值增长最快的方向；而其反方向则是函数值下降最快的方向。
- 梯度的模（长度）表示函数在该点处沿梯度方向的变化率，模越大，函数在该方向上变化得越快。

例如，对于一个二元函数\\(z = f(x,y)\\)，在某点\\((x_0,y_0)\\)处，梯度向量\\(\nabla f(x_0,y_0)\\)所指的方向就是函数\\(z\\)在该点上升最快的方向。如果我们沿着梯度的反方向移动，那么函数值下降得最快。

#### 在机器学习中的作用
在机器学习中，梯度下降是一种常用的优化算法，用于最小化损失函数。

通过计算损失函数关于模型参数的梯度，然后沿着梯度的反方向更新参数，使得损失函数逐步减小，最终找到损失函数的最小值或局部最小值，从而确定最优的模型参数。

例如，在逻辑回归、神经网络等模型的训练过程中，经常会使用梯度下降算法来调整模型的参数，以提高模型的性能。

### 梯度下降法
梯度下降法（Gradient Descent）是一种常用的一阶最优化算法，在机器学习和深度学习领域被广泛应用，用于最小化目标函数，找到最优的模型参数，以下从多个方面为你介绍：
- **基本思想**：函数的梯度是一个向量，指向函数值增长最快的方向，那么其相反方向就是函数值下降最快的方向。梯度下降法基于此思想，从初始参数值出发，沿着目标函数梯度的反方向，以一定的步长不断更新参数，逐步逼近目标函数的局部极小值（在机器学习中，目标函数常为损失函数，目的是让模型预测值和真实值的差距最小）。 
- **具体步骤** 
    1. **初始化参数**：随机或根据经验设定一组初始参数值。比如在一元线性回归\\(y = wx + b\\)中，初始化\\(w\\)和\\(b\\)的值。
    2. **计算梯度**：对目标函数关于参数求偏导数，得到梯度。比如目标函数是均方误差函数\\(J(w,b)=\frac{1}{m}\sum_{i = 1}^{m}(y_i-(wx_i + b))^2\\)（\\(m\\)为样本数量），分别对\\(w\\)和\\(b\\)求偏导数，得到\\(\frac{\partial J}{\partial w}\\)和\\(\frac{\partial J}{\partial b}\\) ，它们组成的向量就是梯度。
    3. **更新参数**：根据梯度和学习率\\(\alpha\\)（用于控制每次参数更新的步长）来更新参数。更新公式为\\(w = w - \alpha\frac{\partial J}{\partial w}\\) ，\\(b = b - \alpha\frac{\partial J}{\partial b}\\)。 
    4. **判断终止条件**：检查是否满足终止条件，如达到最大迭代次数，或目标函数值在两次迭代之间的变化小于某个很小的阈值，若满足则停止迭代，此时的参数即为最终结果；否则返回步骤2继续迭代。
 - **常见类型**
    - **批量梯度下降（BGD）**：在每一次迭代时，使用所有的训练数据来计算梯度并更新参数。优点是梯度方向准确，能保证收敛到全局最优解（若目标函数是凸函数）；缺点是当训练数据量很大时，计算量巨大，训练速度慢，且需要较大的内存来存储所有数据。 
    - **随机梯度下降（SGD）**：每次迭代仅随机选取一个训练样本计算梯度并更新参数。优点是计算效率高，能处理大规模数据，且一定程度上可避免陷入局部最优解；缺点是更新方向受单个样本影响大，具有随机性，导致迭代过程中损失函数值波动大，可能出现振荡甚至无法收敛的情况。 
    - **小批量梯度下降（MBGD）**：综合了上述两种方法，每次从训练数据中选取一个小批量样本（如16个、32个等）来计算梯度并更新参数。既保证了计算效率，又能减少更新的随机性，使训练过程相对稳定，在实际应用中较为常用。 
- **应用场景**：广泛应用于机器学习和深度学习的模型训练中，如线性回归、逻辑回归、神经网络等模型，通过不断调整模型参数来最小化损失函数，提升模型的预测准确性。 
- **局限性与改进**：在处理一些复杂的非线性函数时，可能会出现靠近极小值时收敛速度减慢、“之字形”下降等问题，还可能陷入局部最小值或鞍点（梯度为0，但不是全局或局部最小值的点）。为了改进这些问题，研究者提出了多种优化技术，如引入动量（Momentum）、自适应调整学习率（如Adagrad、RMSprop、Adam等算法） 、使用Nesterov加速梯度（NAG）等。 

### 举例分析

我们以简单的一元线性回归为例来介绍梯度下降法。假设我们有一组数据，用来研究房屋面积（自变量\\(x\\)，单位：平方米）和房屋价格（因变量\\(y\\)，单位：万元）之间的关系，想用一元线性回归模型\\(y = wx + b\\)（\\(w\\)是权重，\\(b\\)是偏置）来拟合这些数据。

### 1. 设定初始条件
我们有\\(5\\)组数据：\\((100, 200)\\)，\\((120, 230)\\)，\\((80, 160)\\)，\\((150, 300)\\)，\\((90, 180)\\)。
初始设定参数\\(w = 1\\)，\\(b = 10\\)，学习率\\(\alpha = 0.00001\\) ，最大迭代次数为\\(1000\\)次。
损失函数采用均方误差（MSE），公式为\\(J(w,b)=\frac{1}{n}\sum_{i = 1}^{n}(y_i-(wx_i + b))^2\\)，这里\\(n = 5\\)是样本数量。

### 2. 计算梯度
对损失函数\\(J(w,b)\\)分别求关于\\(w\\)和\\(b\\)的偏导数：
\\(\frac{\partial J}{\partial w}=\frac{2}{n}\sum_{i = 1}^{n}x_i((wx_i + b)-y_i)\\)
\\(\frac{\partial J}{\partial b}=\frac{2}{n}\sum_{i = 1}^{n}((wx_i + b)-y_i)\\) 

以第一次迭代为例，代入初始值和数据计算：
\\(\frac{\partial J}{\partial w}=\frac{2}{5}×[100×((1×100 + 10)-200)+120×((1×120 + 10)-230)+80×((1×80 + 10)-160)+150×((1×150 + 10)-300)+90×((1×90 + 10)-180)]\\)
\\(=\frac{2}{5}×[100×(-90)+120×(-100)+80×(-70)+150×(-140)+90×(-80)]\\)
\\(=\frac{2}{5}×(-9000 - 12000 - 5600 - 21000 - 7200)\\)
\\(=-22560\\)

\\(\frac{\partial J}{\partial b}=\frac{2}{5}×[((1×100 + 10)-200)+((1×120 + 10)-230)+((1×80 + 10)-160)+((1×150 + 10)-300)+((1×90 + 10)-180)]\\)
\\(=\frac{2}{5}×(-90 - 100 - 70 - 140 - 80)\\)
\\(=-232\\)

### 3. 更新参数
根据梯度和学习率更新参数：
\\(w = w - \alpha\frac{\partial J}{\partial w}=1 - 0.00001×(-22560)=1 + 0.2256 = 1.2256\\)
\\(b = b - \alpha\frac{\partial J}{\partial b}=10 - 0.00001×(-232)=10 + 0.00232 = 10.00232\\)

### 4. 判断终止条件
这里我们判断是否达到最大迭代次数，若未达到，返回步骤2继续计算新的梯度并更新参数；若达到，此时的\\(w\\)和\\(b\\)就是通过梯度下降法得到的模型参数。

通过不断迭代，参数\\(w\\)和\\(b\\)会逐渐调整，使得损失函数\\(J(w,b)\\)越来越小，最终得到能较好拟合数据的线性回归模型。 


## 损失函数

损失函数（Loss Function）是用来估量模型的预测值与真实值之间差异的函数。在不同的任务和模型中，损失函数的定义方式有所不同，以下是一些常见的损失函数定义方式：

### 回归任务
#### 均方误差（Mean Squared Error, MSE）

均方误差（Mean Squared Error，MSE）是衡量预测值与真实值之间差异程度的一种常用指标，计算预测值与真实值之间差值的平方的平均值，能很好地反映模型的拟合程度，是回归问题中最常用的损失函数之一。

对于一组具有\\(n\\)个观测值的数据，设\\(y_i\\)为第\\(i\\)个真实值，\\(\hat{y}_i\\)为对应的预测值。

均方误差的计算公式为：
\\[MSE=\frac{1}{n}\sum_{i = 1}^{n}(y_i-\hat{y}_i)^2\\]

- 衡量模型精度：MSE 用于评估预测模型的准确性。其值越小，说明模型对数据的拟合程度越高，预测值与真实值越接近，模型的性能也就越好；反之，MSE 值越大，表明模型的预测效果越差。
- 比较不同模型：在比较多个不同的预测模型时，均方误差是一个很有用的指标。通过比较不同模型在同一数据集上的 MSE，可以选择出最适合该数据集的模型，即 MSE 最小的模型。

##### 举例分析
假设有一组真实值\\([1, 3, 5, 7, 9]\\)，对应的预测值为\\([1.2, 2.8, 5.3, 6.9, 9.1]\\)。

首先计算每个数据点的误差平方：

\\((1 - 1.2)^2 = 0.04\\)，\\((3 - 2.8)^2 = 0.04\\)，\\((5 - 5.3)^2 = 0.09\\)，\\((7 - 6.9)^2 = 0.01\\)，\\((9 - 9.1)^2 = 0.01\\)。

然后将这些误差平方相加并求平均值：\\(MSE = \frac{0.04 + 0.04 + 0.09 + 0.01 + 0.01}{5}=0.038\\)。

#### 平均绝对误差（Mean Absolute Error, MAE）

计算预测值与真实值之间差值的绝对值的平均值，公式为\\(MAE=\frac{1}{n}\sum_{i = 1}^{n}|y_i - \hat{y}_i|\\)。

相比均方误差，平均绝对误差对异常值的敏感度较低，因为它不使用平方运算。

### 分类任务
#### 对数损失函数
对数损失函数（Log Loss Function），也称为对数似然损失函数（Log-likelihood Loss Function）或交叉熵损失函数（Cross-Entropy Loss Function），是机器学习中用于分类问题的一种重要损失函数，尤其在逻辑回归、神经网络等模型中被广泛应用。

对数损失函数是一种衡量模型预测概率分布与真实标签分布之间差异的指标。它通过对预测概率取对数来计算损失，预测概率越接近真实标签，损失越小；反之，损失越大。

对数损失函数基于极大似然估计的思想。
在分类问题中，我们希望模型预测的概率分布尽可能接近真实的概率分布。
通过最大化似然函数（即样本出现的概率），可以找到最优的模型参数。
而对数损失函数实际上是负对数似然函数的平均值，因此最小化对数损失函数等价于最大化似然函数。

##### 二分类问题
假设样本的真实标签 \\(y\\) 取值为 \\(0\\) 或 \\(1\\)，模型预测样本属于正类的概率为 \\(\hat{y}\\)，则单个样本的对数损失函数公式为：
\\[L(y,\hat{y}) = - [y \log(\hat{y})+(1 - y)\log(1 - \hat{y})]\\]
对于包含 \\(N\\) 个样本的数据集，对数损失函数为所有样本损失的平均值：
\\[L = - \frac{1}{N}\sum_{i = 1}^{N}[y_i \log(\hat{y}_i)+(1 - y_i)\log(1 - \hat{y}_i)]\\]
##### 多分类问题
假设样本有 \\(K\\) 个类别，真实标签 \\(y\\) 是一个 \\(K\\) 维的one - hot向量（只有一个元素为 \\(1\\)，其余元素为 \\(0\\)，模型预测样本属于第 \\(k\\) 类的概率为 $\hat{y}_k$，则单个样本的对数损失函数公式为：

\\[L(y,\hat{y}) = - \sum_{k = 1}^{K}y_k \log(\hat{y}_k)\\]

对于 \\(N\\) 个样本的数据集，对数损失函数为：
\\[L = - \frac{1}{N}\sum_{i = 1}^{N}\sum_{k = 1}^{K}y_{i,k} \log(\hat{y}_{i,k})\\]


##### 公式含义
- 对数损失函数由两部分组成：
    - \\(-y_i\beta^{\mathrm{T}}\hat{\boldsymbol{x}}_i\\) ：这部分反映了真实标签\\(y_i\\)对损失的影响。当\\(y_i = 1\\)时，该项就是\\(-\beta^{\mathrm{T}}\hat{\boldsymbol{x}}_i\\)，意味着模型预测结果越接近\\(1\\)（正类），该项的值越大（损失越小）；当\\(y_i = 0\\)时，该项为\\(0\\)，对损失没有直接贡献 。
    - \\(\ln(1 + e^{\beta^{\mathrm{T}}\hat{\boldsymbol{x}}_i})\\) ：这部分起到了对模型预测结果的惩罚作用。无论\\(y_i\\)取值如何，它都会对损失产生影响。如果模型预测结果偏离真实标签越远，这部分的值就越大，损失也就越大。
 - 整个公式通过对\\(m\\)个样本的损失项求和，得到了所有样本的总损失 。在训练逻辑回归模型时，通常使用梯度下降等优化算法来调整参数\\(\beta\\)，使得对数损失函数\\(l(\beta)\\)最小化，从而让模型的预测结果尽可能接近真实标签。 

##### 举例分析
假设我们有一个简单的二分类逻辑回归问题，判断邮件是否为垃圾邮件。有\\(3\\)个训练样本，特征为邮件中特定关键词的出现次数，标签\\(1\\)表示垃圾邮件，\\(0\\)表示正常邮件。数据如下：

|样本序号\\(i\\)|关键词出现次数\\(\hat{\boldsymbol{x}}_i\\)|是否为垃圾邮件\\(y_i\\)|
| ---- | ---- | ---- |
|1|2|1|
|2|1|0|
|3|3|1|

设参数向量\\(\beta = [\beta_0, \beta_1]^T\\) ，这里\\(\beta_0\\)是截距项，\\(\beta_1\\)是与关键词出现次数对应的权重，为方便计算，假设\\(\beta_0 = 0.5\\)，\\(\beta_1 = 0.3\\)。

对于样本\\(1\\)：

\\(\beta^T\hat{\boldsymbol{x}}_1=\beta_0\times1+\beta_1\times2 = 0.5 + 0.3\times2=1.1\\) 

\\(-y_1\beta^T\hat{\boldsymbol{x}}_1=-1\times1.1 = -1.1\\) 

\\(\ln(1 + e^{\beta^T\hat{\boldsymbol{x}}_1})=\ln(1 + e^{1.1})\approx1.33\\) 

对于样本\\(2\\)：

\\(\beta^T\hat{\boldsymbol{x}}_2=\beta_0\times1+\beta_1\times1 = 0.5+0.3\times1 = 0.8\\) 

\\(-y_2\beta^T\hat{\boldsymbol{x}}_2=-0\times0.8 = 0\\) 

\\(\ln(1 + e^{\beta^T\hat{\boldsymbol{x}}_2})=\ln(1 + e^{0.8})\approx1.14\\) 

对于样本\\(3\\)：

\\(\beta^T\hat{\boldsymbol{x}}_3=\beta_0\times1+\beta_1\times3 = 0.5+0.3\times3 = 1.4\\) 

\\(-y_3\beta^T\hat{\boldsymbol{x}}_3=-1\times1.4 = -1.4\\) 

\\(\ln(1 + e^{\beta^T\hat{\boldsymbol{x}}_3})=\ln(1 + e^{1.4})\approx1.51\\) 

那么对数损失函数值\\(l(\beta)\\)为：

\\(l(\beta)=(-1.1 + 1.33)+(0 + 1.14)+(-1.4 + 1.51) = 1.48\\) 

通过不断调整\\(\beta_0\\)和\\(\beta_1\\)的值，利用梯度下降等方法让\\(l(\beta)\\)尽可能小，从而优化逻辑回归模型。 


### 线性判别分析
#### Fisher线性判别分析（FLDA）
一种经典的线性判别方法，旨在找到一个线性投影方向，使得不同类别的数据在该方向上的投影尽可能分开，同时同一类别的数据在该方向上的投影尽可能聚集。

它通过最大化类间散度与类内散度的比值来确定投影方向，常用于二分类和多分类问题，例如将不同种类的植物根据其特征进行分类。


#### 感知机
一种最简单的线性分类器，它通过一个线性函数将输入特征映射到输出类别，输出为\\(+1\\)或\\(-1\\)，分别代表不同的类别。

感知机的学习过程是通过调整权重向量来使得分类错误的样本逐渐被正确分类，它是神经网络的基础，为后续更复杂的神经网络模型提供了灵感。



## 单位阶跃函数

单位阶跃函数，又称Heaviside函数，通常用\\(u(t)\\)表示，是一个在数学和工程领域中广泛应用的特殊函数，以下是其定义、图像、性质和应用方面的介绍：
- **定义**：
    - 对于自变量\\(t\\)，单位阶跃函数\\(u(t)\\)定义为\\(u(t)=\begin{cases}0, & t<0 \\\\ 1, & t\geq0\end{cases}\\)。也就是说，在\\(t = 0\\)处函数值发生跳变，从\\(0\\)跳变到\\(1\\)，在\\(t < 0\\)时函数值恒为\\(0\\)，在\\(t \geq 0\\)时函数值恒为\\(1\\)。
- **函数图像**：
    - 其图像是一条在\\(t = 0\\)处有一个单位跳跃的水平直线。在\\(t < 0\\)的区间，图像位于\\(t\\)轴上，即\\(y = 0\\)；在\\(t \geq 0\\)的区间，图像是平行于\\(t\\)轴且位于\\(y = 1\\)的直线。在\\(t = 0\\)这一点，函数值从\\(0\\)突变到\\(1\\)，这个点是不连续的。
- **性质**
    - **积分性质**：单位阶跃函数的积分是斜坡函数。即\\(\int_{-\infty}^{t}u(\tau)d\tau = tu(t)\\)。斜坡函数在\\(t < 0\\)时为\\(0\\)，在\\(t \geq 0\\)时为\\(t\\)，它描述了一个随时间线性增长的过程。
    - **导数性质**：单位阶跃函数的导数是冲激函数\\(\delta(t)\\)，即\\(u^\prime(t)=\delta(t)\\)。冲激函数是一种理想化的数学模型，它在\\(t = 0\\)处有一个无穷大的“尖峰”，其面积为\\(1\\)，在其他时刻值为\\(0\\)。
- **应用**
    - **信号处理**：用于表示信号的起始时刻。例如，一个在\\(t = 0\\)时刻开始的直流信号可以表示为\\(A u(t)\\)，其中\\(A\\)是信号的幅度。这样可以方便地对信号进行数学描述和分析，在分析线性时不变系统对信号的响应等方面有重要作用。
    - **电路分析**：可以用来描述电路中开关的动作。当开关在\\(t = 0\\)时刻闭合时，电路中的电流或电压可能会发生突变，这种突变可以用单位阶跃函数来表示，有助于分析电路在不同时刻的状态。


## 线性判别分析

线性判别分析（Linear Discriminant Analysis，简称LDA）可以简单理解为一种给事物分类的方法，就像给不同的水果分类一样。

假设有一堆苹果和橙子混在一起，我们想把它们分开。我们可以观察水果的一些特征，比如颜色、大小、形状等。LDA就是要找到一个最佳的“分界线”（在数学上是一个线性函数），根据这些特征把苹果和橙子尽可能准确地分开。

具体来说，LDA会先看每类水果（比如苹果和橙子）的特征分布情况，计算出它们各自的“中心”位置，然后找到一个方向，让不同类水果在这个方向上的差异尽可能大，而同类水果在这个方向上的差异尽可能小。这样，当我们把新的水果放到这个“分界线”上时，就可以根据它在这个方向上的位置来判断它更可能是苹果还是橙子。

在实际应用中，LDA可以用于很多领域，比如在医学上根据病人的症状、检查结果等特征来判断病人是患有某种疾病还是健康的；在图像识别中，根据图像的特征来判断图像是属于猫、狗还是其他物体等。总之，LDA就是通过找到一个最佳的线性分类器，帮助我们根据事物的特征对它们进行分类。

### 举例分析

好的，下面通过一个简单的二维数据分类例子来说明线性判别分析（LDA）的具体过程。

假设我们要对两类数据点进行分类，一类是蓝色的数据点（类别\\(C_1\\)），另一类是红色的数据点（类别\\(C_2\\)）。这两类数据点的分布情况如下：

类别\\(C_1\\)的数据点：\\((1, 1)\\)，\\((1, 2)\\)，\\((2, 1)\\)，\\((2, 2)\\)
类别\\(C_2\\)的数据点：\\((4, 4)\\)，\\((4, 5)\\)，\\((5, 4)\\)，\\((5, 5)\\)

具体步骤如下：

1. **计算各类别数据的均值向量**
对于类别\\(C_1\\)：
\\(\mu_1 = \frac{(1, 1) + (1, 2) + (2, 1) + (2, 2)}{4} = (\frac{1 + 1 + 2 + 2}{4}, \frac{1 + 2 + 1 + 2}{4}) = (1.5, 1.5)\\)

对于类别\\(C_2\\)：
\\(\mu_2 = \frac{(4, 4) + (4, 5) + (5, 4) + (5, 5)}{4} = (\frac{4 + 4 + 5 + 5}{4}, \frac{4 + 5 + 4 + 5}{4}) = (4.5, 4.5)\\)

2. **计算类内散度矩阵\\(S_w\\)**
类内散度矩阵是衡量同一类别内数据点的离散程度的矩阵。
对于类别\\(C_1\\)，计算每个数据点与均值向量\\(\mu_1\\)的差值的平方和，再求和：
\\[
\begin{align*}
S_{w1}&=\sum_{x\in C_1}(x - \mu_1)(x - \mu_1)^T\\\\
&=((1, 1) - (1.5, 1.5))((1, 1) - (1.5, 1.5))^T + ((1, 2) - (1.5, 1.5))((1, 2) - (1.5, 1.5))^T\\\\
&+ ((2, 1) - (1.5, 1.5))((2, 1) - (1.5, 1.5))^T + ((2, 2) - (1.5, 1.5))((2, 2) - (1.5, 1.5))^T\\\\
&=\begin{pmatrix}0.5\\\\ -0.5\end{pmatrix}\begin{pmatrix}0.5 & -0.5\end{pmatrix} + \begin{pmatrix}-0.5\\\\ 0.5\end{pmatrix}\begin{pmatrix}-0.5 & 0.5\end{pmatrix} + \begin{pmatrix}0.5\\\\ -0.5\end{pmatrix}\begin{pmatrix}0.5 & -0.5\end{pmatrix} + \begin{pmatrix}0.5\\\\ 0.5\end{pmatrix}\begin{pmatrix}0.5 & 0.5\end{pmatrix}\\\\
&=\begin{pmatrix}0.5 & -0.5\\\\ -0.5 & 0.5\end{pmatrix} + \begin{pmatrix}0.25 & -0.25\\\\ -0.25 & 0.25\end{pmatrix} + \begin{pmatrix}0.25 & -0.25\\\\ -0.25 & 0.25\end{pmatrix} + \begin{pmatrix}0.25 & 0.25\\\\ 0.25 & 0.25\end{pmatrix}\\\\
&=\begin{pmatrix}1.25 & -0.5\\\\ -0.5 & 1.25\end{pmatrix}
\end{align*}
\\]

同理，对于类别\\(C_2\\)，可得\\(S_{w2}=\begin{pmatrix}1.25 & -0.5\\\\ -0.5 & 1.25\end{pmatrix}\\)

则类内散度矩阵\\(S_w = S_{w1} + S_{w2} = \begin{pmatrix}2.5 & -1\\\\ -1 & 2.5\end{pmatrix}\\)

3. **计算类间散度矩阵\\(S_b\\)**
类间散度矩阵衡量的是不同类别之间的差异程度。
\\(S_b = (\mu_1 - \mu_2)(\mu_1 - \mu_2)^T = ((1.5, 1.5) - (4.5, 4.5))((1.5, 1.5) - (4.5, 4.5))^T = \begin{pmatrix}-3\\\\ -3\end{pmatrix}\begin{pmatrix}-3 & -3\end{pmatrix} = \begin{pmatrix}9 & 9\\\\ 9 & 9\end{pmatrix}\\)

4. **求解广义特征值问题，得到投影方向\(w\)**
我们要找到一个向量\\(w\\)，使得\\(S_w^{-1}S_b w = \lambda w\\)（\\(\lambda\\) 是特征值）。
先求\\(S_w\\)的逆矩阵\\(S_w^{-1}\\)\\(=\begin{pmatrix}0.4762 & 0.1905\\\\ 0.1905 & 0.4762\end{pmatrix}\\)

然后计算\\(S_w^{-1}S_b\\)\\(=\begin{pmatrix}6 & 6\\\\ 6 & 6\end{pmatrix}\\)

求\\(S_w^{-1}S_b\\)的特征值和特征向量，得到特征值\\(\lambda_1 = 12\\)，\\(\lambda_2 = 0\\)，对应的特征向量\\(w_1 = \begin{pmatrix}1\\\\ 1\end{pmatrix}\\)，\\(w_2 = \begin{pmatrix}-1\\\\ 1\end{pmatrix}\\)。我们取最大特征值对应的特征向量\\(w = \begin{pmatrix}1\\\\ 1\end{pmatrix}\\)作为投影方向。

5. **将数据投影到\\(w\\)方向上进行分类**
对于类别\\(C_1\\)的数据点，投影后的结果例如：
\\((1, 1)\\)投影到\\(w\\)方向上的值为\\((1, 1)\cdot\begin{pmatrix}1\\\\ 1\end{pmatrix} = 2\\)

对于类别\\(C_2\\)的数据点，投影后的结果例如：
\\((4, 4)\\)投影到\\(w\\)方向上的值为\\((4, 4)\cdot\begin{pmatrix}1\\\\ 1\end{pmatrix} = 8\\)

通过观察投影后的数据点的分布，我们可以确定一个合适的阈值来进行分类，比如阈值取\\(5\\)，投影值小于\\(5\\)的归为类别\\(C_1\\)，投影值大于\\(5\\)的归为类别\\(C_2\\)。

这就是一个简单的线性判别分析的例子，通过找到合适的投影方向，将数据投影后进行分类。实际应用中数据可能更复杂，维度更高，但基本原理是一样的。 