<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>传输层与UDP协议简述</title>
    <link href="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <url>/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输层概述与UDP协议简述"><a href="#传输层概述与UDP协议简述" class="headerlink" title="传输层概述与UDP协议简述"></a>传输层概述与UDP协议简述</h1><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><ul><li>传输层协议UDP和TCP</li><li>网络安全</li><li>TCP可靠传输的实现</li><li>TCP的流量控制</li><li>TCP的拥塞控制</li><li>TCP的运输连接管理</li></ul><h2 id="OSI和DOD模型"><a href="#OSI和DOD模型" class="headerlink" title="OSI和DOD模型"></a>OSI和DOD模型</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/2.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="传输层两个协议"><a href="#传输层两个协议" class="headerlink" title="传输层两个协议"></a>传输层两个协议</h2><p>在TCP/IP协议栈，传输层有两个协议TCP和UDP。</p><ul><li>TCP(Transmission Control Protocol)传输控制协议</li><li>UDP(User Data Protocol)用户数据报协议</li></ul><p>TCP 需要将要传输的文件分段 传输 建立会话 可靠传输 流量控制<br>UDP 一个数据包就能够完成数据通信 不分段 不需要建立会话 不需要流量控制 不可靠传输 (屏幕广播 多播 广播)</p><h2 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/3.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="常见的应用层协议使用端口"><a href="#常见的应用层协议使用端口" class="headerlink" title="常见的应用层协议使用端口"></a>常见的应用层协议使用端口</h2><ul><li>http = TCP + 80</li><li>https = TCP + 443</li><li>RDP = TCP + 3389</li><li>ftp = TCP + 21</li><li>共享文件夹 = TCP + 445</li><li>SMTP = TCP + 25</li><li>POP3 = TCP + 110</li><li>telnet = TCP + 23</li><li>SQL = TCP + 1433</li><li>DNS = UDP + 53</li></ul><h2 id="服务和应用层协议之间的关系"><a href="#服务和应用层协议之间的关系" class="headerlink" title="服务和应用层协议之间的关系"></a>服务和应用层协议之间的关系</h2><ul><li>服务使用TCP或UDP的端口侦听客户端请求</li><li>客户端使用IP地址定位服务器 使用目标端口定位服务</li><li>可以在服务器网卡上设置只开放必要的端口 实现服务器网络安全</li><li>可以更改服务使用的默认端口，迷惑病毒，让系统更安全</li></ul><h2 id="如何查看服务侦听的端口"><a href="#如何查看服务侦听的端口" class="headerlink" title="如何查看服务侦听的端口"></a>如何查看服务侦听的端口</h2><pre><code>netstat -anetstat -an 以数字的形式查看端口netstat -n 查看建立的会话netstat -nb 查看建立会话的进程telnet 192.168.80.100 3389 测试到远程计算机某个端口是否打开</code></pre><h2 id="传输层的功能-1"><a href="#传输层的功能-1" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>为相互通信的应用进程提供了端到端的逻辑通信</li><li>传输层还要对收到的报文进行差错检测</li><li>传输层提供面向连接和无连接的服务</li></ul><h2 id="传输层协议和网络层协议的主要区别"><a href="#传输层协议和网络层协议的主要区别" class="headerlink" title="传输层协议和网络层协议的主要区别"></a>传输层协议和网络层协议的主要区别</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/5.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/6.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>端口用一个16位端口号进行标志</li><li>端口号只具有本地意义，即端口号只为了标志本计算机应用层中的各进程。在因特网中不同的计算机的相同端口号是没有联系的。</li><li>熟知端口，数值一般为0-1023.</li><li>登记端口号，数值为1024-49151.</li><li>客户端口号，数值为49152-65535.</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>UDP是无连接的，即发送数据之前不需要建立连接</li><li>UDP使用最最大努力交付，及不保证可靠交付，同时也不使用拥塞控制。</li><li>UDP是面向报文的，UDP没有拥塞控制，适合多媒体通信的要求。</li><li>UDP支持一对一，一对多，多对多的交互通信。</li><li>UDP的首部开销小，只有8字节。</li></ul><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/7.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/8.png" srcset="/img/loading.gif" width="375px" height="220px"><br>首部中的长度指的是UDP用户数据报的长度(首部+数据)，伪首部用于检验和。</p><h3 id="计算UDP检验和的例子"><a href="#计算UDP检验和的例子" class="headerlink" title="计算UDP检验和的例子"></a>计算UDP检验和的例子</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/9.png" srcset="/img/loading.gif" width="375px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP数据包与路由</title>
    <link href="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h2><p>一个IP数据包由首部和数据两部分组成。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/2.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部的前一部分是固定长度，共字节，是所有IP数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><h3 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h3><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>版本：用来表示TCP/IP协议的版本 v4,v6</li><li>首部长度：确定数据包首部有多长，因为包含可变部分。</li><li>区分服务：确定更高的传输优先级。(QoS机制)</li><li>总长度：确定数据部分长度，一共16位，最多有2^16-1=65535字节。</li></ul><blockquote><p>传输限制：数据包最大65535字节，而数据链路层最大传输1500字节，所以对于大于1500字节的数据包，将会进行分片传输。（最大传输单元MTU）<br>分片传输：将数据进行分割，分别添加IP地址，通过网络发给接收端。接收端在通过网络层进行拼接，传送过程中可能存在丢包现象，或者后发的先到，所以需要对分片的数据包进行编号。<br>泪滴攻击：指的是向目标机器发送损坏的IP包，诸如重叠的包或者过大的包载荷。借由这些手段，该攻击可以通过TCP/IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p></blockquote><p>以太网V2数据帧模式：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>标识：如果出现数据包分片，那么标识用来确定哪些数据包需要组合，进行相同标记。</li><li>标志：占位，目前只有前两位有意义。标志字段的最低位是MF(More Fragment)，MF=1表示后面还有分片，MF=0表示最后一个分片，标志字段中间的一位是DF(Don`t Fragment)，只有当DF=0时才允许分片。</li></ul><p>数据包分片举例：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/5.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>片偏移：偏移等于当前字节在数据部分的第几个再除以8.</li><li>生存时间：就是TTL(Time To Live)，每经过一个路由器就减1，8位二进制，作用是防止数据包在网络中循环。</li><li>协议号：用协议号标识数据部分是什么数据。<blockquote><p>ICMP：1, IGMP：2, TCP：6, UDP：17, IPv6：41, OSPF：89</p></blockquote></li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部检验和：16位，只检验数据报的首部，不检验数据部分，这里不是采用CRC而是简单的计算方法，每经过一个路由器就会检验一次。</li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/7.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>源地址和目的地址：都是IP地址，32位，只符合IPv4.IPv6是128位。</li><li>可变部分：一般没用，IPv6已取消。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="网络畅通的条件"><a href="#网络畅通的条件" class="headerlink" title="网络畅通的条件"></a>网络畅通的条件</h3><p>沿途路由器必须知道下一跳给谁，数据包有去有回。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/8.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>需要管理员手动设置路由表，适用于小规模网络，不能自动调整路由。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol><li>RIP协议<br>作用是周期性广播路由表，选择最佳路径，能够自动学习路由，最大15跳，不适合大规模网络。</li><li>OSPF协议<br>根据带宽选择路径</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICMP与IGMP协议</title>
    <link href="/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ICMP与IGMP协议"><a href="#ICMP与IGMP协议" class="headerlink" title="ICMP与IGMP协议"></a>ICMP与IGMP协议</h1><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol).</p><ul><li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</li><li>ICMP 不是高层协议，而是IP层的协议。</li><li>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据包发送出去。</li></ul><h2 id="ping命令诊断网络故障"><a href="#ping命令诊断网络故障" class="headerlink" title="ping命令诊断网络故障"></a>ping命令诊断网络故障</h2><ul><li>PING(Packet Internet Grope),因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</li><li>ping指的是端对端连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数 防火墙的一个基本功能提供给用户进行选择。</li><li>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</li></ul><h3 id="使用ICMP协议的命令"><a href="#使用ICMP协议的命令" class="headerlink" title="使用ICMP协议的命令"></a>使用ICMP协议的命令</h3><p>TTL是数据报的生存时间，每过一个路由器就会减1，作用是防止数据报在网络中循环。<br>TTL默认初始值如下：</p><ul><li>Linux 64</li><li>Windows 128</li><li>Unix 255</li></ul><h3 id="ping与pathping命令"><a href="#ping与pathping命令" class="headerlink" title="ping与pathping命令"></a>ping与pathping命令</h3><p>pathing能跟踪数据包路径，发现问题位置。<br>Windows上跟踪数据包路径的命令：tracerert ip地址<br>路由器上跟踪数据包路径的命令： traceroute ip地址</p><h2 id="IGMP协议与多播"><a href="#IGMP协议与多播" class="headerlink" title="IGMP协议与多播"></a>IGMP协议与多播</h2><p>数据通信分为点到点通信，广播通信，还有组播通信。组播也称为多播通信。<br>多播通信可以跨网段，将数据同时传递给多个计算机，避免了占用大量带宽。<br>使用多播一般用于直播，网络会议等。<br>IGMP协议的作用就是周期性扫描本网段内有没有主机在访问多播数据包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层概述与ARP协议</title>
    <link href="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IOS网络层概述"><a href="#IOS网络层概述" class="headerlink" title="IOS网络层概述"></a>IOS网络层概述</h1><h2 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h2><p>负责在不同网络之间尽力转发数据包</p><blockquote><ul><li>基于数据包的IP地址转发</li></ul></blockquote><ul><li>不负责丢失重传</li><li>不负责顺序</li></ul><h2 id="数据包在Internet中传输"><a href="#数据包在Internet中传输" class="headerlink" title="数据包在Internet中传输"></a>数据包在Internet中传输</h2><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/2.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>路由器是三层设备：能看到网络层的IP地址来选择路径</p></blockquote><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/3.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h2 id="互联网与虚拟互联网"><a href="#互联网与虚拟互联网" class="headerlink" title="互联网与虚拟互联网"></a>互联网与虚拟互联网</h2><h3 id="互联网互联的设备"><a href="#互联网互联的设备" class="headerlink" title="互联网互联的设备"></a>互联网互联的设备</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/4.png" srcset="/img/loading.gif" width="420px" height="250px"></p><ol><li>物理层中继系统：转发器(repeater)，类似集线器</li><li>数据链路层中继系统：网桥或桥接器(bridge)</li><li>网络层中继系统：路由器(router)</li><li>传输层/应用层中继系统：网关(gateway)</li></ol><blockquote><p>中间设备又称为中间系统或中继系统(relay).<br>网关就是路由器接口的地址。一般是本网段第一个地址。</p></blockquote><h3 id="网络需要解决的问题"><a href="#网络需要解决的问题" class="headerlink" title="网络需要解决的问题"></a>网络需要解决的问题</h3><ol><li>不同寻址方案</li><li>不同最大分组长度</li><li>不同网络接入机制</li><li>不同超时控制</li><li>不同差错恢复方法</li><li>不同状态报告方法</li><li>不同路由选择技术</li><li>不同用户接入控制</li><li>不同服务</li><li>不同管理与控制方式</li></ol><blockquote><p>虚拟互联网将复杂的互联网抽象成一个网络，这样用户只需要关心如何接入互联网而不需要关心互联网的复杂性，简化了问题模型。</p></blockquote><h2 id="网络设备和OSI参考模型的关系"><a href="#网络设备和OSI参考模型的关系" class="headerlink" title="网络设备和OSI参考模型的关系"></a>网络设备和OSI参考模型的关系</h2><h3 id="PC4向PC3传输数据"><a href="#PC4向PC3传输数据" class="headerlink" title="PC4向PC3传输数据"></a>PC4向PC3传输数据</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/5.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h4 id="发送端："><a href="#发送端：" class="headerlink" title="发送端："></a>发送端：</h4><ol><li>应用层准备要传输的数据文件；</li><li>传输层把数据进行分段并编号；(数据段)</li><li>网络层把传输层的每一个数据包增加原IP地址和目标IP地址；(数据包)</li><li>数据链路层把每个数据加上MAC地址；(数据帧)</li><li>物理层把数据帧变成数字信号(bit流)</li></ol><p>如何通过Mac地址进行转发数据:</p><ul><li>使用本计算机地址的子网掩码，判断本地址和目标地址分别在哪个网段，若在同一个网段(不过路由器)，通过ARP协议广播的方式得到目标IP地址的MAC地址，然后就能封装出一个数据帧；</li><li>如果子网掩码不是一个网段(与运算)，通过ARP协议广播的方式得到路由器(网关)的MAC地址，然后把数据通过交换机发送到路由器M2，路由器M2在通过广播的方式得到目标IP地址与Mac地址。</li></ul><blockquote><p>因为M2和M3是点对点通信，没有别的主机，所以它们之间的MAC地址就是FF。</p></blockquote><h4 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h4><ol><li>交换机Hub0接收bit流，能对数据进行存储转发。它根据数据帧的MAC地址，确定数据是从哪来的，要去哪。</li><li>路由器M2获取交换机的数据包，识别其中的IP地址，根据路由表选择出口，它无法识别数据段内容。</li><li>路由器M2到M3是点对点通信，遵守PPP协议。</li><li>PC3收到bit流后，数据链路层发现MAC地址是自己的，去掉MAC地址给它的网络层，网络层去掉IP地址给传输层，传输层把数据给应用层，应用层把各个数据拼接起来，进而得到文件。</li></ol><h4 id="路由器与交换机、集线器会不会中病毒？"><a href="#路由器与交换机、集线器会不会中病毒？" class="headerlink" title="路由器与交换机、集线器会不会中病毒？"></a>路由器与交换机、集线器会不会中病毒？</h4><p>不会，因为路由器不能识别数据内容，只进行数据的传递，而交换机与集线器分别工作在数据链路层与物理层，更不会中病毒。但病毒可以影响网络设备的正常工作，例如频繁广播发送数据，占用带宽影响效率，使这些设备一直处于忙碌状态。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="TCP-IP协议层次关系"><a href="#TCP-IP协议层次关系" class="headerlink" title="TCP/IP协议层次关系"></a>TCP/IP协议层次关系</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/6.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>ARP协议为IP协议提供服务，IP协议为ICMP与IGMP协议提供服务。</p></blockquote><h3 id="ARP协议功能"><a href="#ARP协议功能" class="headerlink" title="ARP协议功能"></a>ARP协议功能</h3><p>将IP地址通过广播，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址，只能在本网段使用，ARP是解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射关系。<br>如果所找的主机和原主机不在同一个局域网上，那么就要通过ARP找一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。<br>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知情的，只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址。</p><blockquote><p>arp -a可以查看本地解析过的Mac表缓存。<br>逆地址解析协议(RARP)：只知道自己MAC地址就能获得其IP地址。</p></blockquote><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>ARP欺骗的运作原理是由攻击者发送假的ARP数据包到网上，尤其是送到网关上。其目的是要让送至特定的IP地址的流量被错误送到攻击者所取代的地方。因此攻击者可将这些流量另行转送到真正的网关（被动式数据包嗅探，passive sniffing）或是篡改后再转送（中间人攻击，man-in-the-middle attack）。攻击者亦可将ARP数据包导到不存在的MAC地址以达到阻断服务攻击的效果，例如netcut软件。<br>例如：某一的IP地址是192.168.0.254，其MAC地址为00-11-22-33-44-55，网上上的计算机内ARP表会有这一笔ARP记录。攻击者发动攻击时，会大量发出已将192.168.0.254的MAC地址篡改为00-55-44-33-22-11的ARP数据包。那么网上上的计算机若将此伪造的ARP写入自身的ARP表后，计算机若要透过网上网关连到其他计算机时，数据包将被导到00-55-44-33-22-11这个MAC地址，因此攻击者可从此MAC地址截收到数据包，可篡改后再送回真正的网关，或是什么也不做，让网上无法连线。</p><h3 id="防止ARP欺骗的两种方法"><a href="#防止ARP欺骗的两种方法" class="headerlink" title="防止ARP欺骗的两种方法"></a>防止ARP欺骗的两种方法</h3><ol><li>静态绑定，使用arp -s 命令进行静态绑定，静态绑定后双方计算机通信不在使用ARP协议进行动态获取，可直接进行对目标计算机的通信。可将脚本命令编辑成.bat脚本，用gpedit.msc打开组策略，在开机登陆中添加该脚本，则脚本代码开机自动启动。</li><li>使用ARP防火墙进行防御。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac层与快速以太网</title>
    <link href="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Mac层与快速以太网"><a href="#Mac层与快速以太网" class="headerlink" title="Mac层与快速以太网"></a>Mac层与快速以太网</h1><h2 id="Mac层的硬件地址"><a href="#Mac层的硬件地址" class="headerlink" title="Mac层的硬件地址"></a>Mac层的硬件地址</h2><ul><li>在局域网中，硬件地址又称为物理地址，或Mac地址.</li><li>802标准所说的地址严格的讲应当是每一个站的名字或标识符.<br>但鉴于大家都已经习惯了将这种48位的名字称为地址，所以就采用了这种习惯用法。</li><li>IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节(即高位24位),地址字段中的后三个字节(即低位24位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址.</li><li>一个地址块可以生成2的24次方个不同的地址，这种48位地址称为Mac-48，它的通用名称是EUI-48.</li><li>Mac地址实际上就是适配器地址或适配器标识符EUI-48.</li></ul><h2 id="适配器检查Mac地址"><a href="#适配器检查Mac地址" class="headerlink" title="适配器检查Mac地址"></a>适配器检查Mac地址</h2><ol><li>适配器从网络上每收到一个Mac帧就首先用硬件检查Mac帧中的Mac地址</li><li>如果是发送本站的帧则收下，然后在进行其他的处理</li><li>否则就将此帧丢弃，不再进行其他的处理</li></ol><p>发送本站的帧，包括以下三种:</p><ul><li>单播帧 （一对一）</li><li>广播帧 （一对全体）</li><li>多播帧 （一对多）</li></ul><h2 id="Mac帧格式"><a href="#Mac帧格式" class="headerlink" title="Mac帧格式"></a>Mac帧格式</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="380px" height="220px"><br>前8个字节作用是实现比特同步，第一个字段共七个字节，称为前同步码，作用是实现快速Mac帧的比特同步。</p><h3 id="以太网V2的Mac帧格式"><a href="#以太网V2的Mac帧格式" class="headerlink" title="以太网V2的Mac帧格式"></a>以太网V2的Mac帧格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="无效的Mac帧"><a href="#无效的Mac帧" class="headerlink" title="无效的Mac帧"></a>无效的Mac帧</h3><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>数据字段的长度不在46-1500字节之间</li><li>有效的Mac帧长度为64-1518字节之间</li><li>对于检查出的无效Mac帧就简单地丢弃。以太网不负责重传丢弃地帧。</li></ul><h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为9.6us，相当于96bit地的发送时间,一个站在检测到总线开始空闲后，还要等待9.6us才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层考虑扩展"><a href="#在物理层考虑扩展" class="headerlink" title="在物理层考虑扩展"></a>在物理层考虑扩展</h3><p><strong>距离扩展</strong>：<br>主机使用光纤和一对光纤调制解调器连接到集线器<br><strong>数量扩展</strong>：<br>集线器级联：使网络中计算机增加，变成一个大的冲突域，会造成效率降低</p><h4 id="用集线器扩展局域网优点"><a href="#用集线器扩展局域网优点" class="headerlink" title="用集线器扩展局域网优点"></a>用集线器扩展局域网优点</h4><ul><li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信</li><li>扩大了局域网覆盖的地理范围</li><li>用集线器扩展局域网缺点</li><li>碰撞域增大了，但总的吞吐量并未提高</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将他们互连起来</li></ul><h3 id="在数据链路层考虑扩展"><a href="#在数据链路层考虑扩展" class="headerlink" title="在数据链路层考虑扩展"></a>在数据链路层考虑扩展</h3><p>在数据链路层扩展局域网使用网桥</p><ul><li>网桥工作在数据链路层，它根据Mac帧的目的地址对收到的帧进行转发。</li><li>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的Mac地址，然后再确定将该帧转发到哪一个接口</li></ul><blockquote><p>ps：网桥是交换机的前身，透明网桥：指局域网上的站点不知道所发送的帧将经过几个网桥，因为网桥对于各站点是看不见的</p></blockquote><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>随着网桥接口的增加，后来网桥和集线器合并了，计算机可以直接和交换机连接，这就是交换机。交换机就是网桥和集线器的合并版，能全双工，安全通信。</p><ul><li>端口带宽独享</li><li>安全</li><li>基于Mac地址转发</li><li>通过学习构建Mac地址表</li></ul><h2 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h2><h3 id="100BASE-T以太网"><a href="#100BASE-T以太网" class="headerlink" title="100BASE-T以太网"></a>100BASE-T以太网</h3><p>速率达到或超过100Mb/s的以太网称为高速以太网。<br>在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议。<br>100BASE-T以太网又称为快速以太网(Fast Ethernet)。</p><h4 id="100Base-T以太网的物理层："><a href="#100Base-T以太网的物理层：" class="headerlink" title="100Base-T以太网的物理层："></a>100Base-T以太网的物理层：</h4><ul><li>100BASE-TX ： 使用2对UTP5类线或屏蔽双绞线STP</li><li>100BASE-FX : 使用2对光纤</li><li>100BASE-T4 : 使用4对UTP3类线或5类线</li></ul><h4 id="100Base-T特点"><a href="#100Base-T特点" class="headerlink" title="100Base-T特点"></a>100Base-T特点</h4><ul><li>可在全双工方式下工作而无冲突发生，因此，不使用CSMA/CD协议。Mac帧格式仍然是802.3标准规定的。</li><li>保持最短帧长不变，但将一个网段的最大电缆长度减小到100m，帧间时间间隔从原来的9.6us改为现在的0.96us。</li></ul><h3 id="G比特以太网"><a href="#G比特以太网" class="headerlink" title="G比特以太网"></a>G比特以太网</h3><ul><li>允许在1GB/s下全双工和半双工两种方式工作</li><li>使用802.3协议规定的帧格式</li><li>在半双工方式下使用CSMA/CD协议(全双工方式不需要使用CSMA/CD协议)</li><li>与10BASE-T和100BASE-T技术 向后兼容</li><li>当G比特以太网工作 在全双工方式时,不使用载波延伸和分组突发</li></ul><h3 id="G比特以太网的物理层"><a href="#G比特以太网的物理层" class="headerlink" title="G比特以太网的物理层"></a>G比特以太网的物理层</h3><h4 id="1000BASE-x-基于光纤通道的物理层："><a href="#1000BASE-x-基于光纤通道的物理层：" class="headerlink" title="1000BASE-x 基于光纤通道的物理层："></a>1000BASE-x 基于光纤通道的物理层：</h4><ul><li>1000BASE-SX SX表示短波长 传输距离275或550米</li><li>1000BASE-LX LX表示长波长 550米或5000米</li><li>1000BASE-CX CX表示铜线 传输距离25米</li></ul><h4 id="1000BASE-T："><a href="#1000BASE-T：" class="headerlink" title="1000BASE-T："></a>1000BASE-T：</h4><ul><li>使用四对5类线UTP</li></ul><h4 id="G比特以太网配置举例"><a href="#G比特以太网配置举例" class="headerlink" title="G比特以太网配置举例"></a>G比特以太网配置举例</h4><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/4.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="10G比特以太网"><a href="#10G比特以太网" class="headerlink" title="10G比特以太网"></a>10G比特以太网</h3><ul><li>同10Mb/s，100Mb/s，1Gb/s以太网的帧格式完全相同</li><li>保留了802.3标准规定的以太网最小和最大帧长，便于升级</li><li>不再使用铜线而只使用光纤作为传输媒体</li><li>只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议。</li></ul><h2 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h2><p>10G比特以太网的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输 。<br>这种工作方式的好处是：</p><ul><li>成熟的技术</li><li>互操作性很好</li><li>在广域网中使用以太网时价格便宜</li><li>统一的帧格式简化了操作和管理</li></ul><h2 id="Cisco建网3层模型"><a href="#Cisco建网3层模型" class="headerlink" title="Cisco建网3层模型"></a>Cisco建网3层模型</h2><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/5.png" srcset="/img/loading.gif" width="380px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以太网</title>
    <link href="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h2><ul><li>DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约。</li><li>IEEE 的802.3标准。</li></ul><blockquote><p>DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为以太网。<br>严格说来，以太网应当是指符合DIX Ethernet V2 标准的局域网</p></blockquote><h2 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h2><p>为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层.</p><ul><li>逻辑链路控制LLC(Logical Link Control)子层</li><li>媒体接入控制MAC(Medium Access Control)子层</li></ul><blockquote><p>与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。<br>由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路控制子层LLC(即802.2标准)的作用已经不大了.<br>很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。</p></blockquote><h2 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h2><ul><li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li><li>当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</li><li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li></ul><h2 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h2><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="375px" height="220px"><br>传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不同电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。<br>这种以太网采用星型拓扑，在星型的中心则增加了一种可靠性非常高的设备，叫集线器。</p><h2 id="集线器的一些特点"><a href="#集线器的一些特点" class="headerlink" title="集线器的一些特点"></a>集线器的一些特点</h2><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线。</p><blockquote><p>集线器很像一个多接口的转发器，工作在物理层。</p></blockquote><h2 id="集线器连以太网定义的标准"><a href="#集线器连以太网定义的标准" class="headerlink" title="集线器连以太网定义的标准"></a>集线器连以太网定义的标准</h2><p>10BASE-T的通信距离稍短，每个站到集线器的距离不超过100m。<br>这种10Mb/s速率的无屏蔽双绞线星型网的出现，既降低了成本，又提高了可靠性。<br>10BASE-T双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p><blockquote><p>其他： 100Base-FX 100Base-T 100Base-T4</p></blockquote><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><h3 id="以太网的信道被占用的情况"><a href="#以太网的信道被占用的情况" class="headerlink" title="以太网的信道被占用的情况"></a>以太网的信道被占用的情况</h3><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>争用期长度为2γ，即端到端传播时延的两倍。碰撞到碰撞后不发送干扰信号。<br>帧长为L(bit)，数据发送速率为C(b/s)，因而帧的发送时间为L/C=T0(s).<br>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间γ使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p><h3 id="提高信道利用率"><a href="#提高信道利用率" class="headerlink" title="提高信道利用率"></a>提高信道利用率</h3><p>要提高以太网信道利用率，就必须减小γ与t0之比，以太网中定义了参数a，是以太网单程端到端时延γ与帧的发送时间t0之比:<br>a = γ/t0<br>a -&gt; 0表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a越大，表明争用期所占比例增大，每发生一次碰撞就浪费许多信道资源，使信道利用率明显降低。</p><h2 id="信道利用率最大值"><a href="#信道利用率最大值" class="headerlink" title="信道利用率最大值"></a>信道利用率最大值</h2><h3 id="对以太网参数的要求"><a href="#对以太网参数的要求" class="headerlink" title="对以太网参数的要求"></a>对以太网参数的要求</h3><ul><li>当数据率一定时，以太网的连线的长度受到限制否则γ的数值会太大</li><li>以太网的帧长不能太短，否则t0的值会太小，使a值太大。</li></ul><h3 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h3><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞(这显然已经不是CSMA/CD，而是需要使用一种特殊的调度算法)，即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是t0 + γ，而帧的本身的发送时间是t0，于是我们可计算理想情况下的极限信道利用率Smax为：<br>Smax = t0/t0 + γ = 1/1+a</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用广播信道的数据链路层</title>
    <link href="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="使用广播信道的数据链路层-局域网"><a href="#使用广播信道的数据链路层-局域网" class="headerlink" title="使用广播信道的数据链路层(局域网)"></a>使用广播信道的数据链路层(局域网)</h1><h2 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点:"></a>局域网最主要的特点:</h2><p>网络为一个单位所拥有，且地理范围和站点数目均有限。<br>局域网具有如下的一些主要优点：</p><ul><li>具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性，可用性和生存性。</li></ul><h2 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h2><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul><h3 id="动态媒体接入控制-多点接入"><a href="#动态媒体接入控制-多点接入" class="headerlink" title="动态媒体接入控制(多点接入)"></a>动态媒体接入控制(多点接入)</h3><ul><li>随机接入(主要被以太网采用)</li><li>受控接入 ,如多点线路探询，或轮询。(目前已不被采用)</li></ul><h2 id="认识以太网"><a href="#认识以太网" class="headerlink" title="认识以太网"></a>认识以太网</h2><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。<br>总线上的每一个工作的计算机都能检测到b发送的数据信号.<br>由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。<br>其他计算机都检测到不是发送给他们的数据帧，因此就丢弃这个数据帧而不能接收下来。<br>具有广播特性的总线上实现了一对一的通信。</p><h3 id="带冲突检测的载波监听-碰撞检测"><a href="#带冲突检测的载波监听-碰撞检测" class="headerlink" title="带冲突检测的载波监听/碰撞检测"></a>带冲突检测的载波监听/碰撞检测</h3><p><strong>CSMA/CD</strong>: Carrier Sense Multiple Access with Collision Detection<br><strong>多点接入</strong>: 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong>: 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><blockquote><p>载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号</p></blockquote><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>碰撞检测就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)<br>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</p><blockquote><p>所谓碰撞就是发生了冲突，因此碰撞检测也被称为冲突检测</p></blockquote><p><strong>检测到碰撞后</strong>:<br>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。<br>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送.</p><h3 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h3><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信)。</li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>最先发送数据帧的站，在发送数据帧后至多经过时间2γ(2倍的端到端往返时延)就知道发送的数据帧是否遭受了碰撞。<br>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p><strong>以太网的争用期</strong>：</p><ul><li>以太网的端到端往返时延2γ称为争用期，或碰撞窗口。通常，取51.2us为争用期的长度。</li><li>对于10mb/s以太网，在争用期内可发送512bit，即64字节。</li><li>以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突。</li></ul><p><strong>最短有效帧长</strong>：</p><ul><li>如果发生冲突，就一定是在发送的前64字节之内。</li><li>由于一检测到冲突就立即终止发送，这时已经发送出去的数据一定小于64字节。</li><li>以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。</li></ul><h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟一个随机时间才能在发送数据。<br>确定基本退避时间，一般为争用期γ。<br>定义参数k<br>k = min[重传次数，10]<br>从整数集合[0,1…(2的k次方-1)]中随机地抽取一个数，记为r。重传所需的时延就是r倍的基本退避时间。<br>当重传达16次仍不能成功时即丢弃该帧，并向高层报告。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层基本概念及简单模型</title>
    <link href="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据链路层基本概念及简单模型"><a href="#数据链路层基本概念及简单模型" class="headerlink" title="数据链路层基本概念及简单模型"></a>数据链路层基本概念及简单模型</h1><p>数据链路层的简单模型:</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>数据链路层使用的信道主要有两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂，广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3 id="链路-link"><a href="#链路-link" class="headerlink" title="链路(link)"></a>链路(link)</h3><ul><li>一条点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分</li></ul><h3 id="数据链路-data-link"><a href="#数据链路-data-link" class="headerlink" title="数据链路(data link)"></a>数据链路(data link)</h3><p>除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路，现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层这两层的功能</p><blockquote><p>帧：数据，帧头，帧尾，物理层地址 校验值<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/3.png" srcset="/img/loading.gif" width="350px" height="200px"></p></blockquote><h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限，首部和尾部的一个重要作用就是进行帧定界。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/4.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输，如果传输的数据是ascii码中95个字符集时，一切正常，若传输的数据出现了EOT，被接收端误认为EOT前是一个帧，后面的当作无效帧丢弃。</p><h4 id="字节填充发解决透明传输的问题"><a href="#字节填充发解决透明传输的问题" class="headerlink" title="字节填充发解决透明传输的问题"></a>字节填充发解决透明传输的问题</h4><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转移字符“ESC”(16进制编码是1b).<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/5.png" srcset="/img/loading.gif" width="350px" height="200px"><br>字节填充或字符填充：接收端的数据链路层在将数据送往网络层之前删除插入的转义字符,如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。<br>当接受端收到连续的两个转义字符时，就删除其中前面的一个。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>传输过程中可能会产生比特差错，在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER，误码率与信噪比 有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测错数。常用循环冗余检验，在数据后面添加冗余码称为帧检验序列FCS(Frame Check Sequence).<br>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码.<br>FCS可以用CRC方法得出，但CRC并非用来获得FCS的唯一方法.</p><h2 id="使用点对点信道的数据链路层-广域网"><a href="#使用点对点信道的数据链路层-广域网" class="headerlink" title="使用点对点信道的数据链路层(广域网)"></a>使用点对点信道的数据链路层(广域网)</h2><p>1992年制定了ppp(Point-to-Point Protocol)协议，经过1993年和1994年的修订，现在的ppp协议已经成为因特网的正是标准,ppp协议有三个组成部分:</p><ul><li>数据链路层协议可以用于异步串行或同步串行介质</li><li>它使用LCP(链路控制协议)建立并维护数据链路连接</li><li>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/6.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>现在全世界使用最多的数据链路层协议是点对点协议ppp,用户使用拨号电话线接入因特网时，一般都是使用ppp协议.如图所示</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/7.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>ppp协议应该满足的要求:</p><ul><li>简单–首要要求</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul><p>ppp协议不需要满足的要求:</p><ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul><p>ppp协议帧格式</p><ul><li>标志字段F = 0x7E</li><li>地址字段A只置为0xFF 地址字段实际并不起作用</li><li>控制字段C通常置为0x03</li><li>ppp是面向字节的，所有的ppp帧长度都是整数字节</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/8.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><ul><li>将信息字段中出现的每个0x7E字节转变称为2字节序列0x7D 0x5E</li><li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列0x7D 0x5D</li><li>若信息字段出现ascii码的控制字符，则在该字符前面加入一个0x7D，同时将该字符的编码加以改变</li></ul><h3 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h3><p>ppp协议用在SONET/SDH链路时，是使用同步传输(一连串比特连续发送)。这时ppp协议采用零比特填充方法来实现透明传输。<br>在发送端，只要发现有5个连续1，则立即填入一个0(零比特填充法).接收端对帧中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后的一个0删除。</p><h3 id="ppp协议不使用序号和确认机制的原因"><a href="#ppp协议不使用序号和确认机制的原因" class="headerlink" title="ppp协议不使用序号和确认机制的原因"></a>ppp协议不使用序号和确认机制的原因</h3><ul><li>在数据链路层出现差错的概率不大时，使用比较简单的ppp协议较为合理。</li><li>在因特网环境下，ppp的信息字段放入的数据是ip数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列FCS字段可保证无差错接受。</li></ul><h3 id="ppp协议工作状态"><a href="#ppp协议工作状态" class="headerlink" title="ppp协议工作状态"></a>ppp协议工作状态</h3><ol><li>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接</li><li>PC机向路由器发送一系列的LCP分组(封装成多个ppp帧)。<br>这些分组及其响应选择一些ppp参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。</li><li>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址，接着，LCP释放数据链路层连接，最后释放的时物理层的连接。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字传输系统与宽带接入技术</title>
    <link href="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h1><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路的电话。由于历史原因，PCM有两个互不兼容的国际标准，即<strong>北美的24路PCM(简称为T1)</strong>和<strong>欧洲的30路PCM(简称为E1)</strong>，我国采用的是欧洲的E1标准。<br>E1的速率是2.048mb/s，而T1的速率是1.544Mb/s。<br>当需要有更高的数据率时，可采用复用的方法。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="400px" height="200px"><br>将用户的声波进行8000次采样，然后统计规整每个码元得到二进制代码。<br>E1电路(时分复用)<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="400px" height="200px"><br>T1电路<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)<br>例如</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="400px" height="200px"><br>标准模拟电话信号的频带被限制在300-3400hz范围内，但用户线本身实际可通过的信号频率仍然超过1Mhz。<br>xDSL技术就是把0-4Khz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h2><p>DMT调制技术采用频分复用的方法，将40kHZ以上一直到1.1MHz的高端频谱划分成许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道。<br>每个子信道占据4Khz带宽，并使用不同的载波(即不同的音调)进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p><p>频谱分布<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="光纤同轴混合网HFC-Hybrid-Fiber-Coax"><a href="#光纤同轴混合网HFC-Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网HFC(Hybrid Fiber Coax)"></a>光纤同轴混合网HFC(Hybrid Fiber Coax)</h2><p>HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除了可传送CATV外还提供电话，数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输，而HFC网则需要对CATV网进行改造。每个用户要安装一个用户接口盒。<br>优点 ： 具有很宽的频带，能够利用已有相当大的覆盖面的有线电视网</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h2><p>FTTx(光纤到…)也是一种实现宽带居民接入网的方案。<br>光纤到家FTTH(Fiber To The Home):光纤一直铺设到用户家庭可能是居民接入网最后的解决办法(155Mb/s).<br>光纤到大楼FTTB(Fiber To The Building): 光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br>光纤到路边FTTC(Fiber To The Curb): 从路边到各用户可使用星型结构双绞线作为传输媒体(155mb/s)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输媒体与信道复用技术</title>
    <link href="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><h2 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h2><ul><li>双绞线<ul><li>屏蔽双绞线STP</li><li>无屏蔽双绞线UTP</li></ul></li><li>同轴电缆<ul><li><strong>50Ω同轴电缆</strong>用于数字传输，由于多用于基带传输，也叫基带同轴电缆。</li><li><strong>75Ω同轴电缆</strong>用于模拟传输，即宽带同轴电缆。</li></ul></li><li>光缆<ul><li>光缆是一定数量的光纤按照一定方式组成缆心，外包有护套，有的还包覆外护层，用以实现光信号传输的一种通信线路。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><blockquote><p>导向传输媒体中，电磁波沿着固体媒体传播。</p></blockquote><h2 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h2><p>非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。<br>无线传输使用的频段很广，例如以下两种：</p><ul><li>短波通信主要靠电离层的反射，但短波通信的通信质量较差。</li><li>微波在空间主要是直线传播，例如地面微波接力通信，卫星通信。</li></ul><h3 id="电信领域使用的电磁波的频谱"><a href="#电信领域使用的电磁波的频谱" class="headerlink" title="电信领域使用的电磁波的频谱"></a>电信领域使用的电磁波的频谱</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><h3 id="网线"><a href="#网线" class="headerlink" title="网线"></a>网线</h3><ul><li>直通线<ul><li>主机到交换机或集线器<ul><li>路由器到交换机或集线器</li></ul></li></ul></li><li>交叉电缆<ul><li>交换机到交换机</li><li>集线器到集线器</li><li>主机到主机</li><li>集线器到交换机</li><li>路由器直连到主机</li></ul></li></ul><h4 id="线序制作方法"><a href="#线序制作方法" class="headerlink" title="线序制作方法"></a>线序制作方法</h4><ul><li>直通线：双绞线夹线顺序两边一致，1.橙白、2.橙、3.绿白、4.蓝、5.蓝白、6.绿、7.棕白、8.棕，两端都是同样的线序且一一对应，即568B标准，也就是正线或标准线、直通线。</li><li>交叉电缆: 1、2号线与3、6号线交叉传送，也就是568A标准。<blockquote><p>568A: 绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</p></blockquote></li></ul><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>单模光纤，只能传输一种电磁波模式，光纤细，传播特性好，有线电视网络中使用的都是单模光纤，带宽可达10GHZ，可以在一根光纤中传输60套PAL—D电视节目。</li><li>多模光纤，只可以传输多个电磁波模式，光纤粗。</li></ul><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>工作特点：它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。<br>最大传输距离： 100m</p><blockquote><p>集线器是一个大的冲突域。</p></blockquote><hr><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h3 id="基础模型图"><a href="#基础模型图" class="headerlink" title="基础模型图"></a>基础模型图</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>频分复用FDM(Frequency Division Multiplexing),用户分配到一定的频带后，在通信过程中始终占用这个频带。频带复用的所有用户在同样的时间占用不同的带宽资源(这里带宽指频率带宽不是数据发送速率)。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="300px" height="150px"><br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>时分复用TDM(Time Division Multiplexing),将时间划分为一段段等长的时分复用帧(TDM)帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性出现的(周期就是TDM帧的长度对应的时间)。<br>TDM信号也称为等时信号，时分复用的所有用户是在不同的时间占用相同的频带宽度。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>统计时分复用STDM(Statistic TDM)，由于时分复用可能造成线路资源浪费，使用时分复用系统传输计算机数据时，由于计算机数据突发性，用户对分配的子信道利用率一般不高，所以用统计时分复用去解决，也就是给每一个用户的信息加标记去区分用户的信息。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用WDM(Wavalength Division Multiplexing)，波分复用也就是光的频分复用。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/10.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信道的基本概念</title>
    <link href="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="信道简介"><a href="#信道简介" class="headerlink" title="信道简介"></a>信道简介</h2><p>信道一般表示向一个方向传送信息的媒体。所以通信线路往往包含一条发送信息的信号和一条接收信息的信道</p><ul><li>单向通信(单工通信)，只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信，通信的双方都可以发送信息，但不能同时发送和接受信息</li><li>双向同时通信，通信的双方可以同时发送和接受信息</li></ul><h2 id="基带信号和带通信号"><a href="#基带信号和带通信号" class="headerlink" title="基带信号和带通信号"></a>基带信号和带通信号</h2><ul><li>基带信号(baseband，即基本频带信号)，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如说话的声波就是基带信号。</li><li>带通信号(bandpass)，把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段，以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li></ul><p>因此在传输距离较近时，计算机网络采用基带传输方式，因为近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p><h3 id="几种最基本的调制方法"><a href="#几种最基本的调制方法" class="headerlink" title="几种最基本的调制方法"></a>几种最基本的调制方法</h3><ul><li>调幅(AM): 载波的振幅随基带数字信号而变化。</li><li>调频(FM): 载波的频率随基带数字信号而变化。</li><li>调相(PM): 载波的初始相位随基带数字信号而变化。</li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>单极性不归零码<ul><li>只使用一个电压值，用高电平表示1，没电压表示0.</li></ul></li><li>双极性不归零码<ul><li>用正电平和负电平分别表示二进制数据的1和0，正负幅值相等。</li></ul></li><li>单极性归零码<ul><li>以高电平和零电平分别表示二进制码1和0，而且在发送吗1时高电平在整个码元期间T只持续一段时间γ，其余时间返回零电平</li></ul></li><li>双极性归零码<ul><li>正负零三个电平，信号本身携带同步信息。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>曼彻斯特编码<ul><li>位中间有信号时，低电位变高电位为0，高电位变低电位为1。</li><li>采用这种编码，一个时钟周期只可表示一个位，并且必须通过两次采样才能得到一个位的值，但它能携带时钟信号，且可表示没有数据传输。</li></ul></li><li>差分曼彻斯特编码<ul><li>bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0.bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1.</li><li>差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性强于曼彻斯特编码。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>发送的信号波形通过实际的信道时会受到带宽、噪音、干扰等影响而失真，如果失真较小依旧可以识别并且纠正，如果失真较大则无法识别。</p><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>1924年，Nyquist推导出著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的识别成为不可能。<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>Shannon用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。<br>信道的极限信息传输速率C可以表示为<br>C = W log2(1+S/N) b/s log以2为底</p><ul><li>W为信道的带宽(单位hz)</li><li>S为信道内所传信号的平均功率</li><li>N为信道内部的高斯噪声功率</li></ul><blockquote><ul><li>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li><li>若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率C也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香浓的极限传输速率低不少。</li></ul></blockquote><h3 id="奈氏准则和香农公式的应用范围"><a href="#奈氏准则和香农公式的应用范围" class="headerlink" title="奈氏准则和香农公式的应用范围"></a>奈氏准则和香农公式的应用范围</h3><p>奈氏准则表示没有信号干扰，码元的传输速率有上限。<br>香浓公式表示有信号干扰，无差错传输速率的理论极限。<br><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层概念与数据通信基础</title>
    <link href="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。<br>物理层的主要任务描述为： 确定传输媒体的接口的一些特性即：</p><ul><li>机械特性：例接口形状，大小，引线数目</li><li>电气特性：例规定电压范围（-5v，+5v）</li><li>功能特性：例规定-5v表示0，+5v表示1</li><li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>链接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>数据通信领域中，数字信道所能传送的最高数据率，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>即在单位时间内通过某个网络的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li>发送时延 = 数据块长度(bit)/信道带宽(bit/s) 信号波完全传播完</li><li>传播时延 传播的过程所用时间</li><li>处理时延 收到信号波后处理时间</li><li>排队时延 多个信号排队等待时间</li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 = 传播时延 * 带宽 （传播时线路上有多少bit）</p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>从发送方发送数据开始，到发送方收到接收方确认</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul><li>信道利用率 = 有数据通过时间/有无数据通过时间</li><li>网络利用率 = 信道利用率加权平均值<br>D = D0 / （1-U） D0:网络空闲时的时延，D:网络当前时延，U: 信道利用率</li></ul><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基本模型"><a href="#数据通信基本模型" class="headerlink" title="数据通信基本模型"></a>数据通信基本模型</h3><p><img src="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/1.png" srcset="/img/loading.gif" width="350px" height="150px"></p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>数据(data)– 运送消息的实体</li><li>信号(signal)–数据的电气或电磁的表现</li><li>“模拟信号”–代表消息的参数的取值是连续的。</li><li>“数字信号”–代表消息的参数的取值是离散的。</li><li>码元(code)–在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度，1码元可以携带nbit的信息量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高斯约旦消元法</title>
    <link href="/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/"/>
    <url>/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h1><p>矩阵更准确的说是对线性系统的描述，所谓的线性系统指的是例如3x + 4y + z = 8之类的线性方程组，未知数只能是一次方项。而非线性方程则例如sin(x) = Π等坐标图上呈曲线的方程组。</p><h2 id="消元法解线性方程"><a href="#消元法解线性方程" class="headerlink" title="消元法解线性方程"></a>消元法解线性方程</h2><p>在小学初中我们学过如何用消元法解线性方程组，例如x + y = 2；2x + 3y = 12；的线性方程组，我们可以用第二个方程减去二倍的第一个方程，然后便可以消去x，得到y的值，然后将y带入第一个方程，我们便可以得到x与y的值，即线性方程组的解。</p><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>学习矩阵的概念之后，我们可以将方程组的系数拿下来组成系数矩阵，然后基于矩阵的操作去得到线性方程组的解，例如x + y + z = 6；2x + y + z = 7；x + y + 2z = 9;将其系数拿下来之后，我们可以得到矩阵<br>1 1 1<br>2 1 1<br>1 1 2<br>将方程组的结果也拿下来可以得到该矩阵的增广矩阵<br>1 1 1 | 6<br>2 1 1 | 7<br>1 1 2 | 9<br>经过第二行减二倍的第一行后，我们可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>1 1 2 | 9<br>然后用第三行减去第一行，可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>0 0 1 | 3<br>将第二行乘以-1，可以得到最终的矩阵<br>1 1 1 | 6<br>0 1 1 | 5<br>0 0 1 | 3<br>此矩阵最后一行的1则代表z的值，通过回代，便可得到x与y的值。通过观察，我们可以发现结果矩阵的对角线元素都为1，而矩阵的下一行总比上一行多一个0，我们将每一行的第一个1称为此行的主元，我们把第i-1行根据第i行的主元进而不断消去一个未知数的方法称为高斯消元法。</p><h2 id="高斯约旦消元法"><a href="#高斯约旦消元法" class="headerlink" title="高斯约旦消元法"></a>高斯约旦消元法</h2><p>通过以上的消元,最终我们只能得到最后一个未知数的值，上述矩阵，可以写成以下方程组<br>x + y + z =6;<br>y + z = 5;<br>z = 3;<br>通过回代的方式，可以得到x，y，z的值，但还是有一些麻烦。针对此矩阵，我们还可以在进行变换，将第二行减去第三行可得<br>1 1 1 | 6<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第三行可得<br>1 1 0 | 3<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第二行可得<br>1 0 0 | 1<br>0 1 0 | 2<br>0 0 1 | 3<br>进行这样的变换后，便可以直观的看出x，y，z的值，而坐标的系数矩阵则化成了单位矩阵，这种向下消元然后向上消元的方法被称为高斯约旦法。主要分为两个过程：</p><h3 id="前向过程-从上到下"><a href="#前向过程-从上到下" class="headerlink" title="前向过程(从上到下)"></a>前向过程(从上到下)</h3><ol><li>选择最上的主元，化为1</li><li>主元下面的所有行减去主元所在行的某个倍数，使得主元下面所有元素都为0</li></ol><h3 id="后向过程-从下到上"><a href="#后向过程-从下到上" class="headerlink" title="后向过程(从下到上)"></a>后向过程(从下到上)</h3><ol><li>选择最下的主元</li><li>主元上面的所有行减去主元所在行的某个倍数，使得主元上面所有元素都为0</li></ol><h3 id="python代码演示"><a href="#python代码演示" class="headerlink" title="python代码演示"></a>python代码演示</h3><pre><code>from .Matrix import Matrixfrom .Vector import Vectorclass LinearSystem:    def __init__(self,A,b):        assert A.row_num() == len(b),&quot;row number of A must be equal to the length&quot;        self._m = A.row_num()        self._n = A.col_num()        assert self._m == self._n # TODO: no this restriction        self.Ab = [Vector(A.row_vector(i).underlying_list()+[b[i]])                   for i in range(self._m)]    def _max_row(self,index,n):        best,ret = self.Ab[index][index],index        for i in range(index + 1,n):            if self.Ab[i][index] &lt; best:                best,ret = self.Ab[i][index],i        return ret    def _forward(self):        n = self._m        for i in range(n):            # Ab[i][i]为主元            max_row = self._max_row(i,n)            self.Ab[i],self.Ab[max_row] = self.Ab[max_row],self.Ab[i]            # 将主元归一            self.Ab[i] = self.Ab[i] / self.Ab[i][i] #TODO: self.Ab[i][i] == 0            for j in range(i+1,n):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def _backward(self):        n = self._m        for i in range(n-1,-1,-1):            for j in range(i-1,-1,-1):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def gauss_jordan_elimination(self):        self._forward()        self._backward()    def fancy_print(self):        for i in range(self._m):            print(&quot; &quot;.join(str(self.Ab[i][j]) for j in range(self._n)),end=&quot; &quot;)            print(&quot;|&quot;,self.Ab[i][-1])</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code>from playLA.Matrix import Matrixfrom playLA.Vector import Vectorfrom playLA.LinearSystem import LinearSystemif __name__ == &quot;__main__&quot;:    A = Matrix([[1,1,1],[2,1,1],[1,1,2]])    b = Vector([6,7,9])    Ab = LinearSystem(A,b)    Ab.gauss_jordan_elimination()    Ab.fancy_print()</code></pre><h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h3><p>课程名称: 专给程序员设计的线性代数<br>作者: bobo老师 –ACM亚洲区奖牌获得者</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础与OSI参考模型</title>
    <link href="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="局域网与广域网"><a href="#局域网与广域网" class="headerlink" title="局域网与广域网"></a>局域网与广域网</h2><h3 id="局域网："><a href="#局域网：" class="headerlink" title="局域网："></a><strong>局域网</strong>：</h3><p>局域网是一种私有网络，一般在一座建筑物内或建筑物附近，比如家庭、办公室或工厂。局域网络被广泛用来连接个人计算机和消费类电子设备，使它们能够共享资源和交换信息。当局域网被用于公司时，它们就称为企业网络。</p><blockquote><p>特点：覆盖范围小，设备自己购买，带宽固定，自己维护。</p></blockquote><h3 id="广域网："><a href="#广域网：" class="headerlink" title="广域网："></a><strong>广域网</strong>：</h3><p>在一个区域范围里超过集线器所连接的距离时，必须要通过路由器来连接，这种网上类型称为广域网。如果有北、中、南等分公司，甚至海外分公司，把这些分公司以专线方式连接起来，即称为“广域网”，广域网由各大运行商进行维护和建设，覆盖范围广，给用户提供服务。</p><blockquote><p>解释：ISP(Internet Service Provider)：互联网服务提供商。每个运行商都有自家的机房，各互联网公司通过租用运行商机房里的服务器，搭建自己的公司网站，所以电信网络访问在电信机房的网站就会快很多。为了避免因服务器所属不同产生的网络访问慢的问题，也有了双线机房的诞生，即多个运行商共有一个机房。</p></blockquote><h3 id="Internet："><a href="#Internet：" class="headerlink" title="Internet："></a><strong>Internet</strong>：</h3><p>internet表示的意思是互联网，又称网际网路，根据音译也被叫做因特网(Internet)、英特网，是网络与网络之间所串连成的庞大网络。这些网络以一组通用的协议相连，形成逻辑上的单一且巨大的全球化网络，在这个网络中有交换机、路由器等网络设备、各种不同的连接链路、种类繁多的服务器和数不尽的计算机、终端。</p><blockquote><p>中国互联网由电信，移动，联通，网通等等运行商组成，用户可以通过各地运行商提供的接口进而访问到全国互联网，并且各运行商提供与国外互联网的接口，进而访问全球互联网.</p></blockquote><h2 id="互联网如何进行数据的传输？"><a href="#互联网如何进行数据的传输？" class="headerlink" title="互联网如何进行数据的传输？"></a>互联网如何进行数据的传输？</h2><h3 id="数据帧与数据包"><a href="#数据帧与数据包" class="headerlink" title="数据帧与数据包"></a>数据帧与数据包</h3><p>每个网络都有属于自己的ip地址，每台设备也有唯一的Mac地址。当用户访问网站时，需要将域名传输给DNS，然后DNS返回相应的IP地址，然后将数据和本机IP地址以及目标IP地址进行打包(数据包)，为了将数据包通过路由器进行传输，还需要将当前mac地址以及下一个路由器的mac地址同样打包进去(数据帧),通过不断改变mac地址，进而将数据传输给服务器。</p><blockquote><p>DNS:域名解析服务器</p></blockquote><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><ul><li>应用层 所有能产生网络流量的程序</li><li>表示层 在传输之前是否进行加密或压缩处理，二进制或ASCII表示</li><li>会话层 浏览器与网站服务器建立会话，确保服务器传输来的信息渲染相对的页面 可以通过对话查木马 netstat -n</li><li>传输层 可靠传输 流量控制 不可靠传输(不需要建立会话，一个数据包便可完成交流)</li><li>网络层 负责选择最佳路径，规划IP地址</li><li>数据链路层 帧的开始和结束如何定义 透明传输 差错校验</li><li>物理层 接口标准(网线) 电器标准 如何在物理链路上传输更快的速度</li></ul><h3 id="OSI参考模型对网络排错指导"><a href="#OSI参考模型对网络排错指导" class="headerlink" title="OSI参考模型对网络排错指导"></a>OSI参考模型对网络排错指导</h3><ol><li>物理层故障 查看连接状态 发送和接受数据包</li><li>数据链路层故障 MAC冲突 ADSL欠费 网速没办法协商一致 计算机连接到错误的VLAN</li><li>网络层故障 配置错误的IP地址 子网掩码 配置错误的网关 路由器没有配置到达目标网络的路由</li><li>应用层故障 应用程序配置错误</li></ol><h3 id="OSI参考模型和网络安全"><a href="#OSI参考模型和网络安全" class="headerlink" title="OSI参考模型和网络安全"></a>OSI参考模型和网络安全</h3><ol><li>物理层安全</li><li>数据链路层安全 ADSL账号密码 VLAN交换机端口绑定MAC地址</li><li>网络层安全 在路由器上使用ACL控制数据包流量</li><li>应用层安全 开发的应用程序没有漏洞</li></ol><h3 id="OSI参考模型与TCP-IP"><a href="#OSI参考模型与TCP-IP" class="headerlink" title="OSI参考模型与TCP_IP"></a>OSI参考模型与TCP_IP</h3><p><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/1.png" srcset="/img/loading.gif" width="300px" height="150px"><br><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubantu配置django开发环境</title>
    <link href="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><ol><li>Ubantu镜像</li><li>Python3</li><li>pip3</li><li>pymysql</li><li>Django2.2</li><li>Mysql数据库</li><li>virtualenv虚拟环境</li></ol><h3 id="在VirtualBox上安装Ubantu操作系统"><a href="#在VirtualBox上安装Ubantu操作系统" class="headerlink" title="在VirtualBox上安装Ubantu操作系统"></a>在VirtualBox上安装Ubantu操作系统</h3><p>新建虚拟机，选择类型linux,选择版本ubantu64-bit，分配内存4gb，选择创建虚拟硬盘，配置好之后，在设置里，设置显存大小128m，启动3d加速.<br><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2.png" srcset="/img/loading.gif" width="400px" height="250px"><br>应用设置，并启动系统，再开始界面选择需要导入的ios镜像，进入ubantu安装界面，并完成安装指导，建议自己分区。<br>ubantu系统内已配置python3，所以只需要安装后续软件即可。<br>进入系统后打开terminal，首先输入dpkg -l 查看已安装软件，是否有python，如果有则不需要再安装python。</p><h3 id="安装pip3"><a href="#安装pip3" class="headerlink" title="安装pip3"></a>安装pip3</h3><pre><code>sudo apt-get update        //更新软件源sudo apt-get install python3-pip  pip3 --version  //查看版本sudo pip3 list //查看已安装的lib</code></pre><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><pre><code>sudo apt-get install mysql-server mysql-clientsudo service mysql restartmysql -uroot -p        //进入mysql命令界面</code></pre><p><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/3.png" srcset="/img/loading.gif" width="400px" height="250px"></p><h3 id="安装pymysql"><a href="#安装pymysql" class="headerlink" title="安装pymysql"></a>安装pymysql</h3><pre><code>pip3 install pymysql</code></pre><h3 id="安装virtualenv与virtualenvwrapper"><a href="#安装virtualenv与virtualenvwrapper" class="headerlink" title="安装virtualenv与virtualenvwrapper"></a>安装virtualenv与virtualenvwrapper</h3><pre><code>sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper</code></pre><p>安装好virtualenvwrapper后还无法使用，创建目录存放虚拟环境</p><pre><code>mkdir $HOME/.virtualenvs</code></pre><p>在~/.bashrc中添加</p><pre><code>export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh</code></pre><p>运行</p><pre><code>source ~/.bashrc</code></pre><p>创建python3虚拟环境</p><pre><code>mkvirtualenv -p 路径 /usr/bin/pythonX删除:rmvirtualenv 虚拟环境名称进入: workon 虚拟环境名称</code></pre><p>其他命令</p><pre><code>python -v  //进度python命令终端deactivate //退出虚拟环境pip freeze 查看虚拟环境安装的包</code></pre><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><pre><code>pip install Django==1.11.7django-admin startproject xxx 创建项目python manage.py startapp xxx 创建一个应用</code></pre><p>执行 python manage.py runserver 访问localhost:8000,看到it works则项目启动成功！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>英语短语整理</title>
    <link href="/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/"/>
    <url>/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="英语短语整理"><a href="#英语短语整理" class="headerlink" title="英语短语整理"></a>英语短语整理</h2><hr><h3 id="1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan"><a href="#1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan" class="headerlink" title="1.Queen Agrees to Period of Transition for Harry and Meghan."></a>1.Queen Agrees to Period of Transition for Harry and Meghan.</h3><ul><li>forge a new life 创造新生活</li><li>period of transistion 过渡期</li><li>following a day of … 什么事情之后的一天</li><li>thrown … into turmoil 引起骚乱</li><li>Britain’s monarchy 英国君主制</li><li>dominated the headlines for days 占据头条</li><li>remote prospect 机会渺茫</li><li>carve out 创造雕刻</li><li>back away from 躲开</li><li>in the coming days 在未来几天</li><li>make clear that 明确表示</li><li>be reliant on 依赖</li><li>on the lookout 注意，留心</li><li>cash in 从中牟利，捞到好处</li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冯诺依曼体系</title>
    <link href="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/"/>
    <url>/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-WiuuBbft" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="477417503" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="冯诺依曼简介"><a href="#冯诺依曼简介" class="headerlink" title="冯诺依曼简介"></a>冯诺依曼简介</h2><p>约翰·冯·诺依曼，美籍匈牙利数学家、计算机科学家、物理学家，毕业于苏黎世联邦工业大学，他是现代电子计算机与博弈论的重要创始人，被后人称为现代计算机之父、博弈论之父，并且他还改善了著名的蒙特卡洛算法。<br>1945年6月约翰·冯·诺依曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”。在报告中冯·诺伊曼明确提出了计算机的体系架构。从1951年第一台电子计算机EDVAC开始，计算机经历了多次的更新换代，不管是最原始的、还是最先进的计算机，使用的仍然是冯·诺依曼最初设计的计算机体系结构。因此冯·诺依曼被世界公认为“计算机之父”，他设计的计算机系统结构，称为“冯诺依曼体系结构”。</p><h2 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h2><p>冯诺依曼体系结构主要由五大部分组成，分别是控制器，运算器，存储器，输入设备和输出设备。至今为止，基本上所有的计算机也是遵循冯诺依曼体系所设计的，例如我们经常使用的手机，电脑，平板等等。<br>冯诺依曼提出的两个重要的思想，一个是存储程序的思想，另一个是二进制的思想，这两个思想在如今的计算机领域影响深远。<br>世界上第一台计算机EDVAC，采用了上千个电子管所设计的，体积十分庞大，设计者采用十进制对指令和数据进行计算处理，但执行过程复杂，运行效率慢。十进制与二进制的区别在哪？冯诺依曼为何提出二进制的存储思想呢？因为在早期的计算机电子元件设计中，通常使用高低电压来表示信息，即高电压为1，低电压为0.所以如果要采用十进制进行数据的计算，将二进制信息转换成我们日常所熟悉的十进制后再去进行处理，大大增加了计算机指令的设计难度，而使用二进制则解决了这一问题，后世很多科学家也提出了二进制浮点数的计算，以及反码补码阶码的概念，使二进制成为了计算机设计的中心。所以在今后的计算机中无论是指令还是数据都采用二进制的方式进行存储和计算。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/1.jpg" srcset="/img/loading.gif" width="375px" height="220px"><br>通常我们使用的计算机主要功能是负责运算，所以在冯诺依曼体系中以运算器为中心，而存储器负责存放指令和数据，指令和数据的计算和存储以及外部设备的连接也需要通过控制器进行控制。让我们排除输入输出设备之后，其实运算器，存储器和控制器才是整个计算机的核心，我们可以将三者看作一个黑箱子。当我们输入数据时，数据通过黑箱子，然后输出我们想要的结果，这便是图灵机的简单模型。</p><h2 id="冯诺依曼体系的特点"><a href="#冯诺依曼体系的特点" class="headerlink" title="冯诺依曼体系的特点"></a>冯诺依曼体系的特点</h2><ol><li>计算机由五大部件组成，运算器，存储器，控制器，输入设备，输出设备。</li><li>指令和数据采用二进制方式进行存储。</li><li>指令由地址码和操作码组成。</li><li>运算器为中心。</li><li>存储程序为主要思想。</li><li>指令和数据都以同等地位存入存储器，并且可按地址访问。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>心情随笔</title>
    <link href="/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-BhLxmUig" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1352045760" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近越来越喜欢写博客了，感觉就是自己向自己倾诉一样，或许这也是一些感情的寄托吧。自从参加了两次数学建模比赛，也发现自己的写作能力开始慢慢变强了，同时也明白了为什么有一些人喜欢写日记，因为这也是记录自己点点滴滴的一种方式吧，能让自己感觉到存在的意义。<br>自从大学以后感觉更加孤独了，学技术是寂寞的，枯燥的，只有做出一些作品，才会带给自己很多真实的成就感。这种感觉很奇妙，能让自己感觉到充实，感觉自己是活着的，感觉自己的人生是有意义的。</p><h2 id="倾诉"><a href="#倾诉" class="headerlink" title="倾诉"></a>倾诉</h2><p>最近学校放寒假了，也回家了。回家后避免不了受到父母的各种唠叨，以及亲戚朋友各种“友善”的人生建议，感觉活着越来越累了，想要变的优越一些，但又克服不了那些臭毛病，想要脱单，但心里没有什么喜欢的人，也没人喜欢，自卑在心底已经生根发芽了，最终想想罢了，还是回归现实吧。<br>回家后听到亲戚朋友闲聊，听说别人家的孩子现在创办了公司，一年盈利几百万。听说别人家的孩子最近考上了研究生，毕业以后也不用担心了。听说别人家的孩子，今年高考考进了名牌大学。听说别人家的孩子最近又出国了。听说别人家的孩子……<br>而自己呢？<br>越来越焦虑了，其实我只想当一个普通人罢了，但现在普通人的标准貌似也越来越高了，学习计算机对于父母而言，只不过是整日坐在电脑旁边虚度光阴罢了。挣扎着想要反驳一些什么，想想觉得还是算了，只会让自己更累。</p><blockquote><p>二十而立，三十不惑，四十知天命，如今自己刚过二十岁年纪，却感觉心里已经更老了十岁，人生就是这样，得过且过，顺其自然吧</p></blockquote><hr><p>抱怨就到这里，谈谈未来的人生规划和目标。</p><hr><ol><li>努力学习，考研计算机方向</li><li>毕业后好好工作，乐观生活</li><li>有一套属于自己的小房子</li><li>养一只猫</li><li>吃好喝好</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研的想法</title>
    <link href="/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇博客只是阐述以下我最近的想法，估计大部分人也不会看我的博客。如果有人不幸看到了的话，可以给我一些建议，谢谢。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>由于高考失利，加上地区政策要合并二三本等等，高考失败后没有复读，而是去选择上民办的三本学校（虽然现在已经没三本了），然后选择了计算机科学专业，因为我本身也是比较喜欢编程的，开学后就开始自学编程语言，做一些小程序。</p><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>刚开始我并没有考研的想法，只想着努力学技术，毕业后靠技术吃饭，我一直认为IT这个行业跟学历的关系并不大，只要你的技术强硬，一些大厂总有机会进去，工资也会很高。于是我就去学安卓，学网站等等，自学了不少东西，也做过一些demo。但由于只学专业课，我数学英语都不怎么好，四级也没过，只有专业课还凑合。</p><h2 id="考研想法的由来"><a href="#考研想法的由来" class="headerlink" title="考研想法的由来"></a>考研想法的由来</h2><p>目前大二上学期已经结束了，前一段时间跟我的专业课老师交流，他跟我聊他以前做的很多项目，那些项目都需要用一些复杂的算法去实现，还需要对计算机的深入理解，都是一些偏底层的东西，比如有关卫星，燃气，有色金属等等的项目。<br>然后我问他关于毕业工作的问题，需要学习多少技术，毕业后需不需要再去培训。<br>他给我分析了目前社会上的一些培训班，他们培训的东西都是一些java的电商项目，web前端等等，连微服务都涉及不到，至于培训python与人工智能的，大部分也是涉及较浅，用处不大。而且这些新技术、新框架过时的也很快。这些东西完全可以自学没必要报培训班。<br>建议我如果深入学计算机，想未来爬的高一点，还是需要考研的。</p><h2 id="如何考研？"><a href="#如何考研？" class="headerlink" title="如何考研？"></a>如何考研？</h2><p>在此之后我考研的念头就萌发了，这些天我一直在想一个问题，作为一个好歹算是科班出身的毕业生，我并不想学了四年结果毕业后和培训班一年出来的人一样的水准，甚至还不如。所以我毅然决定考研，如今遇到以下问题。</p><ul><li>1.三本学生如何选择考研学校？</li><li>2.基础薄弱怎么规划自己的学习?</li><li>3.现阶段应该怎么准备？</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>由于我也是比较现实的人，对自己的能力有所认知，所以我并不打算去考一些985，211名校，但也希望尽量上一个cs专业强一点的普通一本并争一争211学校的名额。<br>希望学长学姐以及有过考研经验的人可以给我一些帮助和建议，谢谢！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵转换</title>
    <link href="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵转换"><a href="#矩阵转换" class="headerlink" title="矩阵转换"></a>矩阵转换</h2><p>矩阵可以看作是一个向量的函数，则矩阵可以表示变换。<br>假设有以下向量(x,y),如何让该向量每个点横坐标扩大a倍，纵坐标扩大b倍，根据矩阵的点乘性质，则可以推出<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz1.png" srcset="/img/loading.gif" width="400px" height="100px"><br>假设矩阵还可以表示一个图形，那么如何将图形关于x轴翻转，也可以通过点乘另一个矩阵进行转换。例如<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz2.png" srcset="/img/loading.gif" width="400px" height="100px"><br>由此也可以推广出更多的转换。</p><hr><p>关于y轴的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz3.png" srcset="/img/loading.gif" width="400px" height="100px"><br>关于原点的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz4.png" srcset="/img/loading.gif" width="400px" height="100px"><br>沿x方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz5.png" srcset="/img/loading.gif" width="400px" height="100px"><br>沿y方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz6.png" srcset="/img/loading.gif" width="400px" height="100px"><br>关于原点进行旋转sitar角度<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz7.png" srcset="/img/loading.gif" width="400px" height="100px"></p><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>如果一个矩阵点乘另一个矩阵，矩阵的每一个元素没有发生任何变化，则称这种矩阵为单位矩阵。<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz8.png" srcset="/img/loading.gif" width="250px" height="130px"></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>单位矩阵的主对角线全为1.</li><li>单位矩阵一定是方阵.</li><li>假设单位矩阵为I，另一个矩阵为A，则I · A = A，A · I = A</li></ul><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在数字系统中，除了0之外，X * 1/X = 1.<br>那么在矩阵中，设矩阵A，B。如果A · B = B · A = I，则称B为A的逆矩阵，记作B = 1/A.</p><h3 id="性质与推广"><a href="#性质与推广" class="headerlink" title="性质与推广"></a>性质与推广</h3><ul><li>在矩阵系统中，有一些矩阵并没有逆矩阵。如果矩阵A存在逆矩阵，则称A为可逆矩阵，或者叫非奇异矩阵(non-singular)，相反如果矩阵不可逆，则称为不可逆矩阵，或者奇异矩阵(singular)。</li><li>如果存在矩阵A，B，C，B·A = I，则称B是A的左逆矩阵。如果A·C = I，则称C是A的右逆矩阵。</li><li>如果一个矩阵A既存在左逆矩阵B，又存在右逆矩阵C，则B=C。</li><li>对于矩阵A,如果存在逆矩阵B，则B唯一。</li><li>可逆矩阵一定为方阵，非方阵一定不可逆。</li><li>A的0次方 = I，A的-1次方为A的逆。</li><li>矩阵的逆的转置等于矩阵的转置的逆。</li><li><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz9.png" srcset="/img/loading.gif" width="250px" height="130px"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于javaSwing数据绑定及刷新</title>
    <link href="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/"/>
    <url>/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近学校期末了，正在进行java实训，实训要做一个图书管理系统。对于实现mysql数据库数据在JTable上的绑定，以及数据更新后界面的刷新时，遇到了问题。由于我对于JavaSwing完全不了解 ，实训时也是现学现卖，所以不清楚如何将数据绑定到JTable上。看了很多CSDN的博客，最后采用了以下方法。</p><h3 id="关于数据绑定的实现"><a href="#关于数据绑定的实现" class="headerlink" title="关于数据绑定的实现"></a>关于数据绑定的实现</h3><p>首先创建针对数据的模型类,以下的模型类是基于自定义Book表的简单示范</p><pre><code>/*book_list*/public class book_list extends javax.swing.table.DefaultTableModel{Class[] types = new Class[] { java.lang.Object.class, java.lang.String.class,            java.lang.String.class}; public book_list() {        super(new Object[][] {}, new String[] { &quot;bookname&quot;, &quot;booktype&quot;});}}</code></pre><p>然后对数据表进行填充，创建book对象，读取数据库中的数据后进行对象的赋值。利用循环将所有数据存入List中，而后利用循环从List中依次取得对象，并将各属性存入boo_list创建的对象中。然后创建JTable实体用model进行填充。这样可以将数据库的信息转换成可以填充JTable的对象。从而完成数据绑定的操作。</p><pre><code>    //图书表的创建    public static book_list model2 = new book_list();    public static JTable table2 = new JTable(model2);    ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;();    try {        sqlBookcod sql = new sqlBookcod();        ResultSet rs = sql.searchBook();        while (rs.next()) {            Book book = new Book();            book.setName(rs.getString(&quot;bookname&quot;));            book.setBookType(rs.getString(&quot;booktype&quot;));            list.add(book);        }    }catch(SQLException e) {        e.printStackTrace();    }    for (int i = 0; i &lt; list.size(); i++) {        Book b = (Book) list.get(i);        model2.addRow(new Object[] {b.getName(),b.getBookType()});    }}</code></pre><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>当时进行数据绑定后，直接将table添加到panel中，当数据更新后，table中的数据已经被定死了。所以我采用了简单粗暴的方法，通过监听菜单栏的点击事件，直接删除table中的所有数据，然后重新进行填充，并删除panel中的table控件，重新添加table，从而实现数据表的更新。</p><pre><code>//图书表清空数据public static void delmodel2() {    model2 = new book_list();    table2 = new JTable(model2);}public void stateChanged(ChangeEvent e) {                    if(tabbedPane.getSelectedIndex() == 0) {        panel1.remove(p1);                    //删除panel1中原有的组件            tablepan.delmodel1();                //删除数据表内容                            p1 = tablepan.createTextPanel1();    //重新填充数据表        panel1.add(p1);        panel1.repaint();                     //对panel1本身进行重绘    }}</code></pre><hr><h3 id="界面如下"><a href="#界面如下" class="headerlink" title="界面如下"></a>界面如下</h3><p><img src="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/wz1.png" srcset="/img/loading.gif" width="400px" height="250px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019个人总结</title>
    <link href="/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2019总结与反省"><a href="#2019总结与反省" class="headerlink" title="2019总结与反省"></a>2019总结与反省</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>当初带着坚定学习的决心，来到了大学校园，或许很多人并不清楚自己的目标是什么，我也一样。 我曾经不止一次问过自己，我为什么要学习计算机。 到最后也没有一个合适的理由说服自己，大概因为我什么也不会，除了带着点对计算机的兴趣与热爱之外，我不清楚自己还爱好着什么，也不知道自己将来要面对什么，也正如大多数人一样，只是为了生活去奋斗罢了。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>当初想着靠学技术到毕业工作，也努力学习了很多新技术，不再只会用c/c++敲黑窗口程序。图形界面程序从windowSdk到mfc又到winform，从winform到pythonGUI再到javaSwing。期间接触了很多编程语言，数据库技术，还有web前端技术以及一些网络的知识，服务器知识等。也了解过几种框架，入门过游戏引擎，做出了一些努力，但也曾有一段时间沉迷游戏，荒废时间。</p><h2 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h2><p>数学英语等课程依旧是这么差，技术水平增长缓慢也令我焦虑。当初只想搞技术的我，为其花费了大量的时间，导致我英语跟数学等科目没有跟上进度，现在悔悟基础课是多么重要。<br>当初坚定不打算考研的我，也在今年慢慢动摇，并决定考研一战。<br>感觉2019有收获也有后悔，自己所做出的努力在别人眼中或许根本不算努力，但总之没有自甘堕落，还有着目标和执行力。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="经历"><a href="#经历" class="headerlink" title="经历:"></a>经历:</h3><ul><li>年初参加蓝桥杯编程比赛拿到省三等奖。</li><li>肝封印者达到450w战力后弃坑。</li><li>假期学习unity做过几个小demo。</li><li>参加数学建模校赛，拿到三等奖，并得到333元奖金。</li><li>在学校创办兼职，写过python脚本程序处理excel。</li><li>担任学校计算机协会团支书并且给大一学生讲课。</li><li>买了服务器，但只玩了聊天室。</li><li>举办社团活动给学校师生修电脑。</li><li>学习Linux。</li><li>入坑古剑奇谭并且版本毕业。</li><li>看完了几本小说。</li><li>思考人生ing。</li><li>参加全国大学生数学建模比赛，拿到省一等奖。</li><li>入坑Django，重新复习前端。</li><li>莫名其妙进了学校实验班。</li><li>个人博客坏了一次，所有的文章丢失，又重新搭了博客网站并用了现在的主题。</li></ul><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><ul><li>依旧单身，没什么想法！</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是普普通通的一年，回想起来也没发生什么大事。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>学习英语数学以及计算机基础课，决定考研。</li><li>撰写博客同步发布到个人网站方便总结和复习。</li><li>勤写博客，勤刷题，每天坚持记英语单词。</li><li>继续进行基础知识的学习和练习。</li><li>深入学习框架并尝试进行项目实战。</li><li>稳住急躁的情绪，稳扎稳打。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵学习1</title>
    <link href="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/"/>
    <url>/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>向量是对数的拓展，一个向量表示一组数。<br>而矩阵是对向量的拓展，一个矩阵表示一组向量。<br>行数与列数相等的矩阵称为方阵。<br>一个矩阵可以拆分为n个行向量或者n个列向量，称矩阵为N x N矩阵。<br>矩阵可以表示成一个系统，例如在经济系统中，对于IT，电子，矿产，房产的投入，<br>可以表示成多个方程组，而方程组的系数则可用矩阵表示。</p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>行变成列，列变成行。</p><h3 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h3><p><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x1.png" srcset="/img/loading.gif" width="200px" height="80px"></p><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>每一个对应元素相加得到新矩阵</p><h3 id="矩阵的数量乘法"><a href="#矩阵的数量乘法" class="headerlink" title="矩阵的数量乘法"></a>矩阵的数量乘法</h3><p>标量去乘矩阵的每一个元素得到新矩阵</p><h3 id="矩阵的基本运算性质"><a href="#矩阵的基本运算性质" class="headerlink" title="矩阵的基本运算性质"></a>矩阵的基本运算性质</h3><p>A + B = B + A<br>(A + B) + C = A + (B + C)<br>存在矩阵O，满足：A + O = A<br>存在矩阵-A,满足：A + (-A) = O<br>-A 唯一, -A = -1 * A<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x2.png" srcset="/img/loading.gif" width="250px" height="70px"></p><h3 id="矩阵和向量的乘法"><a href="#矩阵和向量的乘法" class="headerlink" title="矩阵和向量的乘法"></a>矩阵和向量的乘法</h3><p>矩阵的列数必须和向量的元素个数一致。<br>矩阵与向量点乘，实际上将向量a转换成了向量b，所以矩阵可以理解为向量的函数。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x3.png" srcset="/img/loading.gif" width="350px" height="100px"><br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x4.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵和矩阵的乘法"><a href="#矩阵和矩阵的乘法" class="headerlink" title="矩阵和矩阵的乘法"></a>矩阵和矩阵的乘法</h3><p>矩阵A和矩阵B的每一个列向量相乘，要求矩阵A的列数必须和矩阵B的行数一致。<br>矩阵的乘法不遵守交换律。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x5.png" srcset="/img/loading.gif" width="350px" height="100px"><br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x6.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p>只有方阵才有矩阵的幂。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x7.png" srcset="/img/loading.gif" width="350px" height="100px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线代个人理解</title>
    <link href="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线性代数是从从研究一个数，到研究一组数的数学。<br>一组数的基本表示方法为向量，而向量也是线性代数研究的基本元素。<br>向量可以在多个维度表示一个Object的基本属性，方便我们数学的研究。<br>向量一般分为行向量与列向量，但在通常的教材和论文中，向量一般默认指列向量。<br>ps ： 由于印刷问题，列向量可以表示为(num1,num2)T。</p><h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><h3 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h3><p>如果两个向量(num1,num2) + (num3,num4),那么得到的结果为(num1+num3,num2+num4)。<br>向量的加法可以表示为在n维坐标中，继续增加n维度的单位。<br>例如(5,2)T + (2,5)T.<br>表示先在x维度上增加5个单位，在y维度上增加2个单位。再在x维度上增加2个单位，再在y维度上增加5个单位。那么在x维度总共有7个单位，在y维度总共也有7个单位，进而得到的向量的结果为(7,7).<br>它可以表示object在两个维度上的信息。</p><h3 id="向量的数量乘法"><a href="#向量的数量乘法" class="headerlink" title="向量的数量乘法"></a>向量的数量乘法</h3><p>简单来说乘法只是加法的推广和延申，那么向量的乘法同样也表示在n维度的坐标中，重复增加n维度个单位。</p><h3 id="向量运算的基本性质"><a href="#向量运算的基本性质" class="headerlink" title="向量运算的基本性质"></a>向量运算的基本性质</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/xl.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h3><p>二范数的概念：表示向量每个维度的平方相加再开二次方。例如勾股定理<br>那么向量的长度实际上就是求向量的二范数,也可以叫做求向量的模</p><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><p>单位向量是指这个向量去乘这个向量的模分之一，也就是保持向量的长度为1.所以单位向量的模永远为1，它只表示方向。<br>根据向量u求出单位向量u1的过程，也被称为是归一化，规范化(normalize)。<br>二维空间中，有两个特殊的单位向量 e1 = (1,0),e2 = (0,1)。<br>只由0，1组成的单位向量叫做，标准为单位向量(Standard Unit Vector)。<br>n维空间有n个标准为单位向量。</p><h3 id="两个向量相乘"><a href="#两个向量相乘" class="headerlink" title="两个向量相乘"></a>两个向量相乘</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/x2.png" srcset="/img/loading.gif" width="700px" height="150px"><br>两个向量相乘，结果为一个标量，这个标量代表两个向量的模相乘，再乘向量夹角的Cos值。这种乘法更严格的来说是两个向量的点乘，或者两个向量的内积。<br>向量的点乘也可以看作只有一行元素的矩阵与向量相乘。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
