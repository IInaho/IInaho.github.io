<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂乱</title>
    <link href="/2020/06/29/%E6%9D%82%E4%B9%B1/"/>
    <url>/2020/06/29/%E6%9D%82%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="杂乱代码"><a href="#杂乱代码" class="headerlink" title="杂乱代码"></a>杂乱代码</h1><p>主要放乱七八糟的代码</p><pre><code>struct Book {            //图书结点    string ISBN;    string bookName;    string price;};class BookCol {private:    Book *books;    int MAXSIZEBOOKS;public:    int num;                    //当前数量    BookCol() {        fstream file(&quot;F:\\program\\Test_project\\C-C++\\test&#39;\\test&#39;\\book.txt&quot;);        file &gt;&gt; MAXSIZEBOOKS;        //当前容量        num = 0;        books = new Book[MAXSIZEBOOKS];        char temp[256];        file.getline(temp, 100);        if (file.is_open()) {            file.getline(temp, 100);        }        file &gt;&gt; temp;        while (temp[0] != &#39;\0&#39;) {            setISBN(num, temp);            file &gt;&gt; temp;            setBookName(num, temp);            file &gt;&gt; temp;            setPrice(num, temp);            file &gt;&gt; temp;            num++;        }    }    //获取图书信息    string getISBN(int i) {        return books[i].ISBN;    }    string getBookName(int i) {        return books[i].bookName;    }    string getPrice(int i) {        return books[i].price;    }    //设置图书信息    void setISBN(int i,string ISBN) {        books[i].ISBN = ISBN;    }    void setBookName(int i,string bookName) {        books[i].bookName = bookName;    }    void setPrice(int i, string price) {        books[i].price = price;    }    //图书管理操作    void Increase() {        fstream file(&quot;F:\\program\\Test_project\\C-C++\\test&#39;\\test&#39;\\book.txt&quot;);        MAXSIZEBOOKS *= 2;        file.clear();        file &lt;&lt; MAXSIZEBOOKS;        Book *temp = new Book[MAXSIZEBOOKS];        for (int i = 0; i &lt; num; i++) {            temp[i].bookName = getBookName(i);            temp[i].ISBN = getISBN(i);            temp[i].price = getPrice(i);        }        this-&gt;books = temp;    }    void delBook(string ISBN);        //图书删除    int InsertBook();                //图书插入    void revealBook(string ISBN);    //修改价格    //图书查找    int findBook(string ISBN);    void bookSort();            //图书排序    int bookCount();            //图书数量    void printBook();            //遍历图书信息};void BookCol::delBook(string ISBN) {    int i = findBook(ISBN);    while (i &lt; num-1) {        setISBN(i, getISBN(i + 1));        setBookName(i, getBookName(i + 1));        setPrice(i, getPrice(i + 1));        i++;    }    //从文件中删除    fstream file(&quot;F:\\program\\Test_project\\C-C++\\test&#39;\\test&#39;\\book.txt&quot;, ios::out);    file &lt;&lt; MAXSIZEBOOKS &lt;&lt; endl;    file &lt;&lt; &quot;ISBN&quot; &lt;&lt; &quot;            &quot; &lt;&lt; &quot;图书名称&quot; &lt;&lt; &quot;                &quot; &lt;&lt; &quot;价格&quot; &lt;&lt; endl;    for (int i = 0; i &lt; num-1; i++) {        file &lt;&lt; getISBN(i) &lt;&lt; &quot;        &quot; &lt;&lt; getBookName(i) &lt;&lt; &quot;                &quot; &lt;&lt; getPrice(i) &lt;&lt; endl;    }    num--;}void BookCol::bookSort() {    Book temp;    for (int i = 0; i &lt; num; ++i) {        temp = books[i];        //将待插入的数据存放入监视哨中        // 设置查找区间        int low = 0;        int high = i - 1;        // 折半查找插入位置        while (low &lt;= high) {            int m = (low + high) / 2;            if (temp.price &lt; books[m].price) {                high = m - 1;            }            else {                low = m + 1;            }        }        for (int j = i - 1; j &gt;= high + 1; --j) {    //记录后移            books[j + 1] = books[j];        }        books[high + 1] = temp; //进行插入    }}void BookCol::revealBook(string ISBN) {        //修改图书价格    int i = findBook(ISBN);    cout &lt;&lt; &quot;输入修改的价格&quot; &lt;&lt; endl;    string price;    cin &gt;&gt; price;    setPrice(i, price);    //从文件中删除    fstream file(&quot;F:\\program\\Test_project\\C-C++\\test&#39;\\test&#39;\\book.txt&quot;, ios::out);    file &lt;&lt; MAXSIZEBOOKS &lt;&lt; endl;    file &lt;&lt; &quot;ISBN&quot; &lt;&lt; &quot;            &quot; &lt;&lt; &quot;图书名称&quot; &lt;&lt; &quot;                &quot; &lt;&lt; &quot;价格&quot; &lt;&lt; endl;    for (int i = 0; i &lt; num; i++) {        file &lt;&lt; getISBN(i) &lt;&lt; &quot;        &quot; &lt;&lt; getBookName(i) &lt;&lt; &quot;                &quot; &lt;&lt; getPrice(i) &lt;&lt; endl;    }}void BookCol::printBook() {        //现实图书    for (int i = 0; i &lt; num; i++) {        cout &lt;&lt; &quot;图书号:&quot; &lt;&lt; getISBN(i) &lt;&lt;&quot; &quot;&lt;&lt; &quot;图书名称:&quot; &lt;&lt; getBookName(i) &lt;&lt;&quot; &quot;&lt;&lt; &quot;图书价格:&quot; &lt;&lt; getPrice(i) &lt;&lt;endl;    }}int BookCol::InsertBook(){        //插入图书    string bookname;     string price;     string ISBN;    if (num &gt;= MAXSIZEBOOKS) {        Increase();    }    cout &lt;&lt; &quot;请输入图书名称&quot; &lt;&lt; endl;    cin &gt;&gt; bookname;    setBookName(num, bookname);    cout &lt;&lt; &quot;请输入图书价格&quot; &lt;&lt; endl;    cin &gt;&gt; price;    setPrice(num, price);    cout &lt;&lt; &quot;请输入图书ISBN&quot; &lt;&lt; endl;    cin &gt;&gt; ISBN;    setISBN(num, ISBN);    fstream file;    file.open(&quot;F:\\program\\Test_project\\C-C++\\test&#39;\\test&#39;\\book.txt&quot;, ios::app);    file &lt;&lt; ISBN &lt;&lt; &quot;        &quot;&lt;&lt; bookname &lt;&lt;&quot;            &quot; &lt;&lt; price &lt;&lt; endl;    num++;    return 1;}int BookCol::findBook(string ISBN) {    //查找图书    int i;    int flog = 0;    for (i = 0; i &lt; MAXSIZEBOOKS; i++) {        string isbn = getISBN(i);        if (ISBN == isbn) {             flog = 1;            break;         }    }    if(flog) return i;    else return -1;}int BookCol::bookCount() {            //统计图书    return num;}int main() {    BookCol *b = new BookCol();    int flag = 1;    char ch;    cout &lt;&lt; &quot;\t\t--------0. 现实所有图书--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------1. 查找图书--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------2. 插入图书--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------3. 删除图书--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------4. 修改图书价格--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------5. 图书价格排序--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------6. 统计图书数量--------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t--------q. 退出--------&quot; &lt;&lt; endl;    while (flag) {        cin &gt;&gt; ch;        switch (ch)        {        case &#39;0&#39;: {            b-&gt;printBook();        }break;        case &#39;1&#39;: {            string isbn;            cout &lt;&lt; &quot;请输入ISBN号&quot; &lt;&lt; endl;            cin &gt;&gt; isbn;            int i = b-&gt;findBook(isbn);            cout &lt;&lt; &quot;图书编号:&quot; &lt;&lt; b-&gt;getISBN(i) &lt;&lt; &quot;图书名称:&quot; &lt;&lt; b-&gt;getBookName(i) &lt;&lt; &quot;图书价格:&quot; &lt;&lt; b-&gt;getPrice(i) &lt;&lt; endl;        }break;        case &#39;2&#39;: {            b-&gt;InsertBook();        }break;        case &#39;3&#39;: {            cout &lt;&lt; &quot;请输入ISBN号&quot; &lt;&lt; endl;            string isbn;            cin &gt;&gt; isbn;            b-&gt;delBook(isbn);        }break;        case &#39;4&#39;: {            string isbn;            cout &lt;&lt; &quot;请输入ISBN号&quot; &lt;&lt; endl;            cin &gt;&gt; isbn;            b-&gt;revealBook(isbn);        }break;        case &#39;5&#39;: {            b-&gt;bookSort();        }break;        case &#39;6&#39;: {            cout &lt;&lt; &quot;图书数量为:&quot; &lt;&lt; b-&gt;bookCount() &lt;&lt; endl;        }break;        case &#39;q&#39;: {            flag = 0;        }break;        default:            break;        }    }    cin.get();    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(持续更新)</title>
    <link href="/2020/06/15/%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/06/15/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h1><h2 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h2><p>排序是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。<br>假设含n个记录的序列为{<script type="math/tex">r_1,r_2,...,r_n</script>}，其相应的关键字分别为{<script type="math/tex">k_1,k_2,...,k_n</script>}，需确定1,2,…,n的一种排列<script type="math/tex">p_1,p_2,...,p_n</script>，使其相应的关键字满足<script type="math/tex">k_{p1}\leq k_{p2}\leq ... \leq k_{pn}</script>(非递减或非递增)关系，即使得序列成为一个按关键字有序的序列，这样的操作称为排序。</p><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假设<script type="math/tex">k_i=k_j(1\leq i\leq n，1\leq j\leq n，i\neq j)</script>，且在排序前的序列中$r_i$领先于$r_j$(即i&lt;j)。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的;反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。</p><h2 id="内部排序与外部排序"><a href="#内部排序与外部排序" class="headerlink" title="内部排序与外部排序"></a>内部排序与外部排序</h2><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为内排序、外排序。<br>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p><h3 id="内部排序方法分类"><a href="#内部排序方法分类" class="headerlink" title="内部排序方法分类"></a>内部排序方法分类</h3><p>根据逐步扩大记录有序序列长度的原则不同，可以将内部排序分为以下几类。</p><ul><li>插入类，直接插入排序、折半插入排序、希尔排序</li><li>交换类，冒泡排序、快速排序</li><li>选择类，简单选择排序、树形选择排序、堆排序</li><li>归并类，2-路归并排序</li><li>分配类，基数排序</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的基本思想是: 每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序是将一条记录插入到已经排好序的有序表中，从而得到一个新的、记录数量增1的有序表。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>设待排序的记录存放在数组r[1..n]中，r[1]是一个有序序列。</li><li>循环n-1次，每次使用顺序查找法，查找r<a href="i = 2,...,n">i</a>在已经排好序的序列r[1…i-1]中的插入位置，然后将r[i]插入表长为i-1的有序序列r[1…i-1]，直到将r[n]插入表长为n-1的有序序列r[1…n-1]，最后得到一个表长为n的有序序列。</li></ul><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>为了在查找插入位置的过程中避免数组下标出界，r[0]设置监视哨。</p><pre><code>void InsertSort(){    for(i=2;i&lt;=L.length;++i){        if(L.r[i].key &lt; L.r[i-1].key){            L.r[0]=L.r[i];            L.r[i]=L.r[i-1];            for(j=i-2;L.r[0].key &lt; L.r[j].key;--j){                L.r[j+1] = L.r[j];                    }            L.r[j+1] = L.r[0];        }    }}</code></pre><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>直接插入排序采用顺序查找法查找当前记录<strong>在已排好序的序列中的插入位置</strong>，而查找插入位置的过程可以使用折半查找来实现，由此进行的插入排序称之为折半插入排序。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>设待排序的记录存放在数组r中</li><li>循环n-1次，每次使用折半查找法，寻找插入位置，然后插入该元素，最后得到一个表长为n的有序序列。</li></ul><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>void BInsertSort(SqList &amp;L){    for(i = 2; i&lt;= L.length; ++i ){        L.r[0] = L.r[i];        //将待插入的数据存放入监视哨中        // 设置查找区间        low = 1;        high = i-1;        // 折半查找插入位置        while(low &lt;= high){            m = (low+high)/2;            if(L.r[0].key &lt; L.r[m].key ){                high = m-1;            }else{                low = m+1;            }        }        for(j = i-1;j&gt;=high + 1; --j){    //记录后移            L.r[j+1] = L.r[j];        }        L.r[high+1]=L.r[0]; //进行插入    }}</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>折半查找比顺序查找快，因此折半插入排序优于直接插入排序，在平均情况下，折半插入排序仅减少了比较次数，而记录的移动次数不变，算法时间复杂度仍为$O(n^2)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>折半插入排序所需附加存储空间与直接插入排序相同，空间复杂度为$O(1)$.</p><h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul><li>稳定排序，只能用于顺序结构，不能用于链式结构</li><li>适合初始记录无序、n较大的情况。</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序又称为缩小增量排序，直接插入排序，当待排序的记录个数较少且待排序序列的关键字基本有序时，效率较高。希尔排序基于以上两点，从<strong>减少记录个数</strong>和<strong>序列基本有序</strong>两个方面对直接插入排序进行了改进。</p><h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>希尔排序实质上是采用分组插入的方法，先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样当经过几次分组排序后，整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。</p><ul><li>第一趟取增量$d_1(d_1&lt;n)$把全部记录分成$d_1$个组，<strong>所有间隔为$d_1$的记录分在同一组</strong>，在各组中进行直接插入排序。</li><li>第二趟取增量$d_2(d_2 &lt; d_1)$，重复上述的分组和排序。</li><li>依此类推，直到所取的增量<script type="math/tex">d_t=1(d_t < d_{t-1} < ... < d_2 < d_1)</script>，所有记录在同一组中进行直接插入排序为止。</li></ul><h3 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h3><p>假设给定序列为<script type="math/tex">\{8,9,1,7,2,3,5,4,6,0\}</script>.</p><p>初始增量为5，整个数组分成了5组，分别为<script type="math/tex">\{8,3\}，\{9,5\}，\{1,4\}，\{7,6\}，\{2,0\}</script>。<br>对这5组分别使用插入排序，结果可以发现，这五组中的相对小元素都被调到了前面.<br>缩小增量为2，整个数组分成了2组，分别为<script type="math/tex">\{3,1,0,9,7\}，\{5,6,8,4,2\}</script>。<br>对这2组分别使用插入排序，此时整个数组的有序性是很明显的。<br>再缩小增量为1，整个数组分成了1组，<script type="math/tex">\{0,2,1,4,3,5,7,6,9,0\}</script><br>只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>void ShellInsert(SqList &amp;L,int dk){    for(i = dk+1;i&lt;=L.length;++i){        if(L.r[i].key &lt; L.r[i-dk].key){            L.r[0] = L.r[i];        }        // 记录后移        for(j = i - dk; j&gt;0 &amp;&amp; L.r[0].key &lt; L.r[j].key; j -=dk;){            L.r[j+dk] = L.r[j];        }        L.r[j+dk] = L.r[0];    }}void ShellSort(SqList &amp;L,int dt[],int t){    for(k = 0; k &lt; t; ++k){        ShellInsert(L,dt[k]);    //一趟增量为dt[t]的希尔插入排序    }}</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>增量大于1时，关键字较小记录不是一步一步移动，而是跳跃式移动，使得在进行最后一趟增量为1的排序时，序列已基本有序，因此希尔排序的时间复杂度较直接插入排序低。希尔排序的时间复杂度取决于其增量序列，因此求希尔排序的时间复杂度是一个复杂的问题。<br>有人指出，当增量序列为$dt[k]2^{t-k+1}-1$时，希尔排序的时间复杂度为$O(n^{3/2})$，其中t为排序趟数，<script type="math/tex">1\geq k\geq t\geq [log_2(n+1)]</script>.</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>希尔排序的空间复杂度也为$O(1)$.</p><h3 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h3><ul><li>记录跳跃式地移动导致排序方法是不稳定地</li><li>只能用于顺序结构</li><li>增量序列取法不同，但应该使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须为1</li><li>记录总的比较次数和移动次数都比直接插入排序少，n越大，效果越明显，适合于初始记录无序，n较大的情况。</li></ul><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>交换排序的基本思想: 两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果发生逆序，则进行交换，从而使关键字小的记录如气泡一样逐渐向上漂浮或者坠落。</p><h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>设待排序的记录存放在数组r中，将第一个记录与第二个记录的关键字进行比较，如果逆序，则交换，然后比较第二个记录与第三个记录的关键字，直到最后一次交换，第一趟比较完成。</li><li>然后进行第二次排序，对前n-1个记录进行同样的操作，其结果是使关键字次大的记录被安置到第n-1个记录的位置上。</li><li>重复上述操作，直至某一趟排序过程中没有进行交换记录的操作，说明排序完成。</li></ul><h3 id="算法代码示例"><a href="#算法代码示例" class="headerlink" title="算法代码示例"></a>算法代码示例</h3><pre><code>#define MAXSIZE 10typedef struct Key {    int key;}Key;typedef struct SqList {    Key *r;    int length;}SqList;void CreateArray(SqList &amp;L) {    L.r = (Key*)malloc(sizeof(Key)*MAXSIZE);    L.length = 0;    for (int i = 0; i &lt; 10; i++) {        L.r[i].key = i;        L.length++;    }}void Print(SqList L) {    int i = 0;    while (i++ &lt; L.length - 1) {        cout &lt;&lt; L.r[i].key;    }    cout &lt;&lt; endl;}void BubbleSort(SqList &amp;L) {    int m = L.length-1;    int flag = 1;            //标志某趟是否完成交换。    Key t;    while ((m &gt; 0) &amp;&amp; (flag == 1)) {    //如果某趟没有进行交换，说明已排序完成        flag = 0;        for (int j = 1; j &lt;= m; j++) {            if (L.r[j].key &lt; L.r[j + 1].key) {                flag = 1;                //交换                t = L.r[j];                L.r[j] = L.r[j + 1];                L.r[j + 1] = t;            }        }--m;    }}int main() {    SqList L;    CreateArray(L);    Print(L);    BubbleSort(L);    Print(L);    getchar();    return 0;}</code></pre><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况(初始序列为正序)，只需要进行一趟排序，只进行n-1次关键字比较，且不移动记录。<br>最坏情况(初始序列为逆序)，需进行n-1趟排序，总的关键字比较次数KCN和记录移动次数RMN分别为:</p><script type="math/tex;mode=display">KCN = \displaystyle \sum^{2}_{i=n}(i-1) = n(n-1)/2 \approx n^2/2</script><script type="math/tex;mode=display">RMN = 3\displaystyle \sum^{2}_{i=n}(i-1) = 3n(n-1)/2 \approx 3n^2/2</script><p>在平均情况下，冒泡排序比较次数与记录移动次数分别为$n^2/4$和$3n^2/4$，时间复杂度为$O(n^2)$.</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>交换时需要一个临时存储变量，所以空间复杂度为$O(1)$。</p><h3 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h3><ul><li>稳定排序</li><li>可用于链式存储结构</li><li>移动次数较多，算法平均时间性能比直接插入排序差，当初始无序，n较大时不建议使用。</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>在冒泡排序中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序，如果能通过两个不相邻记录的一次交换，消除多个逆序，则会加快排序的速度，因此有了快速排序的算法。</p><h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>在待排序的n个记录中任取一个记录(通常取第一个记录)作为枢轴，设其关键字为pivotkey，经过一次排序后，把所有关键字小于pivotkey的记录交换到前面，所有大于pivotkey的记录交换到后面，然后将待排序记录分成两个子表，枢轴放置其分界处，重复上述过程，直到每个子表只有一个记录时，排序完成。</p><ul><li>选择待排序表中的第一个记录作为枢轴，将其暂存在r[0]中，附设两个指针low和high，分别指向表的下界和上界。</li><li>从表的最右侧位置依次向左搜索，找到第一个关键字小于枢轴关键字pivotkey的记录，将其移到low处。</li><li>再从表的最左侧位置，依次向右搜索找到第一个关键字大于pivotkey的记录和枢轴记录交换。</li><li>重复步骤二和三，直到low与high相等为止，此时low与high的位置即为枢轴在此趟排序中的最终位置，原表被分成两个子表。</li></ul><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>//ADT示例int Partition(SqList &amp;L,int low,int high){    L.r[0] = L.r[low];            //子表的第一个记录作为枢轴    pivotkey = L.r[low].key;    //存放枢轴的key    while(low &lt; high){        while(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) --high;        L.r[low] = L.r[high];    //从右向左找第一个比枢轴小的值        while(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) ++low;        L.r[high] = L.r[low];    //从左向右找第一个比枢轴大的值    }    L.r[low]=L.r[0];    return low;}void QSort(SqList &amp;L,int low,int high){    if(low &lt; high){        pivotloc = Partition(L,low,high);    //枢轴位置        QSort(L,low,pivotloc-1);    //对左子表递归排序        QSort(L,pivotloc+1,high);    //对右子表递归排序    }}void QuickSort(SqList &amp;L){    QSort(L,1,L.length);}//简易代码void Quickly_sort(int num[], int start, int end) {    int le = start, ri = end, pivot;            //使左下标从首元素开始向前滚动，右下标从末尾元素开始向后滚动    int temp;    pivot = num[(start + end) / 2];                //pivot为数组的中间值（最小下标+最大下标处以2）    while (le &lt;= ri) {        while (num[le] &lt; pivot) le++;            //从左向右，找大于中心点的值        while (num[ri] &gt; pivot)    ri--;            //从右向左，找小于中心点的值        if (le &lt;= ri) {            temp = num[le];            num[le] = num[ri];            num[ri] = temp;            le++;    ri--;                        //互换后，左下标与右下标，向前滚动一个位置  （如果交换后不进行滚动，此时while条件永远不成立，if条件始终成立，程序无限循环进行交换）        }    }    if (start != le)        Quickly_sort(num, start, ri);    if (ri != end)        Quickly_sort(num, le, end);}int main(){    int num[] = { 78, 56, 89, 43, 24, 69, 42, 120, 324, 75 };    int length = (sizeof(num) / sizeof(num[0]));                //获取数组长度（数组所占内存大小除以数组元素所占字节）    Quickly_sort(num, 0, length - 1);                            //传入数组首地址,首元素的下标,末尾元素的下标    for (int i = 0; i &lt; length; i++)        printf(&quot;%d\t&quot;, num[i]);    getchar();    return 0;}</code></pre><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>快速排序的时间复杂度取决于递归树的深度，最好情况下每次将记录均匀分割成两个长度大致相等的子表，时间复杂度为$O(nlog_2n)$，最坏情况下其递归树为单支树，比较次数为$n^2/2$，平均情况下，快速排序的时间复杂度为$O(nlog_2n)$。</p><h4 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>快速排序是递归的，执行时需要一个栈来存放相应的数据，最大递归调用次数与递归树的深度一致，最好情况为$O(log_2n)$，最坏情况下为$O(n)$.</p><h3 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h3><ul><li>记录非顺次的移动导致排序方法是不稳定的</li><li>排序过程中需要定位表的下界和上界，所以适合顺序结构，很难用于链式结构。</li><li>当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序，n较大的情况。</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的基本思想是每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排好序的记录序列的最后，直到全部排完为止。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>简单选择排序也称为直接选择排序</p><h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>设待排序记录存放在数组r[1…n]中，第一趟从r[1]开始，通过n-1次比较，从n个记录中选出关键字最小的记录，记为r[k]，交换r[1]与r[k].</li><li>第二趟从r[2]开始，通过n-2次比较，从n-1个记录中选出<strong>关键字最小</strong>的记录，记为r[k]，交换r[2]和r[k]。</li><li>依次类推，第i趟从r[i]开始，通过n-1次比较，从n-i+1个记录中选出关键字最小的记录，记为r[k]，交换r[i]与r[k].</li><li>经过n-1趟，排序完成。</li></ul><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>void SelectSort(SqList &amp;L){    for(i = 1; i&lt;L.length; ++i){        k=i;        for(j=i+1;j&lt;=L.length;++j){        //找出最小关键字的下标            if(L.r[j].key &lt; L.r[k].key) k=j;        }        if(k != i){        //k==i表示不存在比k小的关键字            t = L.r[i];            L.r[i] = L.r[k];            L.r[k] = t;        }    }}</code></pre><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>简单排序过程中，所需进行记录移动的次数较少，最好的情况下不移动，最坏的情况下需要移动$3(n-1)$次，无论记录初始排序如何，所需进行的个关键字比较次数相同，为$n^2/2$，因此简单选择排序时间复杂度为$O(n^2)$。</p><h4 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>同冒泡排序一样，只有在两个记录交换时需要一个辅助空间，空间复杂度为O(1)。</p><h3 id="算法特点-4"><a href="#算法特点-4" class="headerlink" title="算法特点"></a>算法特点</h3><ul><li>它是一种稳定的排序</li><li>可用于链式存储结构</li><li>移动记录次数较少，当每一记录占用空间较多时，此方法比直接插入排序快。</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序就是将两个或两个以上有序表合并成一个有序表的过程，将两个有序表合并成一个有序表的过程称为<strong>2-路归并</strong>。<br>假设初始系列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，如重复，直到得到一个长度为n的有序序列为止。</p><h2 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h2><h3 id="归并相邻两个有序序列"><a href="#归并相邻两个有序序列" class="headerlink" title="归并相邻两个有序序列"></a>归并相邻两个有序序列</h3><p>设两个有序表存在同一数组中相邻位置，R[low…mid]和R[mid+1..high]，每次分别从两个表中取出一个记录进行关键字比较，将较小者放入T[low..high]中，重复此过程，直至其中一个表为空，最后将另一非空表中余下的部分直接复制到T中。</p><h3 id="归并排序步骤"><a href="#归并排序步骤" class="headerlink" title="归并排序步骤"></a>归并排序步骤</h3><ul><li>将当前序列一分为二，求出分裂点mid = [(low+high)/2]。</li><li>对子序列R[low…mid]递归，进行归并排序，结果存入S[low…mid]中。</li><li>对子序列R[mid+1…high]递归，进行递归排序，结果存入S[mid+1…high]。</li><li>调用算法Merge，将有序的两个子序列S[low…mid]和S[mid+1…high]归并成一个有序的序列T[low…high]。</li></ul><p>递归过程举例<br><img src="/2020/06/15/%E6%8E%92%E5%BA%8F/2.png" srcset="/img/loading.gif" width="450px" height="350px"></p><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><pre><code>//相邻两个有序子序列的归并void Merge(RedType R[],RedType T[],int low,int mid,int high){    i = low;    j = mid + 1;    k = low;    while(i &lt;= mid &amp;&amp; j &lt;=high){        if(R[i].key &lt;= R[j].key) T[k++] = R[i++];        else T[k++] = R[j++];    }    while(i &lt;= mid) T[k++] = R[i++];        //移动剩余记录    while(j &lt;= high) T[k++] = R[j++];}//归并排序void MSort(RedType R[],RedType T[],int low,int high){    int mid;    int S[MAXSIZE+1];    if(low == high){        T[low] = R[low];    }    else{        mid = (low+high)/2;        MSort(R,S,low,mid);            //对左子序列递归排序        MSort(R,S,mid+1,high);        //对右子序列递归排序        Merge(S,T,low,mid,high);    //归并    }}void MergeSort(SqList &amp;L){    MSort(L.r,L.r,1，L.length);}</code></pre><h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><pre><code>void MergeSort2(SqList *L){    int* TR = (int*)malloc(L.length*sizeof(int));    int k=1;    while(k &lt; L-&gt;length){        MergePass(L-&gt;r,TR,K,L-&gt;length);    //将L-&gt;r的序列两两归并到TR        k *= 2;        MergePass(TR,L-&gt;r,k,L-&gt;length);    //将TR的序列两两归并到L-&gt;r        k *= 2;    }}void MergePass(int SR[],int TR[],int s,int n){    int i=1;    //增量    int j;    // 1、2归并，3、4归并...    while(i &lt;= n-2*s+1){        Merge(SR,TR,i,i+s-1,i+2*s-1);        i = i+2*s;    }    //尾数处理    if(i &lt; n-s+1) Merge(SR,TR,i,i+s-1,n);    //归并最后两个序列    else{        for(j = i;j &lt;= n; j++)    //若最后只剩单个子序列            TR[j] = SR[j];    }}</code></pre><h2 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h3><p>当有n个记录时，需要进行$log_2n$趟归并排序，每一趟排序，其关键字比较次数不超n，元素移动次数为n，因此归并排序的时间复杂度为$O(nlow_2n)$。<br>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$log_2n$的栈空间，因此空间复杂度为$O(n+logn)$。</p><h3 id="非递归算法-1"><a href="#非递归算法-1" class="headerlink" title="非递归算法"></a>非递归算法</h3><p>非递归的迭代方法，避免了递归时深度为$log_2n$的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为$O(n)$，并且避免递归也在时间性能上有一定的提升。</p><h2 id="算法特点-5"><a href="#算法特点-5" class="headerlink" title="算法特点"></a>算法特点</h2><ul><li>稳定排序</li><li>可用于链式结构</li></ul><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>分配排序是根据关键字中各位的值，通过对待排序记录进行若干趟分配和收集来实现排序的，是一种借助于多关键字排序的思想对单关键字排序的方法。<br>假设记录的逻辑关键字由d个关键字组成，每个关键字可能取rd个值，只要从最低数位关键字起，按关键字的不同值将序列中记录分配到rd个队列中再收集之，如此重复d次完成排序，这种方法称为基数排序。</p><h2 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>以链表存储n个待排记录，并令表头指针指向第一个记录</li><li>第一趟分配对最低数位关键字进行，改变记录的指针值将链表中的记录分配至10个链队列中，每个队列中的记录关键字的个位数相等。<br><img src="/2020/06/15/%E6%8E%92%E5%BA%8F/3.png" srcset="/img/loading.gif" width="450px" height="250px"></li><li>第一趟收集是改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的队头记录，重新将10个队列中的记录链成一个链表。<br><img src="/2020/06/15/%E6%8E%92%E5%BA%8F/4.png" srcset="/img/loading.gif" width="450px" height="250px"></li><li>第二趟分配和第二趟收集是对十位数进行的，第三次分配和收集是对百位数进行的，如此反复，至此排序完毕。<br><img src="/2020/06/15/%E6%8E%92%E5%BA%8F/5.png" srcset="/img/loading.gif" width="450px" height="250px"></li></ul><h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><pre><code>#define MAXNUM_KEY 8        //关键字项数最大值#define RADIX 10            //关键字基数#define MAX_SPACE 10000typedef struct{    KeyType keys[MAXNUM_KEY];        //关键字    InfoType otheritems;            //其他数据项    int next;}SLCell;                            //静态链表结点typedef struct{    SLCell r[MAX_SPACE];            //可利用空间    int keynum;                        //当前关键字个数    int recnum;                        //当前长度}SLList;typedef int ArrType[RADIX];            //数组类型//建立RADIX个子表，使同一子表中记录的key[i]相同void Distribute(SLCell &amp;r,int i,ArrType &amp;f,ArrType &amp;e){    //子表初始化    for(j=0; j&lt;RADIX; ++j){        f[j] = 0;        }    for(p = r[0].next;p;p=r[p].next){        j = ord(r[p.keys[i]]);        //ord将记录中第i个关键字映射        if(!f[j]) f[j] = p;        else r[e[j]].next = p;        e[j] = p;                    //p所指结点插入第j个子表中    }}//按keys[i]自小到大将f[0..RADIX-1]所指各子表依次链接成链表void Collect(SLCell &amp;r,int i,ArrType f,ArrType e){    for(j=0; !f[j]; j=succ(j));    //succ是求后继函数    r[0].next = f[j];    t = e[j];    while(j &lt; RADIX){        for(j = succ(j); j&lt;RADIX-1 &amp;&amp; !f[j]; j=succ(j));    //找下一个非空子表        if(f[j]){        //链接两个非空子表            r[t].next = f[j];            t = e[j];        }    }    r[t].next = 0;        //指向最后一个非空子表中最后一个结点}//对L做基数排序，使L成为按关键字自小到大有序静态链表，L.r[0]为头节点void RadixSort(SLList &amp;L){    //L是静态链表表示的顺序表    for(i=0; i&lt;L.recnum; ++i) L.r[i].next = i+1;    L.r[L.recnum].next = 0;    for(i=0; i&lt;L.keynum; ++i){        Distribute(L.r,i,f,e);        //分配        Collect(L.r,i,f,e);            //收集    }}</code></pre><h2 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h2><p>假设每个记录含d个关键字，每个关键字取值范围为rd个值。</p><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对n个记录进行基数排序，每一趟分配的时间复杂度为$O(n)$，每一趟收集的时间复杂度为$O(rd)$,整个排序需进行d趟分配和收集，时间复杂度为$O(d(n+rd))$.</p><h3 id="空间复杂度-5"><a href="#空间复杂度-5" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>所需辅助空间为2rd个队列指针，另外由于需用链表做存储结构，则相对于其他以顺序结构存储记录的排序方法而言，增加了n个指针域空间，所以时间复杂度为$O(n+rd)$.</p><h2 id="算法特点-6"><a href="#算法特点-6" class="headerlink" title="算法特点"></a>算法特点</h2><ul><li>稳定排序</li><li>可用于链式存储结构，也可用于顺序结构</li><li>时间复杂度可以突破基于关键字比较一类方法的下界$O(nlog_2n)$，达到$O(n)$.</li><li>基数排序需要知道各级关键字的主次关系和取值范围。</li></ul><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O中断</title>
    <link href="/2020/06/14/I-O%E4%B8%AD%E6%96%AD/"/>
    <url>/2020/06/14/I-O%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h1><ul><li>早期，外部设备与主机的连接采用<strong>分散连接</strong>，每一个设备都有专用的控制电路，这些控制电路与CPU的控制电路设计在一起，紧耦合，增加和删除外部设备困难。CPU与IO设备串行工作，主要使用程序查询方式。</li><li>随着外部设备增多，分散连接不适用于外部设备与主机的连接，因此出现了<strong>IO接口与DMA控制器</strong>，连接方式使用<strong>总线连接</strong>，一个总线可以连接多个设备，CPU与IO设备并行工作，出现了两种工作方式分为中断方式、DMA方式。</li><li>为了使输入输出系统的控制尽可能从主机中独立出来，出现了具有<strong>通道结构的阶段</strong>，通道可以看做成小型的DMA控制器，通道有自己的指令系统。</li><li>I/O处理机阶段</li></ul><h1 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h1><h2 id="IO软件"><a href="#IO软件" class="headerlink" title="IO软件"></a>IO软件</h2><p>IO软件的主要功能: 将用户编制的程序输入主机内，将运算结果输出给用户，实现输入/输出系统与主机工作的协调。</p><h3 id="IO指令"><a href="#IO指令" class="headerlink" title="IO指令"></a>IO指令</h3><p>IO指令分为操作码、命令码和设备码三部分组成，操作码负责IO指令区别其他指令的判别代码，命令码负责I/O的具体操作，设备码用来判断对哪一个设备操作。</p><h3 id="通道指令"><a href="#通道指令" class="headerlink" title="通道指令"></a>通道指令</h3><p>通道指令又称为通道控制字，它是通道用于执行IO操作的指令，可以由管理程序存放在主存的任何地方，由通道从主存中取出并执行。通道程序由通道指令组成，它完成某种外部设备与主存间传送信息的操作。</p><h2 id="IO硬件"><a href="#IO硬件" class="headerlink" title="IO硬件"></a>IO硬件</h2><p>输入/输出系统的硬件组成是多种多样的，在带接口的I/O系统中，I/O硬件包括接口模块和I/O设备两大部分。在具有通道或I/O处理器的I/O系统中，I/O硬件包括通道、设备控制器、IO设备等。</p><h1 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h1><p>I/O设备分为: 输入设备、输出设备、输入/输出兼容设备.</p><h2 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h2><ul><li>键盘，按下一个键，查出按了哪个键，然后将此键翻译为ASCII码传输给计算机。</li><li>鼠标，光电鼠标内部的发光二极管发出的光线经过表面反射通过一组光学透镜，传输到一个光感应器件内成像，当光电鼠标移动时，其轨迹便会被记录为一组高速拍摄的连贯图像，被光电鼠标内部的专用图形分析芯片处理，完成光标定位。</li></ul><h2 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h2><h3 id="阴极射线管-CRT-显示器"><a href="#阴极射线管-CRT-显示器" class="headerlink" title="阴极射线管(CRT)显示器"></a>阴极射线管(CRT)显示器</h3><p>CRT显示器按扫描方式不同 ，分为光栅扫描与随机扫描，按分辨率不同，分为高分辨率和低分辨率。</p><ul><li>分辨率指显示器所能表示的像素个数，分辨率越高，图像越清晰。</li><li>灰度级指黑白显示器中所显示像素点的亮暗差别。</li></ul><p>CRT发光是由电子束打在荧光粉上引起的，电子束扫过之后，发光亮度只能维持几十毫秒，为了使人眼能 看到稳定的图像，必须重复扫描整个屏幕，按人的视觉生理，刷新率大于30次/s时才不会感到闪烁。<br>分辨率为$1024\times 1024$像素，256级灰度的图像，存储容量为<script type="math/tex">1024\times 1024\times log_2(256)=1MB</script></p><h3 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h3><ul><li>击打式，点阵式(逐字、逐行)</li><li>非击打式，激光、喷墨</li></ul><h1 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h1><h2 id="总线连接方式的I-O接口电路"><a href="#总线连接方式的I-O接口电路" class="headerlink" title="总线连接方式的I/O接口电路"></a>总线连接方式的I/O接口电路</h2><p><img src="/2020/06/14/I-O%E4%B8%AD%E6%96%AD/1.png" srcset="/img/loading.gif" width="280px" height="300px"></p><ul><li>数据线: 用作I/O设备与主机之间传送数据</li><li>设备选择线: 用来传送设备码</li><li>命令线: 用来传输CPU向设备发出的各种命令信号</li><li>状态线: 将I/O设备的状态向主机报告的信号线。</li></ul><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><ul><li>选址功能，设备选择电路组成</li><li>传送命令功能，命令寄存器、命令译码器组成</li><li>传送数据功能，数据缓冲寄存器组成</li><li>反映设备状态功能，设备状态标记</li></ul><h2 id="I-O接口的基本组成"><a href="#I-O接口的基本组成" class="headerlink" title="I/O接口的基本组成"></a>I/O接口的基本组成</h2><p><img src="/2020/06/14/I-O%E4%B8%AD%E6%96%AD/2.png" srcset="/img/loading.gif" width="500px" height="180px"></p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><ul><li>按数据传送方式分类<ul><li>并行接口</li><li>串行接口</li></ul></li><li>按功能选择的灵活性分类<ul><li>可编程接口</li><li>不可编程接口</li></ul></li><li>按通用性分类<ul><li>通用接口</li><li>专用接口</li></ul></li><li>按数据传送的控制方式分类<ul><li>中断接口</li><li>DMA接口</li></ul></li></ul><h1 id="I-O方式"><a href="#I-O方式" class="headerlink" title="I/O方式"></a>I/O方式</h1><h2 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h2><p>程序查询方式又称为程序控制I/O方式，这种方式中，数据在CPU与外部设备之间的传输完全靠计算机程序控制，是在CPU主动控制下进行的，当需要输入或输出时，CPU暂停执行主程序，转去执行设备输入输出的服务程序，根据服务程序中的I/O指令进行数据传送。<br>这种方式的缺点在于每时每刻需要不断查询I/O设备是否准备就绪，为了正确完成这种查询，需要执行以下3条指令</p><ul><li>测试指令，用来查询I/O设备是否准备就绪</li><li>转移指令，若I/O设备未准备就绪，则执行转移指令，即转到测试指令，继续测试I/O设备的状态。</li><li>传送指令，若I/O设备准备就绪，则执行传送指令。</li></ul><h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><p>CPU启动I/O后，不需要停止现行程序的运行，而I/O接到启动命令后，进入准备阶段，准备就绪，向CPU提出请求，CPU中断现行程序，为I/O服务，这种方式不需要CPU时刻查询I/O设备的状态，一次中断处理过程归纳为5个阶段:</p><ul><li>中断请求、中断判优、中断响应、中断服务、中断返回</li></ul><h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p>DMA方式是一种完全由硬件进行成组信息传送的控制方式，数据准备阶段，CPU与外设并行，还降低了CPU在传送数据时的开销，因为信息传送不经过CPU，而在外设和内存之间直接进行。</p><h3 id="DMA的传送方法"><a href="#DMA的传送方法" class="headerlink" title="DMA的传送方法"></a>DMA的传送方法</h3><p>如果高速I/O(通过DMA接口)和CPU同时访存，这时CPU需要将总线占有权让给DMA接口使用，通常DMA与主存交换数据采用以下三种方法。</p><h4 id="停止CPU访问主存"><a href="#停止CPU访问主存" class="headerlink" title="停止CPU访问主存"></a>停止CPU访问主存</h4><p>DMA接口向CPU发一个信号，要求CPU放弃地总线使用权，然后DMA获得总线控制权后，开始进行数据传送，数据传输后，DMA接口通知CPU可以使用主存，并把总线控制权还给CPU。</p><h4 id="周期挪用"><a href="#周期挪用" class="headerlink" title="周期挪用"></a>周期挪用</h4><p>当I/O设备由DMA请求时，会遇到3种情况:</p><ul><li>CPU不在访存，故CPU与IO访存请求未冲突</li><li>CPU正在访存，等待存储周期结束后，CPU再将总线占有权让出</li><li>CPU与IO同时访存，此刻CPU要暂时放弃总线占有权，由I/O设备挪用一个或几个存储周期，这种方式既实现了I/O传送，又较好的发挥了主存与CPU的效率。</li></ul><h4 id="DMA与CPU交替访问"><a href="#DMA与CPU交替访问" class="headerlink" title="DMA与CPU交替访问"></a>DMA与CPU交替访问</h4><p>这种方式适用于CPU工作周期比主存存取周期长的情况，不需要总线使用权的申请、建立和归还过程，总线使用权分时控制。</p><h3 id="DMA接口的功能和组成"><a href="#DMA接口的功能和组成" class="headerlink" title="DMA接口的功能和组成"></a>DMA接口的功能和组成</h3><h4 id="DMA接口的功能"><a href="#DMA接口的功能" class="headerlink" title="DMA接口的功能"></a>DMA接口的功能</h4><ul><li>向CPU申请DMA传送</li><li>处理总线控制权的转交</li><li>管理系统总线、控制数据传送</li><li>确定数据传送的首地址和长度，修正传送过程中的数据地址和长度</li><li>DMA传送结束时，给出操作完成信号。</li></ul><h4 id="DMA接口组成"><a href="#DMA接口组成" class="headerlink" title="DMA接口组成"></a>DMA接口组成</h4><p><img src="/2020/06/14/I-O%E4%B8%AD%E6%96%AD/3.png" srcset="/img/loading.gif" width="500px" height="300px"></p><h3 id="DMA工作过程"><a href="#DMA工作过程" class="headerlink" title="DMA工作过程"></a>DMA工作过程</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>DMA接口开始工作前，CPU必须做如下工作:</p><ul><li>指明是输入数据还是输出数据</li><li>向DMA设备地址寄存器送入设备号，并启动设备</li><li>向DMA主存地址寄存器送入交换数据的主存首地址</li><li>对字计数器赋予交换数据的个数</li></ul><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>DMA是以数据块为单位传送的，具体流程如下:</p><ul><li>准备好一个字时，将该字读到DMA的数据缓冲寄存器中,表示数据缓冲寄存器满。</li><li>设备同时向DMA接口发请求</li><li>DMA接口向CPU申请总线控制权</li><li>CPU发出HLDA信号，表示允许将总线控制权交给DMA接口</li><li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器写</li><li>DMA控制逻辑告诉I/O，CPU已经安排了DMA周期，记住为下一个字的传送做准备</li><li>将DMA数据缓冲寄存器的内容送数据总线</li><li>主存将数据总线上的信息写至地址总线指定的存储单元中。</li><li>修改主存地址和字计数值。</li></ul><h4 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h4><p>当DMA中断请求得到响应后，CPU停止原程序执行，转去执行中断服务程序，做一些DMA的结束工作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>散列表的查找</title>
    <link href="/2020/06/14/%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/06/14/%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列表的定义"><a href="#散列表的定义" class="headerlink" title="散列表的定义"></a>散列表的定义</h2><p>顺序表和树表的查找中，记录在存储结构中的位置与关键字无直接关系，查找是通过比较进行的，如果结点特别多，需要和很多无效关键字进行比较，导致效率低下。<br>如果在元素的存储位置与关键字建立对应关系，进行查找时就无需进行比较，或者少数的比较，这就是<strong>散列查找法</strong>的思想，它通过对元素的关键字值进行某种运算，直接求出元素的存储位置，因此散列查找法又称为杂凑法或者散列法。</p><ul><li>散列函数和散列地址: 在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使p=H(key)，称这个对应关系H为散列函数(又称为哈希函数)，p为散列地址。</li><li>散列表或哈希表: 一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录，通常散列表的存储空间是一个一维数组，散列地址是数组的下标。</li><li>冲突和同义词: 对不同的关键字可能得到同一散列地址，即$key1\neq key2$，而$H(key1)=H(key2)$,这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1与key2互称为同义词。</li></ul><p>散列查找法主要研究以下两个问题:</p><ul><li>如何构造散列函数</li><li>如何处理冲突</li></ul><h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><p>构造散列表应该考虑下列因素:</p><ul><li>散列表的长度</li><li>关键字的长度</li><li>关键字的分布情况</li><li>计算散列函数所需的时间</li><li>记录的查找频率</li></ul><p>构造好的散列函数应该遵循以下两条原则:</p><ul><li>函数<strong>计算简单</strong>，每一个关键字只能有一个散列地址与之对应</li><li>函数的值域需在表长的范围内，计算出的散列地址的<strong>分布应均匀</strong>，尽可能减少冲突。</li></ul><h3 id="构造散列函数的常用方法"><a href="#构造散列函数的常用方法" class="headerlink" title="构造散列函数的常用方法"></a>构造散列函数的常用方法</h3><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>这种方法直接取关键字的某个线性函数值为散列地址，即<script type="math/tex">F(key)=a\times key +b</script>.<br>这样的散列函数优点是简单、均匀，也不会产生冲突，但需要事先知道关键字的分布情况，适合查找表较小且连续的情况，现实应用中并不常用。</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，可以从关键字中抽取数字分布均匀的若干位作为散列地址，如果出现冲突问题，还可以对这些数字进行反转、叠加、左右环位移等方法，目的为了合理将关键字分配到散列表的各个位置。<br>这种方法事先必须明确知道所有的关键字每一位上各种数字的分布情况，实际应用中例如手机号、同一出版社的所有图书等，某些位是相同的，可以抽取其他位作为散列地址。</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>平方取中法就是取关键字的平方，然后中间的几位作为散列地址，因为一个树平方后的中间几位数和数的每一位都相关，如果取中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，这种方法通常适合处理不知道关键字的分布，而位数不是很大的情况。</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>将关键字分成位数相同的几部分，然后取这几部分的叠加和(舍去进位)作为散列地址，根据数为叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。<br>移位叠加将分割后每部分的最低位对齐，然后相加。边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加，例如关键字为9876543210，分为四组，987|654|321|0，然后将987和321反转，变成789+654+123+0=1566，此时散列地址为566.</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>假设散列表表长为m，选择一个不大于m的数p，用p去除关键字，除后所得余数为散列地址，即</p><script type="math/tex;mode=display">H(key)=key\%p</script><p>这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。<br>除留余数法计算简单，适用范围非常广，是常用的构造散列表函数的方法，它不仅可以对关键字直接取模，也可在折叠、平方取中等运算后取模，这样能保证散列地址一定落在散列表的地址空间中。</p><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>好的散列函数可以在一定程度上避免冲突，但是难以完全避免冲突，创建散列表和查找散列表都会遇到冲突，两种情况下处理冲突的方法应该一致，处理冲突的方法与散列表本身的组织形式有关，按组织形式，通常分为开放地址法和链地址法。</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>把记录都存储在散列表数组中，当某一记录关键字key的初始散列地址$H_0=H_0(key)$发生冲突时，以$H_0$为基础，采用合适的方法计算得到另一个地址$H_1$，如果$H_1$依然重复，再根据$H_1$计算下一个地址$H_2$…,直到不冲突为止。<br>这种方法寻找下一个空的散列地址时，原来数组空间对所有的元素都是开放的，所以称为开放地址法，通常把寻找下一个空位的过程称为探测，可用以下公式表示:</p><script type="math/tex;mode=display">H_i=(H(key)+d_i)\%m，i=1,2,...,k(k\leq m-1)</script><p>H(key)为散列函数，m为散列表表长，$d_i$为增量序列，根据$d_i$的取值可分为3种探测方法。</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><script type="math/tex;mode=display">d_i=1,2,...,m-1</script><p>这种探测方法将散列表假想成一个循环表，发生冲突后，从冲突地址下一个单元顺序寻找空单元，如果到最后一个位置也没找到，则回到表头开始找，直到找到一个空位，找不到空位说明散列表已满。</p><h4 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h4><script type="math/tex;mode=display">d_i=1^2,-1^2,2^2,-2^2,3^2,...,+k^2,-k^2，(k\leq m/2)</script><h4 id="伪随机探测法"><a href="#伪随机探测法" class="headerlink" title="伪随机探测法"></a>伪随机探测法</h4><p>在冲突时，对于位移量$d_i$采用随机函数计算得到，称之为随机探测法。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在处理冲突时发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象称为”<strong>二次聚集</strong>“或”<strong>堆积</strong>“。<br>线性探测法的优点是只要散列表未填满，总能找到一个不发生冲突的地址，缺点是会产生<strong>堆积</strong>现象，二次探测法和伪随机法可以避免<strong>堆积</strong>现象，但不能保证一定找到不发生冲突的地址。</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>如果发生冲突，不需要更换地址，链地址法将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。<br>这种方法绝不会出现找不到地址的情况，但是带来了查找时需要遍历单链表的性能损耗。</p><h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>将发生冲突的关键字存放到公共溢出区中，如下图所示<br><img src="/2020/06/14/%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/1.png" srcset="/img/loading.gif" width="450px" height="80px"></p><p>在查找时，先在基本表相应位置查找，如果不等，再去溢出区表进行顺序查找，在冲突数据很少的情况下，公共溢出区的结构对于查找性能来说还是很高的。</p><h2 id="散列表的查找算法实现"><a href="#散列表的查找算法实现" class="headerlink" title="散列表的查找算法实现"></a>散列表的查找算法实现</h2><pre><code>#define SUCCESS 1#define UNSUCCESS 0#define HASHSIZE 12        //散列表长度#define NULLKEY -32768typedef struct{    int *elem;    //动态数组    int count;    //元素个数}HashTable;int m=0;        //散列表表长Status InitHashTable(HashTable *H){    int i;    m = HASHSIZE;    H-&gt;count = m;    H-&gt;elem = (int*)malloc(m*sizeof(int));    for(i=0;i&lt;m;i++){        H-&gt;elem[i]=NULLKEY;    }    return OK;}int Hash(int key){    return key % m;}void InsertHash(HashTable *H,int key){    int addr = Hash(key);    //求散列地址    while(H-&gt;elem[addr] != NULLKEY){        //开放定址法的线性探测        addr = (addr+1) % m;    }    H-&gt;elem[addr] = key;}Status SearchHash(HashTable H,int key,int *addr){    //散列表查找    *addr = Hash(key);    while(H.elem[*addr] != key){        *addr = (*addr+1) %m;        if(H.elem[*addr] == NULLKEY || *addr == Hash(key)){    //循环回到原点            return UNSUCCESS;        }    }    return SUCCESS;}</code></pre><h3 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h3><p>如果没有冲突，散列查找的时间复杂度为O(1),但实际应用中，冲突不可避免，散列查找的平均查找长度取决于以下三种因素:</p><ul><li>散列函数是否均匀，散列好处的好坏影响出现冲突的频繁程度</li><li>处理冲突的方法，处理冲突的方法不同，会使平均查找长度不同。</li><li>散列表的<strong>装填因子α=填入表中的记录个数/散列表长度</strong>，α标志这散列表的装满程度，当填入表中的记录越多，α越大，产生冲突的可能性越大，所以散列表的平均查找长度取决于装填因子。</li></ul><p>不论记录个数n有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内，此时散列查找的时间复杂度就是O(1)，但是会浪费一定的空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表和树表的查找</title>
    <link href="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h1><ul><li><strong>查找表</strong>: 查找表(Search Table)是同一类型数据元素的集合.</li><li><strong>关键字</strong>: 数据元素中某个数据项的值，又称为<strong>键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项，称为<strong>关键码</strong>.如果此关键字可以唯一的标识一个记录，则称此关键字为<strong>主关键字</strong>(Primary Key),对不同地记录，主关键字均不同，主关键字所在地数据项称为<strong>主关键码</strong>.对于可以识别多个数据元素地关键字，称之为<strong>次关键字</strong>(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素地关键字，对应地数据项是<strong>次关键码</strong>。</li><li><strong>查找</strong>: 查找是根据某个给定的值，在查找表中找到一个关键字等于给定值的记录或数据元素，如果表中存在这样的元素，则称<strong>查找成功</strong>，否则<strong>查找失败</strong>。</li><li>动态查找表与静态查找表: 若在查找的同时对表做修改操作，则相应的表称为<strong>动态查找表</strong>，否则称之为<strong>静态查找表</strong>。<ul><li>静态查找表是只作查找操作的查找表，主要操作是查询某个特定数据元素是否在表中，或者检索某个特定的数据元素和各种属性</li><li>动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li></ul></li><li><strong>平均查找长度</strong>: 为确定记录在查找表中的位置，需要和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的<strong>平均查找长度</strong>。</li></ul><h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找的过程为: 从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。<br>数据元素类型定义:</p><pre><code>typedef struct{    KeyType key;        //关键字域    InfoType otherinfo;    //其他域}ElemType;typedef struct{    ElemType *R;        //存储空间基地址    int length;            //当前长度}SSTable;</code></pre><p>假设从1位置开始查找，0位置不用，查找算法如下:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){    for(i=ST.length;i&gt;=1;--i){        if(ST.R[i].key == key) return i;    }    return 0;}</code></pre><p>在上面的算法中，每一步都需要检测整个表是否查找完毕，即需要判断i&gt;=1是否成立，改进此算法，可以增加一个哨兵，例如ST.R[0]关键字赋值key，如下例所示:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){    ST.R[0].key = key;    for(i=ST.length;ST.R[i].key != key;--i);    return i;        //返回0代表没找到}</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>设置监视哨，可以免去查找过程中每一步进行检测整个表是否查找完毕，实践证明，这个改进能使顺序表在大于1000长度的表中，进行一次查找所需的平均时间减半，两个时间复杂度都为O(n)。<br>顺序查找的优点: 算法简单，对表结构无要求。<br>顺序查找的缺点: 平均查找长度较大，查找效率低，当n很大时，不宜使用顺序查找。</p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找也称二分查找，它是一种效率较高的查找方法，但折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="折半查找的过程"><a href="#折半查找的过程" class="headerlink" title="折半查找的过程"></a>折半查找的过程</h3><p>从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功，如果给定值大于或小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，重复操作。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>为了标记查找过程中每一次的查找区间，分别用low和high表示区间的上下限，用mid表示区间的中间位置。</p><ol><li>置查找区间初值，low为1，high为表长。</li><li>当low小于等于high时，循环执行以下操作:<ol><li>mid取值为low和high的中间值</li><li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid</li><li>若不相等则利用中间位置记录将表对分成前、后两个子表，如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1.</li></ol></li><li>循环结束，说明查找区间为空，则查找失败，返回0.</li></ol><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><pre><code>int Search_Bin(SSTable ST,KeyType key){    low=1;    high=ST.length;    while(low &lt;= high){        mid = (low+high)/2;        if(key == ST.R[mid].key) return mid;        else if(key &lt; ST.R[mid].key) high=mid-1;        else low=mid+1;    }    return 0;}</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>折半查找的过程可用二叉树描述，树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号，把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/1.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度，具有n个结点的判定树深度为$log_2n+1$,折半查找的时间复杂度为$O(log_2n)$.</p><ul><li>折半查找的优点: 比较次数少，查找效率高</li><li>折半查找的缺点: 只能用于顺序表查找，查找前需要排序。</li></ul><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找是每次将查找区间缩小1/2进行查找，如果要在取值范围0-10000之间100个元素从小到大均匀分布的数组中查找5，我们自然考虑从数组下标较小的开始查找。<br>折半查找代码的$mid=(low+high)/2$经过变换后可以得到$mid=low+1/2(high-low)$,这个等式可以改进为$mid=low+((key-a[low])/(a[high]-a[low])(high-low))$，将$1/2$改为了$(key-a[low])/(a[high]-a[low])$，这种方法就是<strong>插值查找法</strong>。<br>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式。</p><pre><code>mid = low + (high-low) * (key-a[low]) / (a[high]-a[low]);     //修改折半查找的mid</code></pre><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>折半查找是每次查找总是一分为二，插值查找是对折半查找的改进，使其在数据分布均匀情况下查找效率更高，而斐波那契查找，利用了黄金分割原理来实现，斐波那契数列如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/2.png" srcset="/img/loading.gif" width="500px" height="80px"></p><p>斐波那契搜索就是在折半查找的基础上根据斐波那契数列进行分割的，在平均性能上来说，斐波那契查找要由于折半查找，但在最坏情况下，例如key=1，那么始终处于左侧长半区查找，查找效率就低于折半查找。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>斐波那契查找算法的核心在于:</p><ul><li>key值与第mid=（low+high）/2相等，mid位置的元素即为所求；</li><li>key值大于第mid=（low+high）/2，则令 low=mid+1；</li><li>key值小于第mid=（low+high）/2，则令high=mid-1。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>int Fibonacci_Search(int *a,int n,int key){    int low,high,mid,i,k;    low=1;            //最低下标为记录首位    high=n;            //最高下标为记录末位    k=0;    while(n &gt; F[k]-1) k++;    //计算n位于斐波那契数列的位置    for(i=n;i&lt;F[k]-1;i++) a[i]=a[n];    //将不满的数值补全    while(low&lt;=high){        mid = low+F[k-1]-1;        //计算当前分隔的下标        if(key&lt;a[mid]){            high = mid-1;            k=k-1;        }else if(key &gt; a[mid]){            low=mid+1;            k=k-2;        }else{            if(mid &lt;= n) return mid;            else return n;        }    }    return 0;}</code></pre><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>前面的几种查找方法都是基于有序的基础之上的，如果数据集增长很快，要保证记录全部按照当中某个关键字有序，时间代价很高，所以这种数据通常按先后顺序存储，对于这种查找表，需要利用索引来快速查找数据。<br>索引是为了加快查找速度而设计的一种数据结构，索引就是把每一个关键字和它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息，索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引的分类: <strong>线性索引</strong>、<strong>树形索引</strong>、<strong>多级索引</strong>，线性索引就是将索引集合组织为线性结构，也成为索引表。</p><h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图所示:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/4.png" srcset="/img/loading.gif" width="350px" height="250px"></p><p>稠密索引要应对的可能是成千上万的数据，因此对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列，索引项有序意味着，在查找关键字时，可以用到折半、插值、斐波那契等查找算法，但如果数据集非常大，意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能需要反复访问磁盘，查找性能大大下降。</p><h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。<br>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p><ul><li>块内无序，即每一块内的记录不要求有序</li><li>块间有序，例如要求第二块的所有记录的关键字均大于第一块中所有记录的关键字，块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引叫做分块索引。</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大。</li><li>存储了块中的记录个数，以便于循环使用。</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找又称为<strong>索引顺序查找</strong>，这是一种性能介于顺序查找和折半查找之间的一种查找方法，在分块索引表中查找，分为两步进行:</p><ol><li>在分块索引表中查找要查关键字所在的块</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。</li></ol><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。<br>索引项的通用结构是次关键码、记录号表，其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。</p><h1 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h1><p>折半查找效率虽然较高，但是由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为了<strong>维护表的有序性</strong>，需要移动表中很多记录，导致额外浪费时间。<br>若要对动态查找表进行高效率的查找，可以采用几种特殊的二叉树作为查找表的组织方式。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。</p><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树:</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/5.png" srcset="/img/loading.gif" width="300px" height="250px"><br>例如上图是对序列{62，88，58，47，35，73，51，99，37，93}进行构造的二叉排序树。</p><h4 id="二叉排序树的二叉链表存储结构"><a href="#二叉排序树的二叉链表存储结构" class="headerlink" title="二叉排序树的二叉链表存储结构"></a>二叉排序树的二叉链表存储结构</h4><pre><code>typedef struct{    KeyType key;            //关键字项    InfoType otherinfo;        //其他数据项}ElemType;typedef struct BSTNode{    ElemType data;            //数据域，包括关键字和其他数据项    struct BSTNode *lchild,*rchild;}BSTNode,*BSTree;</code></pre><h3 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h3><p>二叉排序树可以看作一个有序表，因此在二叉排序树上进行查找和折半查找类似。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则查找失败，返回空指针</li><li>若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较:<ul><li>若key等于T-&gt;data.key，则查找成功，返回根结点地址</li><li>若key小于T-&gt;data.key，则递归查找左子树</li><li>若key大于T-&gt;data.key，则递归查找右子树</li></ul></li></ul><h4 id="算法代码示例"><a href="#算法代码示例" class="headerlink" title="算法代码示例"></a>算法代码示例</h4><pre><code>BSTree SearchBST(BSTree T,KeyType key){    if((!T) || key == T-&gt;data.key)    return T;    else if(key &lt; T-&gt;data.key) return SearchBST(T-&gt;lchild,key);    else return SearchBST(T-&gt;rchild,key);}</code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>在二叉排序树上查找其关键字等于给定值的结点的过程，恰好是走完了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1(或是结点所在层次数)。<br>和折半查找类似，与给定值比较的关键字个数不超过数的深度，但折半查找长度为n的顺序表的判定树是唯一的，而含n个结点的二叉排序树不唯一。<br>如果给定的含n个记录的序列有序，那么构造二叉排序树时，不断向右子树添加结点，二叉排序树会变成一个深度为n的单支树，其平均查找长度为(n+1)/2，这就是最坏的情况，而最好的情况便是和二分查找的判定树类似，但二叉排序树适合维护，对于经常需要添加删除的序列来说，显然适合使用二叉排序树。</p><h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p>二叉排序树的插入操作以查找为基础的，将一个关键字值为key的结点插入到二叉排序树，需要从根结点向下查找，当树中不存在关键字等于key的结点时，才能进行插入。<br>新结点的插入一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则待插入结点*S作为根结点插入空树中。</li><li>若二叉排序树非空，则将key与根结点的关键字T-&gt;data.key进行比较。<ul><li>若key小于T-&gt;data.key，则将*S插入左子树</li><li>若key大于T-&gt;data.key，则将*S插入右子树</li></ul></li></ul><blockquote><p>中序遍历一棵二叉排序树，可以得到一个结点值递增的有序序列。</p></blockquote><h4 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void InsertBST(BSTree &amp;T,ElemType e){    if(!T){        S = new BSTNode;        S-&gt;data = e;        S-&gt;lchild = S-&gt;rchild = NULL;        T = S;            //新结点插入找到的位置    }    else if(e.key &lt; T-&gt;data.key) InsertBST(T-&gt;lchild,e);    else if(e.key &gt; T-&gt;data.key) InsertBST(T-&gt;rchild,e);}</code></pre><p>二叉排序树插入的基本过程是查找，所以时间复杂度同查找一养，也是$O(log_2n)$.</p><h3 id="二叉排序树的创建"><a href="#二叉排序树的创建" class="headerlink" title="二叉排序树的创建"></a>二叉排序树的创建</h3><p>二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>将二叉排序树T初始化为空树</li><li>读入一个关键字为key的结点</li><li>如果读入的关键字key不是输入结束标志，则循环执行以下操作<ul><li>将此结点插入二叉排序树T中</li><li>读入一个关键字为key的结点</li></ul></li></ul><h4 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void CreatBST(BSTree &amp;T){    T = NULL;    cin &gt;&gt; e;    while(e.key != ENDFLAG){    //ENDFLAG表示输入结束标志        InsertBST(T,e);        cin &gt;&gt; e;        }}</code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>假设有n个结点，则需要插入n次，而插入一个结点的算法时间复杂度为$O(log_2n)$，则创建二叉排序树的算法时间复杂度为$O(nlog_2n)$.</p><h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>被删除的结点可能是二叉排序树中的任何结点，删除结点后，要根据其位置不同修改双亲结点及相关结点的指针，以保持二叉排序树的特性。</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/7.png" srcset="/img/loading.gif" width="500px" height="350px"></p><p>从二叉排序树的根结点开始查找关键字为key的待删结点，分三种情况讨论:</p><ul><li>若待删结点为叶子结点，由于删除叶子结点不破坏树的整体结构，因此只需要修改其双亲的结点指向空即可。</li><li>若待删结点只有左子树或者只有右子树，只要使其左子树或右子树称为其双亲结点的左子树即可。</li><li>若待删结点的左右子树均不为空，为了保证删除该结点后，其他元素之间的相对位置不变，有以下两种方案:<ul><li>使待删结点的左子树为其双亲结点的左子树，然后待删结点的右子树为其直接前驱的右子树</li><li>令待删结点的直接前驱代替待删结点，然后删除此结点的直接前驱</li></ul></li></ul><p>第二种方案图例如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/6.png" srcset="/img/loading.gif" width="500px" height="230px"></p><p>显然，前一种处理方法可能增加树的深度，而后一种方法是以被删结点左子树中关键字最大的结点(左子树中最大的结点一定没有右子树)代替被删结点，然后从左子树中删除这个结点，这种方法更好。</p><h4 id="算法示例-2"><a href="#算法示例-2" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void DeleteBST(BSTree &amp;T,KeyType key){    //查找关键字值等于key的结点    p = T;     f = NULL;                    //f保存p的双亲结点    while(p){        if(p-&gt;data.key == key) break;        f = p;        if(p-&gt;data.key &gt; key) p = p-&gt;lchild;        else p = p-&gt;rchild;    }    if(!p) return;    //被删结点的左右子树均不为空    q=p;    if((p-&gt;lchild) &amp;&amp; (p-&gt;rchild)){        s = p-&gt;lchild;                        //找到被删结点的直接前驱        while(s-&gt;rchild){            q=s;                            //保存待删结点的直接前驱的双亲结点，用于重接            s=s-&gt;rchild;        }        p-&gt;data = s-&gt;data;                    //将待删结点的直接前驱来替换待删结点        if(q != p){            q-&gt;rchild = s-&gt;lchild;            //重接q的右子树        }        else{            q-&gt;lchild = s-&gt;lchild;            //重接q的左子树        }        delete s;        return;    }else if(!p-&gt;rchild){                    //被删结点无右子树        p = p-&gt;lchild;    }else if(!p-&gt;lchild){                    //被删结点无左子树        p = p-&gt;rchild;    }    //p指向的子树挂接到其双亲结点的对应位置    if(!f) T=p;                                //被删结点为根结点    else if(q == f-&gt;lchild) f-&gt;lchild = p;    else f-&gt;rchild = p;    delete q;}</code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>二叉排序树删除的基本过程也是查找，所以算法时间复杂度为$O(log_2n)$.</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>二叉排序树查找算法的性能取决于树的结构，而树的结构取决于给定数据是否有序，对于有序的数据进行构造二叉排序树，树的结构会是一棵深度为数据长度的单支树，查找效率低，事实上，树的高度越小，查找效率越高，为了使二叉排序树的高度尽量小，前苏联数学家提出了<strong>平衡二叉树</strong>的概念，也成为<strong>AVL</strong>树。</p><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/8.png" srcset="/img/loading.gif" width="500px" height="300px"></p><p>平衡二叉树或者是空树，或者是具有下列特征的二叉排序树:</p><ul><li>左子树和右子树的深度之差的绝对值不超过1</li><li>左子树和右子树也是平衡二叉树</li><li>平衡二叉树必须是二叉排序树</li></ul><p>二叉树上结点的平衡因子定义为该结点左子树与右子树的深度只差。</p><h3 id="AVL的平衡调整方法"><a href="#AVL的平衡调整方法" class="headerlink" title="AVL的平衡调整方法"></a>AVL的平衡调整方法</h3><p>在二叉排序树构造的过程中，如果新加入的结点破环了平衡二叉树的特性，就需要对树进行调整，调整方法为: 找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为<strong>最小不平衡子树</strong>，可将重新平衡的范围局限于这棵子树。</p><p>假设有一个数组a[10]={3,2,1,4,5,6,7,10,9,8}需要构建二叉排序树，在没有了解二叉平衡树之前，根据二叉排序树的特性会构建成如下图1的样子，树的深度为8，查找效率是很低的。当我们学了平衡二叉树之后会构建成如下图2的样子，树的深度只有4，效率提高了一倍。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/9.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>首先根据二叉排序树的特性插入结点”3”，然后再插入”2”，此时结点”3”的bf为1，再插入”1”，此时结点”2”的bf值变为2，如图1所示，树已经不平衡了所以需要调整树，因为bf值为正，所以需要将整个树进行右旋，此时结点”2”成为根结点，结点”3”成为2的右孩子，如图2所示，然后再插入结点”4”，bf并没有发生改变。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/10.png" srcset="/img/loading.gif" width="450px" height="150px"></p><p>插入结点”5”之后，结点”3”,”4”,”5”组成了最小不平衡子树，此时结点”3”的bf值为-2，由于bf值是负值，所以需要对这棵最小不平衡子树进行左旋，如图5，此时整棵树又达到平衡。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/11.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>继续插入结点”6”，此时根结点”2”的bf值变为-2，所以需要对根结点进行左旋，但由于本来结点3是4的左孩子，旋转后需要满足二叉排序树的特性，因此它成了结点2的右孩子，如图7所示。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/12.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>插入结点”7”,发现结点”5”的bf值为-2，左旋由结点”5”,”6”,”7”组成的最小不平衡子树，如图9所示，此时整棵树达到平衡。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/13.png" srcset="/img/loading.gif" width="400px" height="150px"></p><p>当插入结点”10”时，结构无变化 ，再增加结点”9”，此时结点”7”的bf值变为-2，理论上只需要旋转最小不平衡子树”7”,”9”,”10”即可，但左旋转后，结点”9”成了结点”10”的右孩子，不符合二叉排序树的特性，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/14.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>通过观察发现，结点”7”的bf值为-2，但结点”10”的bf值为1，它们的bf值政府不统一，而前几次的旋转，最小不平衡子树的根结点和它的子结点符号都是相同的，因此需要先使符号统一，所以对结点”9”和结点”10”进行右旋，使结点”10”成为”9”的右子树，结点”9”的bf值为-1，此时不平衡子树的根结点与子结点符号统一，再对结点”7”进行左旋，得到图”13”，然后再加入结点”8”<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/15.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>此时结点”6”的bf值为-2，结点”9”的bf值为1，符号不统一，因此需要首先以9为根结点，进行右旋得到图15，此时结点”6”与结点”7”的bf值都为负，再以6为根结点左旋，最终得到最后的平衡二叉树如图16所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/16.png" srcset="/img/loading.gif" width="400px" height="180px"></p><h4 id="调整AVL的四种情况"><a href="#调整AVL的四种情况" class="headerlink" title="调整AVL的四种情况"></a>调整AVL的四种情况</h4><p>假设不平衡子树的根结点为A</p><ul><li>在A左子树根结点的左子树上插入结点，需要进行一次右旋</li><li>在A右子树根结点的右子树上插入结点，需要进行一次左旋</li><li>在A左子树根结点的右子树上插入结点，需要先对子树进行逆时针左旋使bf符号相同，然后再顺时针右旋。</li><li>在A右子树根结点的左子树上插入结点，需要先对子树进行顺时针右旋使bf符号相同，然后再逆时针左旋。</li></ul><h3 id="AVL代码示例"><a href="#AVL代码示例" class="headerlink" title="AVL代码示例"></a>AVL代码示例</h3><h4 id="存储结构代码示例"><a href="#存储结构代码示例" class="headerlink" title="存储结构代码示例"></a>存储结构代码示例</h4><p>在树结点结构中增加一个bf代表平衡因子，平衡因子的绝对值如果大于2，说明树不平衡，需要进行调整。</p><pre><code>typedef struct BiTNode{    int  data;                            //结点数据    int bf;                                //结点的平衡因子    struct BiTNode *lchild,*rchild;        //左右孩子指针}BiTNode,*BiTree;</code></pre><h4 id="旋转代码示例"><a href="#旋转代码示例" class="headerlink" title="旋转代码示例"></a>旋转代码示例</h4><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/17.png" srcset="/img/loading.gif" width="500px" height="200px"></p><p>右旋操作时，当传入一个二叉排序树p，将它的左孩子结点定义为L，将L的右子树变成p的左子树，然后将p改为L的右子树，最后将L替换p成为根结点，这样就完成了一次右旋操作，如下图所示，N为插入结点，左旋操作大同小异。</p><pre><code>void R_Rotate(BiTree *p){        //右旋操作    BiTree L;    L = (*p)-&gt;lchild;    (*p)-&gt;lchild=L-&gt;rchild;    L-&gt;rchild = (*p);     *p = L;}void L_Rotate(BiTree *p){        //左旋操作    BiTree R;    R = (*p)-&gt;rchild;    (*p)-&gt;rchild = R-&gt;lchild;    R-&gt;lchild = (*p);    *p = R;}</code></pre><h4 id="平衡调整代码示例"><a href="#平衡调整代码示例" class="headerlink" title="平衡调整代码示例"></a>平衡调整代码示例</h4><pre><code>#define LH +1    //左高#define EH 0    //等高#define RH -1    //右高void LeftBalance(BiTree *T){    //T是不平衡子树，对T进行左平衡旋转处理，且左子树高度大于右子树高度    BiTree L,Lr;    L = (*T)-&gt;lchild;        //左孩子赋给L    switch(L-&gt;bf){        case LH:            //新结点插入在T的左孩子的左子树上            (*T)-&gt;bf = L-&gt;bf = EH;    //将bf值改为0            R_Rotate(T);            //进行右旋操作            break;        case RH:            //新结点插入在T的左孩子的右子树上            Lr = L-&gt;rchild;            //修改bf值            switch(Lr-&gt;bf){                case LH:                     (*T)-&gt;bf = RH;                    L-&gt;bf = EH;                    break;                case EH:                     (*T)-&gt;bf = L-&gt;bf = EH;                    break;                case RH:                    (*T)-&gt;bf = EH;                    L-&gt;bf = LH;                    break;            }            Lr-&gt;bf = EH;            //进行双旋操作，先对左子树左旋，再对根右旋            L_Rotate(&amp;(*T)-&gt;lchild);            R_Rotate(T);    }}void RightBalance(BiTree *T){        //右平衡    BiTree R,Rr;    R = (*T)-&gt;rchild;    switch(R-&gt;bf){        case LH:            //新结点插入在右孩子的右子树上            (*T)-&gt;bf = R-&gt;bf = EH;            L_Rotate(T);    //左旋操作            break;        case RH:            //新结点插入在右孩子的左子树上            Rr = R-&gt;lchild;            //修改bf值            switch(Rr-&gt;bf){                case LH:                     (*T)-&gt;bf = RH;                    R-&gt;bf = EH;                    break;                case EH:                     (*T)-&gt;bf = R-&gt;bf = EH;                    break;                case RH:                    (*T)-&gt;bf = EH;                    R-&gt;bf = LH;                    break;            }            Rr-&gt;bf = EH;            R_Rotate(&amp;(*T)-&gt;rchild);    //先右旋            L_Rotate(T);                //再左旋    }}</code></pre><h4 id="AVL树的插入操作"><a href="#AVL树的插入操作" class="headerlink" title="AVL树的插入操作"></a>AVL树的插入操作</h4><pre><code>//若在平衡二叉排序树中不存在和e有相同关键字的结点，则插入此结点。//taller反映T长高与否Status InsertAVL(BiTree *T,int e,Status *taller){    //创建根结点    if(!*T){        *T = (BiTree)malloc(sizeof(BiTNode));        (*T)-&gt;data = e;        (*T)-&gt;lchild = (*T)-&gt;rchild = NULL;        (*T)-&gt;bf = EH;        *taller = TRUE;    }    else{        if(e == (*T)-&gt;data){        //如果树中存在和e关键字相同的结点则插入失败            *taller = FALSE;        //没长高            return FALSE;        }        if(e &lt; (*T)-&gt;data){            //在T的左子树中搜索            if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))    return FALSE;            if(taller){                //已经插入T的左子树，且左子树长高                //检查T是否平衡                switch((*T)-&gt;bf){                    case LH:        //原本左高右低，先又增左，需要左平衡处理                        LeftBalance(T);                        *taller = FALSE;                        break;                    case EH:        //原本等高，现在左子树增高，树也要增高                        (*T)-&gt;bf = LH;                        *taller = TRUE;                        break;                    case RH:        //原本右高左低，现在等高                        (*T)-&gt;bf = EH;                        *taller = FALSE;                        break;                }            }        }        else{                        //在T的右子树中搜索            if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) return FALSE;            if(*taller){                switch((*T)-&gt;bf){                    case LH:        //原本左高右低，现在等高                        (*T)-&gt;bf = EH;                        *taller = FALSE;                        break;                    case EH:        //原本等高，现在右高，树也高                        (*T)-&gt;bf = RH;                        *taller = TRUE;                    case RH:        //原本右高，现在增右，需要右平衡处理                        RightBalance(T);                        *taller = FALSE;                        break;                }            }        }    }    return TRUE;}// 测试代码int main(){    int i;    int a[10] = {3,2,1,4,5,6,7,10,9,8};    BiTree T = NULL;    Status taller;    for(i = 0;i &lt; 10;i++){        InsertAVL(&amp;T,a[i],&amp;taller);    }    return 0;}</code></pre><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>因为AVL树上任何结点的左右子树深度之差不超过1，因此其查找的时间复杂度为$O(log_2n)$.</p><h2 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h2><p>之前介绍的查找方法用于存储在计算机内存中较小的文件，统称为内查找法。如果文件很大，且存放于外存进行查找，涉及到这样的外部存储设备，关于时间复杂度的计算会发生变化，需要考虑对硬盘等外部设备的访问时间以及访问次数，之前所谈的树，都是一个结点可以有多个孩子，但它自身只存储一个元素，在元素非常多时，树的度就会非常大，为此引入了<strong>多路查找树</strong>的概念。<br>多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><ul><li>2-3树其中每一个结点都能具有两个孩子(称为2结点)或者三个孩子(称为3结点)。</li><li>一个2结点包含一个元素和两个孩子(或无孩子)，且与二叉排序树类似 ，左子树包含的元素小于该元素，右子树包含的元素大于该元素，但结点只能有2或3个孩子，或者无孩子。</li><li>一个3结点包含一小一大两个元素和三个孩子(或无孩子)，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</li></ul><p>2-3树中所有的叶子都在同一层次，如下图所示:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/18.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h4 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h4><p>2-3树插入一个元素的过程可能会对该树的其余结点产生连锁反应。</p><ul><li>对于空树，插入一个2结点即可</li><li>插入一个结点到一个2结点的叶子上，需要将其升级为3结点即可，如下图所示，将结点”3”插入结点”1”所在位置，需要将结点”1”升级为3结点。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/19.png" srcset="/img/loading.gif" width="500px" height="100px"></li><li>往3结点中插入一个新元素，因为3结点本身是最大容量，因此需要拆分。</li></ul><p>如果要向左图插入元素”5”，它应该要插入到拥有6、7元素的3结点位置，但元素已满，无法添加，但其双亲结点是一个2结点，所以将其双亲升级为3结点，使4、6称为此结点的元素，”5”成为它的中间孩子，”7”为它的右孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/20.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>如果要插入结点和其双亲结点都为3结点，但其双亲的双亲结点”8”是个2结点，因此将9、10拆分，12、14也拆分，结点”8”升级为3结点，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/21.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>如果要插入结点和其之上所有双亲结点都是3结点，需要将1、3拆分，4、6拆分，8、12也拆分，形成如下图所示的树<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/22.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>由此可见，2-3树插入的传播效应导致了根结点的拆分，因此树的高度增加。</p><h4 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h4><ul><li>所删元素位于一个3结点的叶子结点上，只需要在该结点处删除该元素即可，不影响树的整体结构，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/23.png" srcset="/img/loading.gif" width="500px" height="100px"></li><li>所删元素位于一个2结点上，但如果删除此结点，2结点只拥有一个孩子，不满足定义，因此需要分为四种情况处理</li></ul><p>此结点的双亲也是2结点，且拥有一个3结点的右孩子，删除结点1需要左旋处理，6成为双亲，4成为6的左孩子17是6的右孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/24.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>此结点的双亲是2结点，它的右孩子也是2结点，此时删除结点1，如果直接左旋会造成没有右孩子，因此需要让结点7变成3结点，因此使元素8下来，让元素9补充8的位置，然后再用左旋的方式，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/25.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>此结点的双亲是一个3结点，如果删除此结点，不满足2-3树的特性，因此需要将结点进行拆分，使12、13合并成为左孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/26.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>如果当前树是一个满二叉树，需要将2-3树的层数减少，将8的双亲和左子树6合并为一个3结点，将14和9合并为一个3结点，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/27.png" srcset="/img/loading.gif" width="350px" height="100px"></p><ul><li>所删除的元素位于非叶子的分支结点，通常将树按中序遍历后得到此元素的前驱或后继元素，然后考虑让它们补位。</li></ul><p>如果要删除的分支结点4是2结点，它的前驱是1后继是6，由于6、7是3结点，所以需要用6来补位，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/28.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>如果要删除的分支结点是3结点的某个元素，需要将3结点的左孩子10上升到删除位置合适，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/29.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>2-3树的删除是有规律的，其他情况不一一解释。</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是2-3树的一个扩展，多了一个4结点的使用，一个4结点包含小中大三个元素和4个孩子(或无孩子)，一个4结点要么无孩子，要么具有4个孩子。<br>4结点的左子树包含小于最小元素的元素，第二子树包含大于最小元素小于第二元素的元素，第三子树包含大于第二元素小于最大元素的元素，右子树包含大于最大元素的元素。<br>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/30.png" srcset="/img/loading.gif" width="500px" height="200px"></p><p>2-3-4树的删除过程，删除顺序是1、6、3、4、5、2、9<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/31.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树(B-tree)是一种平衡的多路查找树，2-3树与2-3-4树都是B树的特例，结点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树。</p><h4 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B-树的定义"></a>B-树的定义</h4><p>一棵m阶的B-树，或为空树，或为满足下列性质的m叉树:</p><ul><li>若根结点不是叶子结点，则至少有两棵子树</li><li>一个非根的分支结点都有k-1个元素和k个孩子，其中$[m/2]\leq k\leq m$，每个叶子结点n都有k-1个元素，其中$[m/2]\leq k\leq m$.</li><li>所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点(失败结点不存在，指向其指针为空，引入失败结点便于分析B-树的查找性能)</li><li>所有分支结点包含下列信息<script type="math/tex">(n,A_0,K_1,A_1,K_2,A_2...K_n,A_n)</script>，其中<script type="math/tex">K_i(i=1,2,...,n)</script>为关键字，且<script type="math/tex">K_i<K_{i+1}</script>，<script type="math/tex">A_i(i=0,1,2,..,n)</script>为指向子树根结点的指针，且指针$A_{i-1}$所指子树中所有结点的关键字均小于<script type="math/tex">K_i(i=1,2,...,n)</script>，$A_n$所指子树中所有结点的关键字均大于$K_n$，<script type="math/tex">n([m/2]-1\leq n\leq m-1)</script>为关键字的个数(或n+1为子树的个数)。</li></ul><p>下图为一个4阶的B-树<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/32.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B-树的查找"></a>B-树的查找</h4><p>在一个典型的B-树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B-树进行调整，使得B-树的阶数(或结点的元素)与硬盘存储的页面大小相匹配。<br>例如一棵B-树的阶为1001(即1个结点包含1000个关键字)，高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。<br>最坏情况下，对于n个关键字的m阶B树，第一层至少有1个结点，由于除根结点外每个分支结点至少有$[m/2]$棵子树，则第三层至少有$2\times [m/2]$个结点，第k+1层至少有<script type="math/tex">2\times ([m/2])^{k-1}</script>个结点，也就是叶子结点，若m阶B-树有n个关键字，因此<script type="math/tex">n+1\geq 2\times [m/2]</script>,即在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过<script type="math/tex">k\leq log_{m/2}\{(n+1)/2\}+1</script></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>对于树结构来说，可以用中序遍历来顺序查找树中的元素，但在B树结构中，往返于每个结点之间，也就是在硬盘的页面之间进行多次访问，如下图所示，假设每个结点都属于不同的页面，中序遍历所有元素时需要重复访问页面1，为了让遍历时每个元素只访问一次，所以在原有的B树结构基础上，加了新的元素组织方式，称为B+树。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/33.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>B+树是一种B-树的变形树,更适用于文件索引系统，但它以及不算是定义的树了，如下图所示，灰色关键字即是根结点中的关键字在叶子结点再次列出，所有叶子结点都链接在一起。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/34.png" srcset="/img/loading.gif" width="500px" height="150px"></p><h4 id="B-树与B-树的差异"><a href="#B-树与B-树的差异" class="headerlink" title="B+树与B-树的差异"></a>B+树与B-树的差异</h4><ul><li>有n棵子树的结点中包含n个关键字</li><li>所有叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li><li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。</li></ul><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><p>如果要随机查找，从根结点出发与B-树查找方式相同，但即使在分支结点找到了待查的关键字，也是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。<br>如果从最小关键字进行从小到大顺序查找，可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子的指针即可遍历所有关键字。<br>B+树不仅能有效查找单个关键字，而且更适合查找某个范围内的所有关键字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的应用</title>
    <link href="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="带权最小生成树"><a href="#带权最小生成树" class="headerlink" title="带权最小生成树"></a>带权最小生成树</h1><p>如果要在n个城市之间建立通信网络，n个城市之间最多有n(n-1)/2条道路，如何选择线路连通所有的城市，并且为了节省成本，要使连通的线路距离最短，假设有如下城市：<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/1.png" srcset="/img/loading.gif" width="250px" height="200px"></p><p>图中有9个城市{$v_0$,$v_1$,$v_2$…$v_8$}，图中各顶点之间的连线为此地的所有铺设的道路，现在要从这些道路中选择距离最短的线路，以便可以连通所有的城市，那么有如下三种选择。<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/2.png" srcset="/img/loading.gif" width="580px" height="220px"></p><p>这三种线路的距离各不一样，而方案三要比方案一的线路节省62公里的线路成本，如何选择一个最优的线路，也就是我们需要解决的问题。<br>对于n个顶点的连通网可以建立许多不同的生成树，每棵生成树都可以是一个通信网，最合理的通信网应该是代价之和最小的生成树，在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的<strong>最小生成树</strong>。<br>对于寻找连通图的最小生成树，一般有两种算法，普里姆算法和克鲁斯卡尔算法。</p><h2 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h2><h3 id="普里姆算法的构造过程"><a href="#普里姆算法的构造过程" class="headerlink" title="普里姆算法的构造过程"></a>普里姆算法的构造过程</h3><p>假设N=(V，E)是连通图，TE是N上最小生成树中边的集合。</p><ol><li>U={$u_0$}($u_0\in V$),TE={ }.</li><li>在所有$u\in U$,$v\in V-U$的边$(u,v)\in E$中找到一条权值最小的边$(u_0,v_0)$并入集合TE，同时$v_0$并入U。</li><li>重复过程二，直至U=V为止，此时TE中必有n-1条边，则T=(V,TE)为N的最小生成树。</li></ol><h3 id="普里姆算法举例"><a href="#普里姆算法举例" class="headerlink" title="普里姆算法举例"></a>普里姆算法举例</h3><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/3.png" srcset="/img/loading.gif" width="180px" height="180px"></p><p>如上图所示，例如从A点出发，A-B权值为2，A-C权值为4，A-D权值为2，选择最小的边则选择A-B，将A-B看作一个整体，选择A-D、A-C、B-C中权值最小的边A-D。<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/4.png" srcset="/img/loading.gif" width="180px" height="180px"></p><p>然后将A-B-D看作一个整体，继续选择A-C、B-C、D-C当中最小的边，直至所有顶点全部选完，这就是普里姆算法的大致思路，此图中有两个最小生成树，如下图所示<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/5.png" srcset="/img/loading.gif" width="380px" height="180px"></p><h3 id="普里姆算法的实现"><a href="#普里姆算法的实现" class="headerlink" title="普里姆算法的实现"></a>普里姆算法的实现</h3><p>假设无向图G以邻接矩阵存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边，为了实现此算法需要附设一个辅助数组closedge，用于记录U到V-U具有最小权值的边，每个顶点$v_i\in V-U$，在辅助数组中存在一个相应分量closedge[i-1]，它包括两个域，lowcost与adjvex，lowcost存储最小边上的权值，adjvex存储最小边在U中的顶点。</p><p>closedge数组结构如下</p><pre><code>struct{    VerTexType adjvex;        //最小边在U中的那个顶点    ArcType lowcost;        //最小边的权值}closedge[MVNum];</code></pre><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>首先将初始顶点u加入U中，对其余的每一个顶点$v_j$，将closedge[j]均初始化为到u的边信息。</li><li>循环n-1次，进行以下操作<ol><li>从各组边closedge中选出最小边closedge[k]，输出此边</li><li>将k加入U中</li><li>更新剩余的每组最小边信息closedge[j],对于V-U中的各边，新增加了一条从k到j的边，如果新边的权值比closedge[j].lowcost小，则将closedge[j].lowcost更新为新边的权值。</li></ol></li></ol><p>算法代码如下</p><pre><code>void MiniSpanTree_Prim(AMGraph G,VerTexType u){    k = LocateVex(G,u);                //k保存顶点u的下标    for(j=0;j&lt;G.vexnum;j++){        if(j!=k){                    //遍历除顶点u外所有顶点            closedge[j] = {u,G.arcs[k][j]};            /* 相当于                closedge[j].adjvex = u;                //初始化为起始点                closedge[j].lowcost = G.arcs[k][j]    //初始化为起始点到其余各顶点的权值            */        }        closedge[k].lowcost = 0;        //顶点u到自身的权值为0        for(i=1;i&lt;G.vexnum;i++){            k = Min(closedge);                //选出最小的边            u0 = closedge[k].adjvex;        //最小边的一个顶点            v0 = G.vexs[k];                    //最小边的另一个顶点            cout &lt;&lt; u0 &lt;&lt; v0;                //输出该边            closedge[k].lowcost = 0;        //并入U集            for(j=0;j&lt;G.vexnum;j++){        //重新选择最小边                if(G.arcs[k][j]&lt;closedge[j].lowcost){                    closedge[j] = {G.vexs[k],G.arcs[k][j]}                }            }        }    }}</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>假设网中有n个顶点，初始化closedge的循环频度为n，第二个循环频度为n-1，第二个循环内有两个循环其一是在closedge[v].lowcost中求最小值，频度为n-1，其二是重新选择最小权值的边频度为n，所以该算法时间复杂度为$O(n^2)$，此算法适合求稠密网的最小生成树。</p><h2 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h2><p>普里姆算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树，而克鲁斯卡尔算法是以边为目标去构建的，因此需要使用图的存储结构中的<strong>边集数组</strong>结构，边集数组结构定义代码如下：</p><pre><code>typedef struct{    int begin;        //边的起点    int end;        //边的终点    int weight;        //边上的权值}Edge;</code></pre><h3 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h3><p>克鲁斯卡尔算法的具体思路是： 将所有边按照权值从小到大排序，然后判断这个边会不会与之前选择的边组成回路。如果不会，就可以作为最小生成树的一部分，反之，舍去。<br>判断是否产生回路的方法为： 在初始状态每个顶点给不同的标记，遍历过程的每条边都有两个顶点，判断这两个顶点是否相等，如果相等说明他们处于一棵树中，如果继续连接就会产生回路。</p><p>假设连通网N=(V,E)，将N中的边按权值从小到大的顺序排列。</p><ol><li>初始状态为只有n个顶点而无边的非连通图T={V，{ }}，图中每个顶点自成一个连通分量。</li><li>在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上(即不构成回路)，则将此边加入到T中，否则舍去此边而选择下一条权值最小的边。</li><li>重复过程二，直至T中所有顶点都在同一连通分量上为止。</li></ol><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>将数组Edge中的元素按权值从小到大排序</li><li>依次查看数组Edge中的边，循环执行以下操作<ol><li>依次从排序好的数组Edge中选出一条边($U_1$,$U_2$).</li><li>在辅助数组parent中分别查找$v_1$和$v_2$所在的连通分量$vs_1$和$vs_2$，进行判断：<ol><li>如果两者不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并两个连通分量。</li><li>如果两者相等，表明所选的两个顶点属于同一连通分量，舍去此边而选择下一条权值最小的边。</li></ol></li></ol></li></ol><h3 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h3><p>例如下图所示的网，初始状态下赋予各个顶点不同颜色的标记，对所有边的权值升序排序并进行判断。<br>首先是<strong>(1,3)</strong>边，由于顶点1和3标记不同，所以可以构成生成树的一部分，然后遍历所有的顶点，将与顶点3标记相同的顶点全部改为顶点1的标记.<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/6.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>同理<strong>(4,6)</strong>边与<strong>(2,5)</strong>边也同样可以构成生成树的一部分，连接后更新相应顶点的标记，如下图：<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/7.png" srcset="/img/loading.gif" width="220px" height="180px"></p><p>然后最小为<strong>(3,6)</strong>边，两者标记不同，可以连接，遍历所有顶点，将与顶点6标记相同的所有顶点标记更改为顶点1的标记，如下图所示<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/8.png" srcset="/img/loading.gif" width="220px" height="180px"></p><p>继续选择权值最小的边，此时权值为5的边有三个，其中<strong>(1,4)</strong>和<strong>(3,4)</strong>各自两顶点的标记相同，如果连接连接会产生回路，所以舍去。由于<strong>(2,3)</strong>标记不同，可以连接，将顶点2标记相同的所有顶点的标记改为与顶点3相同的标记，当选取的边的数量比顶点数量小1，说明最小生成树生成。<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/9.png" srcset="/img/loading.gif" width="220px" height="180px"></p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>int Find(int *parent,int f){        //查找连线顶点的尾部下标    while(parent[f]&gt;0){        f = parent[f];    }    return f;}void MiniSpanTree_Kruskal(MGraph G){    int i ,n, m;    Edge edges[MAXEDGE];            //边集数组    int parent[MAXVEX];                //辅助数组用来判断边与边是否形成环路    Sort(edges);                    //对边集数组升序排序    for(i = 0;i&lt;G.numVertexes;i++){        parent[i] = 0;    }    for(i=0;i&lt;G.numEdges;i++){        n = Find(parent,edges[i].begin);        m = Find(parent,edges[i].end);        if(n != m){            parent[n] = m;        //将此边的结尾顶点放入下标为起点的parent中            cout &lt;&lt; edges[i].begin &lt;&lt; edges[i].end &lt;&lt; edges[i].weight &lt;&lt; endl;        }    }}</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>如果对存放在网中的边进行堆排序，对于包含e条边的网，上述算法排序时间为$O(elog_2e)$,由此克鲁斯算法的时间复杂度为$O(elog_2e)$，此算法更适合求稀疏网的最小生成树。</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/10.5.png" srcset="/img/loading.gif" width="400px" height="280px"></p><p>我们在出门旅行时经常会面临选择路线的决策问题，比如从一个城市到另一个城市如何选择线路，或者在城市中从A点到B点如何乘坐交通工具能够最快到达目的地，我们所讨论的最短路径主要分为两种：</p><ul><li>对于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径，只需要从顶点对图做广度优先搜索到终点停止，所得的广度优先生成树上，从根顶点到目的地的路径就是最短路径。</li><li>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</li><li>两种常见的最短路径问题: 求从某个源点到其余各顶点的最短路径、求每一对顶点之间的最短路径</li></ul><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>本文讨论单源点的最短路径问题： 给定带权有向图G和源点$v_0$，求从$v_0$到G中其余各顶点的最短路径。<br>迪杰斯特拉算法是一个按路径长度递增的次序产生最短路径的算法。</p><h3 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h3><p>对于网N=(V,E)，将N中的顶点分成两组</p><ol><li>S: 已求出的最短路径的终点集合(初始时只包含源点$v_0$)</li><li>V-S: 尚未求出的最短路径的顶点集合(初始时为V-{$v_0$})</li></ol><p>算法将按各顶点与$v_0$间最短路径长度递增的次序，逐个将集合V-S中的顶点加入到集合S中，在这个过程中，总保持从$v_0$到集合S中各顶点的路径长度始终不大于到集合V-S中各顶点的路径长度。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>假设用带权邻接矩阵arc来表示带权有向网G，G.arcs[i][j]表示弧<v_i ,v_j>上的权值，如果不存在，则用一个非常大的数字代表正无穷，算法的实现需要引入以下辅助数据结构：</v_i></p><ol><li>一维数组<strong>S[i]</strong>: 记录从源点$v_0$到终点$v_1$是否已被确定最短路径长度，true表示确定，false表示不确定。</li><li>一维数组<strong>Path[i]</strong>: 记录从源点$v_0$到终点$v_i$的当前最短路径上$v_i$的直接前驱顶点序号，初值为： 如果从$v_0$到$v_1$有弧，则Path[i]为$v_0$，否则为-1.</li><li>一维数组<strong>D[i]</strong>: 记录从源点$v_0$到终点$v_1$的当前最短路径长度，初值为: 如果从$v_0$到$v_i$有弧，则D[i]为弧上的权值，否则为无穷大。</li></ol><p>长度最短的一条最短路径必为($v_0$,$v_k$)，满足<script type="math/tex">D[k]=Min\{D[i] | v_i\in V-S\}</script><br>求得顶点$v_k$的最短路径后，将其加入第一组顶点集S中，每当加入新顶点到S，对第二组而言，多了一个<br>中转顶点，从而多了中转路径，所以要对第二组剩余的各个顶点的最短路径长度进行更新。<br>原来$v_0$到$v_i$的最短路径长度为D[i]，加入$v_k$之后，以$v_k$作为中间顶点的中转路径长度为: $D[k]+G.arcs[k][i]$，若$D[k]+G.arcs[k][i]&lt;D[i]$，则用$D[k]+G.arc[k][i]$取代D[i].<br>更新后，在选择数组D中最小的顶点加入顶点集S中，然后重复上述过程，直至图中所有顶点都加入S中为止。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化<ol><li>将源点$v_0$加入S中，即$S[v_0]=true$.</li><li>将$v_0$到各个终点的最短路径长度初始化为权值，即<script type="math/tex">D[i]=G.arcs[v_0][v_i]</script>.</li><li>如果$v_0$和顶点$v_i$之间有弧，则将$v_i$的前驱置为$v_0$，即$Path[i]=v_0$，否则Path[i]=-1.</li></ol></li><li>循环n-1次，执行以下操作<ol><li>选择下一条最短路径的终点$v_k$，使得<script type="math/tex">D[k]=Min\{D[i] | v_i\in V-S\}</script></li><li>将$v_k$加入S中，即$S[v_k]=true$.</li><li>根据条件更新从$v_0$出发到集合V-S上任一顶点的最短路径的长度，若条件<script type="math/tex">D[k]+G.arcs[k][i]<D[i]</script>，同时更改$v_i$的前驱为$v_k$，$Path[i]=k$。</li></ol></li></ol><h3 id="算法举例-1"><a href="#算法举例-1" class="headerlink" title="算法举例"></a>算法举例</h3><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/10.png" srcset="/img/loading.gif" width="550px" height="240px"></p><p>用上图进行举例，首先选取源点D并入S集中，然后更新从源点D到其余各顶点的距离，用U数组进行存储，然后在U中选取最小权值的顶点(C)并入S集中，此时S集有D、C两个顶点，继续更新D到其余各顶点的距离，此时S集中有C顶点可以作为中转点，所以D到B的距离可以更新为13，D-C-E的距离比D-E的距离长，所以E的权值不变，F的距离根据C顶点中转，可以算出为3+6=9.</p><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/11.png" srcset="/img/loading.gif" width="550px" height="240px"><br>第三步在S集中继续选取最小权值的顶点(E)并入S集中，然后E作为中转点，更新U中其余顶点到源点的距离，第四步依然是在S集中选取最小权值的顶点(F)并入S集中，U中更新其余顶点到源点的距离。</p><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/12.png" srcset="/img/loading.gif" width="550px" height="240px"><br>第五步和第六步与以上步骤同理，从U中选取权值最小的顶点并入S集，然后将此顶点作为中转点，更新源点到其余顶点的距离。</p><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/13.png" srcset="/img/loading.gif" width="550px" height="160px"><br>通过以上步骤，U集中的顶点已经全部并入S集，此时源点到其余各顶点的最短路径已经计算完毕。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><pre><code>void ShortesPath_DIJ(AMGraph G,int v0){    n = G.vexnum;    for(v=0;v&lt;n;++v){            //对n个顶点初始化        S[v]=false;        D[v]=G.arcs[v0][v];        //记录v0到v的最短路径长度        if(D[v]&lt;MaxInt){        //MaxInt表示正无穷，如果有弧更新Path为v0,否则置为-1            Path[v]=v0;        }        else{            Path[v]=-1;        }    }    S[v0]=true;        //将v0加入S    D[v0]=0;        //源点到源点的距离为0    //遍历其余顶点，每次求得v0到某个顶点v的最短路径，将v并入S    for(i=1;i&lt;n;++i){        min=MaxInt;            //初始化最短路径为无穷大        /*遍历所有结点，如果顶点v0到vw没有确认为最短路径，        并且v0到vw的路径比当前最短路径小，则更新最短路径。*/        for(w=0;w&lt;n;++w){            if(!S[w] &amp;&amp; D[w]&lt;min){                v=w;            //保存顶点位置                min=D[w];            }        }        S[v]=true;                //设置顶点v0到v为确定的最短路径        /*更新从v0出发到集合V-S上所有顶点的最短路径长度*/        for(w=0;w&lt;n;++w){            /*如果没有确认到vw的最短路径，            并且v0到v的最短路径加从v到w的路径之和，            小于当前从v到w的最短路径, 则对其更新*/            if(!S[w] &amp;&amp; (D[v]+G.arcs[v][w]&lt;D[w])){                D[w]=D[v]+G.arcs[v][w];                Path[w]=v;        //更改w的前驱为v            }        }    }}</code></pre><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>主循环一共进行n-1次，每次执行时间为O(n)，所以算法时间复杂度为$O(n^2)$。<br>人们可能只希望找到从源点到某个终点的最短路径，但这个问题和求源点到其他所有顶点的最短路径一样复杂，所以使用迪杰斯特拉算法解决，时间复杂度依然为$O(n^2)$。</p><h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><p>迪杰斯特拉算法是解决单源点到其余顶点最短路径的问题，如果是求每一对顶点之间的最短路径，用迪杰斯特拉算法就需要将每个顶点都作为源点，然后共同调用n次算法，相当于在外层又套了一层循环，这种方式时间复杂度变为$O(n^3)$。<br>另一种求最短路径的算法是弗洛伊德算法，弗洛伊德算法的时间复杂度依然为$O(n^3)$,但其算法非常简洁优雅，此算法仍然使用带权的邻接矩阵arcs来表示有向网G，求从顶点$v_i$到$v_j$的最短路径.</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>算法实现需要引入以下数组:</p><ul><li>二维数组Path[i][j]: 最短路径上顶点$v_j$的前一顶点的序号。</li><li>二维数组D[i][j]: 记录顶点$v_i$和$v_j$之间的最短路径长度。</li></ul><h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>将$v_i$到$v_j$的最短路径长度初始化，即D[i][j]=G.arcs[i][j]，然后进行n次比较更新。</p><ol><li>在$v_i$和$v_j$间加入中转顶点$v_0$，比较($v_i$,$v_0$,$v_j$)和($v_i$,$v_j$)的路径长度，也就是判断G.arcs[i][0]+G.arcs[0][j]是否比G.arcs[i][j]的路径更短，取最短的作为$v_i$到$v_j$的最短路径，同时更新Path数组对应的值。</li><li>循环将$v_1$,$v_2$…$v_n$都作为中转点，更新$v_i$到$v_j$的最短路径，经过n次比较后，就可以得到任意两顶点之间的最短路径。</li></ol><h3 id="算法举例-2"><a href="#算法举例-2" class="headerlink" title="算法举例"></a>算法举例</h3><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/14.png" srcset="/img/loading.gif" width="500px" height="250px"></p><p>我们先用三个顶点的无向图举例，D0表示初始的邻接表，P0记录最短路径上顶点$v_j$前一个顶点的序号。<br>我们发现如果用$v_1$作为中转点，那么$(v_0,v_1)+(v_1,v_2)=4$，比$(v_0,v_2)=5$更小，所以需要更新D矩阵的对应值为最短路径的长度，所以更新D[0][2]=4，由于此图是无向图，因此D[2][0]=4，由此得到D1所对应的矩阵，D矩阵改变，P矩阵也需要改变，由于现在$v_0$到$v_2$的最短路径经过$v_1$，因此P[0][2]需要存储$v_1$的序号1，表明$v_2$结点的前一顶点是$v_1$。</p><p>接下来如果我们用下面一个较为复杂的图来进行说明，首先还是对D、P矩阵进行初始化。<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/15.png" srcset="/img/loading.gif" width="600px" height="200px"></p><p>我们依然首先以v0作为中转点，发现只有v1与v2是以v0作为中转点的，所以D、P矩阵的值不变，接下来我们使用v1作为中转点，v3、v4、v2都可以以v1作为中转点，然后更新D、P矩阵的对应数据，我们更新以v1作为中间结点的数据代码如下：</p><pre><code>for(int i=0; i&lt;n; i++)          //n为图中顶点的数量    for(int j=0; j&lt;n; j++)          if(D[i][1]+D[1][j]&lt;D[i][j])              D[i][j]=D[i][1]+D[1][j];</code></pre><p>那么如果我们需要更新以$v_i$(i=1,2,3…n)顶点为中间顶点的对应D矩阵的数据，只需要将循环中的1改为i即可，因此需要在外层在进行循环i，可以得到以下代码：</p><pre><code>for(int k=1; k&lt;=n; k++)      for(int i=1; i&lt;=n; i++)          for(int j=1; j&lt;=n; j++)              if(D[i][k]+D[k][j]&lt;D[i][j]){                D[i][j]=D[i][k]+D[k][j];                Path[i][j]=Path[k][j];    //在循环的过程中顺便更新P矩阵的值            }</code></pre><p>经过9次循环可以得到现在的D、P矩阵:<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/16.png" srcset="/img/loading.gif" width="550px" height="250px"></p><p>从上图的D矩阵可以看出$(v_0,v_8)$的最短路径为16，从P矩阵可以看出从$(v_0,v_8)$需要经过$v_1$中转，然后又从$(v_1,v_8)$看出需要经过$v_2$，从$(v_2,v_8)$需要经过$v_4$，$(v4,v8)$需要经过$v_3$，$(v_3,v_8)$需要经过$v_6$，从$(v_6,v_8)$需要经过$v_7$，然后从$v_7$可以直接到$v_8$，那么$v_0$到$v_8$的最短路径就是$v_0-v_1-v_2-v_4-v_3-v_6-v_7-v_8$，然后我们手动计算此路径长度为1+3+1+2+3+7=16，和D矩阵相应的值一样，这就是弗洛伊德算法的过程。</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>void ShortestPath_Floyd(AMGraph G){    for(i=0;i&lt;G.vexnum;i++){                //初始化矩阵        for(j=0;j&lt;G.vexnum;j++){            D[i][j]=G.arcs[i][j];            if(D[i][j]&lt;MaxInt &amp;&amp; i!=j){        //如果i与j之间有弧，则将j的前驱置为i，否则置为-1                Path[i][j]=i;            }            else{                Path[i][j]=-1;            }        }    }    //计算任意两顶点之间最短距离    for(k=0;k&lt;G.vexnum;k++){        for(i=0;i&lt;G.vexnum;i++){            for(j=0;j&lt;G.vexnum;j++){                if(D[i][k]+D[k][i]&lt;D[i][j]){                    D[i][j]=D[i][k]+D[k][j];        //更新D[i][j]                    Path[i][j]=Path[k][j];            //更改j的前驱为k                }            }        }    }}</code></pre><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>一个无环的有向图称作<strong>有向无环网(Directed Acyline Graph)</strong>，简称<strong>DAG图</strong>。<br>有向无环网是描述工程进行过程的有效工具，一个工程可以被分为若干个称为活动的子工程，子工程之间有约束关系，比如前一个工程完成后才能进行下一个工程，如下图所示：</p><p><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/17.png" srcset="/img/loading.gif" width="550px" height="300px"><br>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV网(Activity On Vertex Network)</strong>。</p><p>在AOV网中，若从顶点$v_i$到顶点$v_j$有一条有向路径，则$v_i$是$v_j$的前驱，$v_j$是$v_i$的后继，若<script type="math/tex"><v_i,v_j></script>是网中的一条弧，则$v_i$是$v_j$的直接前驱，$v_j$是$v_i$的直接后继。</p><p>在AOV网中不应该出现有向环 ，因为存在环意味着某项活动应以自己为先决条件，这是矛盾的，对于给定的AOV网应该先判断网中是否存在环，检测的方法就是对AOV网进行拓扑排序，若网中所有的顶点都在它的拓扑有序序列中，则该AOV网中必定不存在环。<br>拓扑排序就是将AOV网中所有顶点排成一个线性序列，该序列满足: 若在AOV网中由$v_i$到$v_j$有一条路径，则在该线性序列中的顶点$v_i$必定在$v_j$之前.这样的拓扑序列不止一条，例如上面的工程图有如下两个拓扑有序序列：</p><script type="math/tex;mode=display">V_0，V_1，V_2，V_3，V_4，V_5，V_6，V_7，V_8，V_9，V_{10}，V_{11}，V_{12}，V_{13}，V_{14}，V_{15}，V_{16}</script><script type="math/tex;mode=display">V_0，V_1，V_4，V_3，V_2，V_7，V_6，V_5，V_8，V_{10}，V_9，V_{12}，V_{11}，V_{14}，V_{13}，V_{15}，V_{16}</script><blockquote><p>拓扑序列只要保证前一个结点一定是指向后一个结点，而不指向之前的结点就好。</p></blockquote><p>构造拓扑序列时有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环的AOV网，如果输出顶点数少了，就说明这个网存在环，不是AOV网。</p><h2 id="拓扑排序的过程"><a href="#拓扑排序的过程" class="headerlink" title="拓扑排序的过程"></a>拓扑排序的过程</h2><ol><li>在有向图中选一个无前驱的顶点且输出它。</li><li>从图中删除该顶点和所有以它为尾的弧。</li><li>重复步骤1与步骤2，直至不存在无前驱的顶点。</li><li>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点为拓扑序列。</li></ol><p>已之前的流程图为例，可以构造出以下的AOV网：<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/18.png" srcset="/img/loading.gif" width="380px" height="230px"></p><h2 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h2><p>进行拓扑排序的过程需要删除顶点，所以使用邻接表会更加方便，因此需要为AOV网建立一个邻接表，考虑到算法过程需要查找入度为0的顶点，所以需要在原顶点表结构中，加入一个入度域in，结构代码如下所示：</p><pre><code>typedef struct EdgeNode{        //边表结点    int adjvex;                    //邻接点域，存储该顶点对应的下标    int weight;                    //存储权值    struct EdgeNode *next;        //指向下一个邻接点}EdgeNode;typedef struct VertexNode{        //顶点表结点    int in;                        //入度域    int data;                    //顶点域    EdgeNode *firstedge;        //边表头指针}VertexNode,AdjList[MAXVEX];typedef struct{    AdjList adjList;    int numVertexes,numEdges;    //图中顶点数和边数}graphAdjList,*GraphAdjList;</code></pre><p>在算法中，还需要用栈来处理入度为0的顶点，目的是为了避免每个查找时都要遍历顶点表找有没有入度为0的顶点。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在删除顶点和以它为尾的弧的操作，可以不必真正对图的存储结构进行改变，可用弧头顶点的入度-1的方式来实现。</p><pre><code>Status TopologicalSort(GraphAdjList GL){    EdgeNode *e;    int i,k,gettop;    int top = 0;        //栈指针下标    int count = 0;        //输出顶点的个数    int *stack;            //存入度为0的顶点    stack = (int*)malloc(GL-&gt;numVertexes*sizeof(int));    //遍历所有顶点将入度为0的顶点入栈    for(i=0;i-&gt;GL-&gt;numVertexes;i++){        if(GL-&gt;adjList[i].in==0){            stack[++top]=i;        }    }    while(top!=0){        gettop=stack[top--];    //出栈        cout &lt;&lt; GL-&gt;adjList[gettop].data;        count++;                //统计输出顶点数        //遍历此顶点的弧表        for(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next){            k=e-&gt;adjvex;            if(!(--GL-&gt;adjList[k].in)){    //将k号顶点邻接点的入度-1                stack[++top]=k;            //如果为入度为0则入栈            }        }    }    if(count &lt; GL-&gt;numVertexes) return ERRPR;    //如果输出顶点数小于总顶点则说明有环    else return OK;}</code></pre><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>对于有n个顶点和e条边的有向图而言，建立求各顶点入度的时间复杂度为$O(e)$,建立零入度顶点栈的时间复杂度为$O(n)$，所以总的时间复杂度为$O(n+e)$.</p><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>在AOV网中，我们用顶点表示活动，用弧来表示活动间的优先关系，AOE(Activity On Edge)网与AOV网不同，AOE网用顶点表示事件，用弧来表示活动，权表示活动持续的时间，通常AOE网可用来估算工程的完成时间。<br>在一个工程计划中，通常需要判断哪些活动是影响工程进度的关键，由于现在大多数工程采用流水线管理，对于没有先后关系的子工程可以在同一时间进行，那么进行时间最长的子工程将决定下一个子工程的开始时间，因此将其称为关键活动，关键活动的延期会导致整个项目的延期。<br>由于整个工程只有一个开始点和一个完成点，正常情况下，网中只有一个入度为零的点，称为源点，也只有一个出度为零的点，称为汇点，如下图所示:<br><img src="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/19.png" srcset="/img/loading.gif" width="450px" height="150px"></p><p>$v_0$即为源点，表示工程的开始，$v_9$是汇点，表示工程的结束，顶点<script type="math/tex">v_0,v_1,v_2,...,v_9</script>分别表示事件，弧<script type="math/tex"><v0,v1>,<v0,v2>...<vi,vj></script>都表示一个活动，用<script type="math/tex">a_0，a_1，...，a_i</script>表示，它们的值表示活动持续的时间。<br>在AOE网中，一条路径各弧上的权值之和称为该路径的带权路径长度，要估算整个项目的完成时间，就要找一条从源点到汇点的带权路径长度最长的路径，称为关键路径，关键路径上的活动称为关键活动。</p><h2 id="关键路径的确定"><a href="#关键路径的确定" class="headerlink" title="关键路径的确定"></a>关键路径的确定</h2><p>为了确定关键路径，需要定义四个描述量:</p><ol><li>事件的最早发生时间etv(earliest time of vertex): 即顶点$v_k$的最早发送时间</li><li>事件的最迟发生时间ltv(latest time of vertex): 即顶点$v_k$的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li><li>活动的最早开始时间ete(earliest time of edge): 即弧$a_k$的最早发生时间。</li><li>活动的最晚开始时间lte(latest time of edge): 即弧$a_k$的最晚发生时间，也就是不推迟工期的最晚开工时间。</li></ol><p>由1、2可以求得3、4，然后再根据ete[k]是否与lte[k]相等来判断$a_k$是否是关键活动。</p><h2 id="关键路径求解过程"><a href="#关键路径求解过程" class="headerlink" title="关键路径求解过程"></a>关键路径求解过程</h2><ol><li>对图中顶点进行排序，在排序过程中按拓扑序列求出每个事件的最早发生时间etv。</li><li>按逆拓扑序列求出每个事件的最迟发生时间ltv。</li><li>求出每个活动的最早开始时间ete。</li><li>求出每个活动的最晚开始时间lte。</li><li>找出ete与lte相等的活动，即为关键活动，由关键活动形成的由源点到汇点的每一条路径就是关键路径。</li></ol><h2 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>调用拓扑排序算法，保存拓扑序列到stack2</li><li>初始化每个事件的最早发生时间为0</li><li>根据stack2保存的拓扑序列，按从前向后的拓扑次序，依次求每个事件的最早发生时间，循环执行以下操作<ol><li>取得拓扑序列中的顶点序号k</li><li>用指针p依次指向k的每一个邻接顶点，取得每个邻接顶点的序号j=p-&gt;adjvex，依次更新顶点j的最早发生时间</li></ol></li><li>将每个事件的最迟发生时间初始化为汇点的最早发生时间</li><li>根据stack2的值按从后向前的逆拓扑次序，依次求每个事件的最迟发生时间，循环执行以下操作<ol><li>取得拓扑序列中顶点序号k</li><li>用指针p依次指向k的每一个邻接顶点，取得每个邻接顶点的序号j=p-&gt;adjvex,依次根据k的邻接点，更新k的最迟发生时间</li></ol></li><li>判断某一活动是否为关键活动，循环n次，执行以下操作<ol><li>对每个顶点i，用指针p依次指向i的每个邻接顶点，取得每个邻接顶点的序号j=p-&gt;adjvex，分别计算活动<vi ,vj>的最早和最晚开始时间，如果两者相等，说明活动为关键活动，输出此弧。</vi></li></ol></li></ol><h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><p>求事件的最早发生时间etv的过程，就是从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要调用一次拓扑序列算法来计算etv和拓扑序列列表。</p><pre><code>int *etv,*ltv;int *stack2;        //stack2用来存储拓扑序列，以便后面求关键路径时使用。int top2;            //用于stack2的指针Status TopologicalSort(GraphAdjList GL){    EdgeNode *e;    int i,k,gettop;    int top=0;        //用于栈指针下标    int count=0;    //用于统计输出顶点的个数    int *stack;        //建栈将入度为0的顶点入栈    stack=(int*)malloc(GL-&gt;numVertexes*sizeof(int));    //将所有入度为0的顶点入栈    for(i=0; i&lt;Gl-&gt;numVertexes; i++){        if(0==GL-&gt;adjList[i].in)            stack[++top]=i;    }    //事件最早发生事件全部初始化为0    etv = (int*)malloc(GL-&gt;numVertexes*sizeof(int));    //事件最早发生时间    for(i=0;i&lt;GL-&gt;numVertexes;i++){        etv[i]=0;    }    top2=0;    stack2 = (int*)malloc(GL-&gt;numVertexes*sizeof(int));    while(top !=0 ){        gettop = stack[top--];        count++;        stack2[++top2]=gettop;        //这里原先是输出顶点序号，现在改为压入stack2        for(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next){            k=e-&gt;adjvex;            if(!(--GL-&gt;adjList[k].in)){                stack[++top]=k;            }            //求etv数组的每一个元素的值            if((etv[gettop] + e-&gt;weight) &gt; etv[k]){                etv[k]=etv[gettop]+e-&gt;weight;            }        }    }    if(count &lt; GL-&gt;numVertexes) return ERROR;    else return OK;}void CriticalPath(GraphAdjList GL){    EdgeNode *e;    int i,gettop,k,j;    int ete,lte;            //声明活动最早发生时间和最迟发生时间变量     TopologicalSort(GL);    //求拓扑序列，计算数组etv与stack2的值    //初始化ltv(事件最晚发生时间)    ltv = (int*)malloc(GL-&gt;numVertexes*sizeof(int));    for(i=0;i&lt;GL-&gt;numVertexes;i++){        ltv[i]=etv[Gl-&gt;numVertexes-1];    }    //计算ltv    while(top2 ！=0){        gettop = stack2[top2--];        for(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next){            k=e-&gt;adjvex;            if(ltv[k]-e-&gt;weight &lt; ltv[geettop]){                ltv[gettop] = ltv[k]-e-&gt;weight;            }        }    }    //求ete，lte和关键活动    for(j=0; j&lt;GL-&gt;numVertexes; j++){        for(e = GL-&gt;adjList[j].firstedge; e; e=e-&gt;next){            k=e-&gt;adjvex;            ete=etv[j];                //活动最早发生时间            lte=ltv[k]-e-&gt;weight;    //活动最迟发生时间            if(ete == lte){            //两者相等，即为关键活动                cout &lt;&lt; GL-&gt;adjList[j].data &lt;&lt; &quot;，&quot; &lt;&lt; GL-&gt;adjList[k].data &lt;&lt; &quot;权值：&quot; &lt;&lt; e-&gt;weight;            }        }    }}</code></pre><h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><p>在求每个事件的最早和最迟发生时间，以及活动的最早最迟开始时间，都要对所有顶点及每个顶点边表中所有结点遍历，因此算法时间复杂度为$O(n+e)$.</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/2020/06/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>图的遍历算法是求解图的连通性的问题、拓扑排序和关键路径等算法的基础。<br>然而，图的遍历比树复杂，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问了某个顶点之后，可能沿着某条路径搜索，又回到该顶点上，为了避免同一个顶点被多次访问，遍历图的过程中，必须记下每个被访问过的顶点。<br>可以设置一个辅助数组，将初始值置为0，访问过后置为1，根据搜索方向，有两条常用遍历路径，深度优先遍历与广度优先遍历。</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p><img src="/2020/06/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" srcset="/img/loading.gif" width="250px" height="200px"></p><p>根据上图所示，深度优先遍历每次访问该顶点的第一个邻接点(假设为最左边的顶点)，那么从A出发，访问B，然后再访问C，再访问D，再访问E，访问F，从F出发再进行访问时发现A已经被访问，所以F访问G，然后从G出发，发现B、D已经被访问，所以访问H，从H出发，发现D、E都被访问过，所以退回到G，然后退回到F，退回到E，再次退回到D，然后从D出发访问I，从I出发发现邻接点也都被访问过，所以退回D，再退回C、B，最后退回A，这样就完成了所有顶点的遍历。<br>遍历的过程其实相当于一棵二叉树，如下图所示，这样的树也被称为<strong>深度优先遍历生成树</strong><br><img src="/2020/06/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/2.png" srcset="/img/loading.gif" width="300px" height="300px"></p><p>深度优先遍历(DFS)类似于树的先序遍历，遍历过程如下：</p><ol><li>从图中某个顶点v出发，访问v。</li><li>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重新重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</li><li>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该结点。</li></ol><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>深度优先遍历是一个递归过程，附设一个访问标志数组visited[n],其初值为”false”，一旦某个顶点被访问，则其相应的分量置为”true”,算法步骤如下：</p><ol><li>从图中某个顶点v出发，访问v并置visited[v]的值为true。</li><li>依次检查v的所有邻接点w，如果visited[w]为”false”,再从w出发进行递归遍历，直到图中所有顶点都被访问过。</li></ol><p>连通图遍历算法描述</p><pre><code>bool visited[MVNum];            //标志数组，初始为&quot;false&quot;void DFS(Graph,G,int v){    cout &lt;&lt; v;    visited[v] = true;    //NextAdjVex(G,v,w)，表示v相对于w的下一个结点，w&gt;=0表示存在邻接点    //FistAdjVex(G,v)，表示v的第一个邻接点    for(w=FirstAdjVex(G,v);w&gt;=0;w=NextAdjVex(G,v,w)){        if(!visited[w])            DFS(G,w);    }}</code></pre><p>非连通图需要重新找一个未被访问的顶点作为起始点，然后重复DFS的过程，直至所有顶点都被访问过，非连通图的遍历算法如下：</p><pre><code>void DFSTraverse(Graph G){    for(v=0;v&lt;G.vexnum;++v){        visoted[v] = false;        //初始化    }    for(v=0;v&lt;G.vexnum;++v){        if(!visited[v]) DFS(G,v);    }}</code></pre><h4 id="采用邻接矩阵表示图的深度优先搜索遍历"><a href="#采用邻接矩阵表示图的深度优先搜索遍历" class="headerlink" title="采用邻接矩阵表示图的深度优先搜索遍历"></a>采用邻接矩阵表示图的深度优先搜索遍历</h4><pre><code>void DFS_AM(AMGraph G,int v){    cout &lt;&lt; v;    visited[v] = true;    for(w=0;w&lt;G.vexnum;w++){        if((!G.arc[v][w]!=0) &amp;&amp; (!visited[w]))            DFS_AM(G,w);    }}</code></pre><h4 id="采用邻接表表示图的深度优先搜索遍历"><a href="#采用邻接表表示图的深度优先搜索遍历" class="headerlink" title="采用邻接表表示图的深度优先搜索遍历"></a>采用邻接表表示图的深度优先搜索遍历</h4><pre><code>void DFS_AL(ALGraph G,int v){    cout &lt;&lt; v;    visited[v]=true;    p = G.vertices[v].firstarc;    //p指向v的边链表的第一个边结点    while(p!=NULL){        w = p-&gt;adjvex;            //w是v的邻接点        if(!visited[w]) DFS_AL(G,w);        p = p-&gt;nextarc;    }}</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为$O(n^2)$，其中n为图中顶点数。<br>邻接表做图的存储结构时，查找邻接点的时间复杂度为$O(e)$，e为图中边数。由此，当以邻接表做存储结构时，DFS时间复杂度为$O(n+e)$.</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p><img src="/2020/06/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/3.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>假设需要遍历图1，将图1调整位置后可以得到图2，我们发现图1其实是一个层次的关系，因此广度优先遍历就是层序进行遍历，从A点出发，访问B和F，然后从B出发访问C、I和G，再从F出发访问E(由于G已经被访问，所以不需要再访问G)，从C出发访问D，D已经被访问，所以不需要从I出发再访问D，然后从D出发访问H，H已被访问，所以从E出发不需要再次访问H，这样图就遍历完成了。</p><p>广度优先搜索(BFS)遍历类似于树的层序遍历，遍历过程如下：</p><ol><li>从图中某个顶点v出发，访问v。</li><li>依次访问v的各个未曾访问过的邻接点。</li><li>分别从这些邻接点出发依次访问他们的邻接点，并使”先被访问的顶点的邻接点”先于”后被访问的顶点的邻接点”被访问，重复步骤3，直至所有已被访问的顶点的邻接点都被访问到。</li></ol><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>广度优先遍历的特点是：尽可能先对横向进行搜索，先访问的顶点其邻接点也先被访问，所以算法实现时需要引进队列保存已被访问过的顶点，算法步骤如下：</p><ol><li>从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。</li><li>只要队列不为空，则重复以下操作<ol><li>队头顶点u入队</li><li>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</li></ol></li></ol><p>连通图算法描述</p><pre><code>void BFS(Graph G,int v){    cout &lt;&lt; v;    visited[v] = true;    InitQueue(Q);            //初始化队列Q    EnQueue(Q,v);            //v顶点进队    while(!QueueEmpty(Q)){    //队列非空        DeQueue(Q,u);        //u保存出队后的队头元素        for(w=FirstAdjVex(G,u); w&gt;=0; w=NextAdjVex(G,u,w)){    //w为u的邻接点            if(!visited[w]){                cout &lt;&lt; w;                visited[w] = true;                EnQueue(Q,w);            }        }    }}</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>每个顶点最多进一次队列，使用邻接矩阵存储时，时间复杂度为$O(n^2)$。<br>使用邻接表存储时，时间复杂度为$O(n+e)$，BFS与DFS的差别在于顶点的访问顺序不同。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部分排序问题</title>
    <link href="/2020/06/02/%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/02/%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/06/02/%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/1.jpg" srcset="/img/loading.gif" width="500px" height="400px"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到题目后，有一种简单想法就是将所有k位的部分排序后得到的整体序列全部存起来，然后对每一个序列比较，筛除相同的序列，得到不同序列，但如果n与k的值足够大，需要使用更多的数组存储序列，时间复杂度与空间复杂度都非常高，因此必须想到一个更好的解题思路，以下是我的解题思路。<br>本题中，由于k的值不同，所以每次选择的部分排序也不同，可能存在两次或多次进行部分排序后，整体的序列排序相同。因此需要考虑在什么情况下，两次或两次以上部分排序得到的整体的序列排序也相同，因为序列相同只进行一次计算。<br>由于每次可以从任意位置i(i=0,1,2,3…n)取k位，然后对k位进行升序排序，那么如果i+1位置开始取k位并进行升序排序得到的序列，和前一个位置的升序排序序列得到的序列的的交集相等，则说明这两个经过部分排序的序列得到的整体序列顺序也相等，因此说明两个序列重复，重复的序列只计算一次，如果不等说明两个序列不重复，则序列种类+1。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>void Sort(int *num, int x) {        //冒泡排序    int lenth = x;                    //数组大小    int temp;    for (int i = 0; i &lt; lenth - 1; i++) {                //冒泡排序(将数组元素升序排序)        for (int j = 0; j &lt; lenth - 1 - i; j++) {            if (*(num + j) &gt; *(num + j + 1)) {                temp = *(num + j);                *(num + j) = *(num + j + 1);                *(num + j + 1) = temp;            }        }    }}int IsEqual(int a[], int b[], int k) {        //判断是否相等    Sort(a, k); Sort(b, k);    for (int i = 0; i &lt; k - 1; i++) {        if (a[i] == b[i + 1]) continue;        else return false;    } return true;}int main() {    int max;                        //输入序列长度    cout &lt;&lt; &quot;输入序列长度&quot; &lt;&lt; endl;    cin &gt;&gt; max;    int k;    cout &lt;&lt; &quot;输入k&quot; &lt;&lt; endl;    cin &gt;&gt; k;    int *temp = (int*)malloc(sizeof(int)*k);        //临时数组，负责存储从i位起k个数据，部分排序序列    int *temp1 = (int*)malloc(sizeof(int)*k);        //负责保存上一个部分排序序列    for (int i = 0; i &lt; k; i++) {                    //初始化        temp1[i] = 0;        temp[i] = 0;    }    int *number = (int*)malloc(sizeof(int)*max);    //输入序列    cout &lt;&lt; &quot;序列赋值&quot; &lt;&lt; endl;    for (int i = 0; i &lt; max; i++) {        cin &gt;&gt; number[i];    }    int sortNum = 0;        //初始序列排列种类数量    int fl = 0;                //移位次数    for (int i = 0; i + k &lt; max; i++) fl++;    int lock = 0;    for (int i = 0; i &lt;= fl; i++) {        int b = 0;        for (int j = i; j &lt; i + k; j++) {                //每次截取k位数据            if (b &lt; k) {                temp[b++] = number[j];            }        }        int isTrue = IsEqual(temp, temp1, k);        if (isTrue) {        //判断前后两次部分排序序列的交集是否相等            if (lock != 1) {                sortNum++; lock = 1;            }        }        else if (!isTrue) {            sortNum++; lock = 0;        }        for (int l = 0; l &lt; k; l++) {            temp1[l] = temp[l];        }    } cout &lt;&lt; &quot;结果为:&quot; &lt;&lt; sortNum - 1 &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微程序设计</title>
    <link href="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><h2 id="微程序设计思想的产生"><a href="#微程序设计思想的产生" class="headerlink" title="微程序设计思想的产生"></a>微程序设计思想的产生</h2><p>使用组合逻辑设计的方式设计控制器，思路清晰、简单明了，但是电路庞杂，每个控制信号都需要单独的电路来完成控制信号的生成，如果要对指令集进行扩展，引入新的指令，其相关的微操作或者控制命令的逻辑电路都要进行修改。<br>采用微程序设计的思想来实现控制器，设计和修改都比较容易，可以方便的进行指令集的扩展，这种思想由英国剑桥大学教授Wilkes提出，利用高低电平控制每个节拍发出的控制命令。<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.png" srcset="/img/loading.gif" width="450px" height="150px"><br>完成一条机器指令需要多个微操作命令，分在不同的节拍完成，如果在一个节拍内的多个微操作命令可以并行执行，可以将其组合起来构成一个微指令，这样一条机器指令可以由多个微指令完成，多个微指令就构成了一个微程序，微指令格式可以由二进制代码来表示，1/0代表高低电平有效，如果一个节拍中要发送控制信号，可以由0或者1控制相应的部件生成信号，并且控制相应的微操作命令执行。<br>一条机器指令对应一个微程序，每个微指令包含若干个控制信号，微指令的先后顺序就是微程序在设计上的先后顺序，将微指令存入ROM，执行时将微指令逐条读出，根据微指令有效位数，发送信号。</p><h2 id="微程序控制单元框图及工作原理"><a href="#微程序控制单元框图及工作原理" class="headerlink" title="微程序控制单元框图及工作原理"></a>微程序控制单元框图及工作原理</h2><h3 id="机器指令对应的微程序"><a href="#机器指令对应的微程序" class="headerlink" title="机器指令对应的微程序"></a>机器指令对应的微程序</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.png" srcset="/img/loading.gif" width="350px" height="300px"><br>取指周期有三个节拍，所以由三个微指令完成，每个节拍对应一条微指令，微指令完成每个节拍的微操作。</p><h3 id="微程序控制单元的基本框图"><a href="#微程序控制单元的基本框图" class="headerlink" title="微程序控制单元的基本框图"></a>微程序控制单元的基本框图</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.png" srcset="/img/loading.gif" width="430px" height="350px"><br>微程序、微指令都保存在控制存储器，取出微指令，需要知道微指令的地址，微指令的地址保存在一个寄存器中，也就是控制存储器地址寄存器(CMAR)，这个地址进行译码之后就可以送入控制存储器，控制存储器只读，读出来的微指令放入一个CMDR(控制存储器数据寄存器)中，微地址形成部件需要接受IR中操作码部分送来的信号，微地址形成部件下面有一个顺序逻辑，顺序逻辑负责从CMAR中选择正确的来源(也就是多种”下地址”生成方式的来源)，将其送入CMAR。</p><p><strong>微指令基本格式</strong>：</p><ul><li>操作控制，由0和1组成，每一个位置代表一个操作信号。</li><li>顺序控制，给出下一条微指令的地址。</li></ul><h3 id="微程序控制单元分析"><a href="#微程序控制单元分析" class="headerlink" title="微程序控制单元分析"></a>微程序控制单元分析</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.png" srcset="/img/loading.gif" width="400px" height="320px"><br>每一条微指令右边存放下一条微指令的地址，假设该程序没有间址和中断周期，M-M+2这三条指令将指令取出，至于取出的指令是什么指令，需要经过指令译码才能知道去执行周期执行哪一个微程序，这个过程由微地址形成部件来做的，微地址形成部件根据取来的这条指令的操作码，形成这条指令它在执行阶段所在的微程序在控制存储器中保存的位置，所以由XXX表示。</p><h3 id="微程序工作原理"><a href="#微程序工作原理" class="headerlink" title="微程序工作原理"></a>微程序工作原理</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.png" srcset="/img/loading.gif" width="400px" height="320px"></p><h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><p>M-&gt;CMAR，(控制存储器中M的内容送入CMAR，由CMAR指出第一条微指令在控制存储器的首地址)<br>CM(CMAR)-&gt;CMDR(控制存储器中保存的指令取出，送入到CMDR，CMDR保存了要执行的控制信号)<br>由CMDR发命令形成下条微指令地址M+1<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.png" srcset="/img/loading.gif" width="300px" height="80px"></p><p>Ad(CMDR)-&gt;CMAR(将地址码部分通过顺序逻辑送入CMAR)<br>CM(CMAR)-&gt;CMDR(将CMAR指出的地址所指向的控制存储器的单元所保存的微指令送入CMDR)<br>由CMDR发命令形成下条微指令地址M+2<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/7.png" srcset="/img/loading.gif" width="300px" height="80px"></p><p>Ad(CMDR)-&gt;CMAR<br>CM(CMAR)-&gt;CMDR<br>由CMDR发命令，进入间址阶段或执行阶段<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/8.png" srcset="/img/loading.gif" width="300px" height="80px"></p><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>OP(IR)-&gt;微地址形成部件-&gt;CMAR(p-&gt;CMAR)<br>CM(CMAR)-&gt;CMDR<br>由CMDR发命令，形成下一条微指令地址P+1<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/9.png" srcset="/img/loading.gif" width="300px" height="80px"></p><p>Ad(CMDR)-&gt;CMAR(CMDR地址码部分送入CMAR)<br>CM(CMAR)-&gt;CMDR<br>由CMDR发命令，形成下一条微指令地址P+2<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10.png" srcset="/img/loading.gif" width="300px" height="80px"></p><p>Ad(CMDR)-&gt;CMAR<br>CM(CMAR)-&gt;CMDR<br>由CMDR发命令，形成下条微指令地址M<br>Ad(CMDR)-&gt;CMAR<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/11.png" srcset="/img/loading.gif" width="300px" height="80px"></p><ul><li>全部微指令存在CM中，程序执行过程中只需读出</li><li>微指令的操作控制字段如何形成微操作命令</li><li>微指令的后续地址如何形成</li></ul><h2 id="微指令的编码方式-控制方式"><a href="#微指令的编码方式-控制方式" class="headerlink" title="微指令的编码方式(控制方式)"></a>微指令的编码方式(控制方式)</h2><h3 id="直接编码方式"><a href="#直接编码方式" class="headerlink" title="直接编码方式"></a>直接编码方式</h3><p>在微指令的操作字段中，每一位代表一个微操作命令<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/12.png" srcset="/img/loading.gif" width="300px" height="80px"><br>某位为”1”表示该控制信号有效，这种方式控制信号由某一位直接给出，不需要译码，所以速度最快。</p><h3 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h3><p>将微指令的控制字段分成若干”段”，每段经过译码后发出控制信号<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/13.png" srcset="/img/loading.gif" width="330px" height="200px"><br>每段译码只有一位是有效信号，每一位都代表在这组或者这一段中的一个微操作，如果译码结果有$2^n$位，代表有$2^n$个微操作,但只有一个有效，所以每个字段中的命令是互斥的，这种方式称为显示编码，优点是缩短了微指令字长，增加了译码时间，所以微程序执行速度较慢。</p><h3 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/14.png" srcset="/img/loading.gif" width="330px" height="200px"><br>每个字段的译码结果不仅和本字段的输入有关，还和其他字段译码结果相关</p><h3 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h3><p>直接编码和字段编码混合使用</p><h2 id="微指令序列地址的形成"><a href="#微指令序列地址的形成" class="headerlink" title="微指令序列地址的形成"></a>微指令序列地址的形成</h2><ul><li>微指令的下地址字段指出</li><li>根据机器指令的操作码形成</li><li>增量计数器(CMAR)+1-&gt;CMAR</li><li>分支转移(也就是地址跳转)<ul><li>由操作控制字段、转移方式、转移地址组成</li><li>转移方式：指明判别条件</li><li>转移地址：指明转移成功后的去向</li></ul></li><li>通过测试网络（没看懂）<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.png" srcset="/img/loading.gif" width="500px" height="170px"></li><li>由硬件产生位程序入口地址<ul><li>第一条微指令地址由专门硬件产生</li><li>中断周期，由硬件产生中断周期微程序首地址</li></ul></li><li>后续微指令地址形成方式原理图<br><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/16.png" srcset="/img/loading.gif" width="375px" height="330px"></li></ul><h2 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h2><ul><li>水平型微指令，一次能定义并执行多个并行操作<ul><li>直接编码、字段直接编码、字段间接编码、直接和字段混合编码</li></ul></li><li>垂直型微指令<ul><li>类似机器指令操作码的方式</li><li>由操作码字段规定微指令的功能</li></ul></li></ul><h3 id="两种微指令格式的比较"><a href="#两种微指令格式的比较" class="headerlink" title="两种微指令格式的比较"></a>两种微指令格式的比较</h3><ol><li>水平型微指令比垂直型微指令并行操作能力强，灵活性强</li><li>水平型微指令执行一条机器指令所要的微指令数目少，速度快</li><li>水平型微指令用较短的微程序结构换取较长的微指令结构</li><li>水平型微指令与机器指令差别大</li></ol><h2 id="静态微程序设计和动态微程序设计"><a href="#静态微程序设计和动态微程序设计" class="headerlink" title="静态微程序设计和动态微程序设计"></a>静态微程序设计和动态微程序设计</h2><ul><li>静态，微程序无须改变，也就是指令集不变，将为程序存入ROM</li><li>动态，通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM</li></ul><h2 id="豪微程序设计"><a href="#豪微程序设计" class="headerlink" title="豪微程序设计"></a>豪微程序设计</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>豪微程序设计用微程序解释机器指令</li><li>豪微程序设计用豪微程序解释微指令</li><li>豪微指令与微指令的关系好比微指令和机器指令的关系</li></ul><h3 id="豪微程序控制存储器的基本组成"><a href="#豪微程序控制存储器的基本组成" class="headerlink" title="豪微程序控制存储器的基本组成"></a>豪微程序控制存储器的基本组成</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/17.png" srcset="/img/loading.gif" width="375px" height="330px"></p><h3 id="串行微程序控制和并行微程序控制"><a href="#串行微程序控制和并行微程序控制" class="headerlink" title="串行微程序控制和并行微程序控制"></a>串行微程序控制和并行微程序控制</h3><p><img src="/2020/05/28/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/18.png" srcset="/img/loading.gif" width="500px" height="250px"></p><h2 id="微程序设计步骤"><a href="#微程序设计步骤" class="headerlink" title="微程序设计步骤"></a>微程序设计步骤</h2><ol><li>写出对应机器指令的微操作及节拍安排<ol><li>取指阶段微操作分析</li><li>取指阶段的微操作及节拍安排</li><li>执行阶段的微操作及节拍安排</li></ol></li><li>确定微指令格式<ol><li>微指令的编码方式</li><li>后续微指令的地址形成方式</li><li>微指令子串</li><li>微指令字长的确定</li><li>定义微指令操作控制字段的每一位操作</li></ol></li><li>编写微指令码点</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑设计</title>
    <link href="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h1><h2 id="组合逻辑控制单元框图"><a href="#组合逻辑控制单元框图" class="headerlink" title="组合逻辑控制单元框图"></a>组合逻辑控制单元框图</h2><h3 id="CU外特性"><a href="#CU外特性" class="headerlink" title="CU外特性"></a>CU外特性</h3><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/1.png" srcset="/img/loading.gif" width="300px" height="200px"><br>CU发出控制信号，信号之间有先后关系，节拍发生器产生的节拍作为CU的输入，节拍发生器外接入CLK(机器主频)，产生多个节拍信号，每个节拍信号的起始端,CU会产生命令，IR的指令的操作码部分需要译码，n位操作码可以译码出$2^n$个结果。</p><h3 id="节拍信号"><a href="#节拍信号" class="headerlink" title="节拍信号"></a>节拍信号</h3><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/2.png" srcset="/img/loading.gif" width="350px" height="180px"></p><h2 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h2><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/3.png" srcset="/img/loading.gif" width="350px" height="180px"><br>采用同步控制方式，也就是有一个统一的时钟信号来控制各个部件之间的交互，假设我们所设计一个机器周期内有三个节拍(时钟周期)，并且CPU内部结构采用非总线方式。</p><h3 id="安排微操作时许的原则"><a href="#安排微操作时许的原则" class="headerlink" title="安排微操作时许的原则"></a>安排微操作时许的原则</h3><ol><li>微操作的先后顺序不得随意更改</li><li>被控对象不同的微操作尽量安排在一个节拍内完成</li><li>占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序</li></ol><h3 id="取指周期微操作的节拍安排"><a href="#取指周期微操作的节拍安排" class="headerlink" title="取指周期微操作的节拍安排"></a>取指周期微操作的节拍安排</h3><ul><li>$T_0$，不同的微操作可以安排在一个周期内完成<ul><li>PC-&gt;MAR</li><li>1-&gt;R</li></ul></li><li>$T_1$，同样按照原则二<ul><li>M(MAR)-&gt;MDR</li><li>(PC)+1-&gt;PC</li></ul></li><li>$T_2$，两个微操作占用时间较短，一个微操作可在时钟周期的上升沿，一个在下降沿完成<ul><li>MDR-&gt;IR</li><li>OP(IR)-&gt;ID</li></ul></li></ul><h3 id="间址周期微操作的节拍安排"><a href="#间址周期微操作的节拍安排" class="headerlink" title="间址周期微操作的节拍安排"></a>间址周期微操作的节拍安排</h3><ul><li>$T_0$<ul><li>Ad(IR)-&gt;MAR</li><li>1-&gt;R</li></ul></li><li>$T_1$<ul><li>M(MAR)-&gt;MDR</li></ul></li><li>$T_2$<ul><li>MDR-&gt;Ad(IR)</li></ul></li></ul><h3 id="执行周期微操作的节拍安排"><a href="#执行周期微操作的节拍安排" class="headerlink" title="执行周期微操作的节拍安排"></a>执行周期微操作的节拍安排</h3><ol><li>CLA(对累加器进行清零)，$T_2$: 0-&gt;AC</li><li>COM(对累加器的内容按位取反)，$T_2$: AC(取反)-&gt;AC</li><li>SHR(AC当中保存的内容右移)，$T_2$: L(AC)-&gt;R(AC),$AC_0-&gt;AC_0$</li><li>CSL(循环左移)，$T_2$: R(AC)-&gt;L(AC),$AC_0-&gt;AC_n$</li><li>STP(停机命令)，$T_2$: 0-G</li><li>ADD X(将X寄存器保存的内容和AC的内容相加)<ul><li>$T_0$，Ad(IR)-&gt;MAR</li><li>$T_1$，M(MAR)-&gt;MDR</li><li>$T_2$，(AC)+(MDR)-&gt;AC</li></ul></li><li>STA X(将AC的数据存入X中)<ul><li>$T_0$，Ad(IR)-&gt;MAR</li><li>$T_1$，AC-&gt;MDR</li><li>$T_2$，MDR-&gt;M(MAR)</li></ul></li><li>LDA X(将X中的数据取出送入CPU并且保存进AC)<ul><li>$T_0$，Ad(IR)-&gt;MAR</li><li>$T_1$，M(MAR)-&gt;MDR</li><li>$T_2$，MDR-&gt;AC</li></ul></li><li>JMP X(跳转到给定的地址)，$T_2$: MDR-&gt;AC</li></ol><h3 id="中断周期微操作的节拍安排"><a href="#中断周期微操作的节拍安排" class="headerlink" title="中断周期微操作的节拍安排"></a>中断周期微操作的节拍安排</h3><ul><li>$T_0$: 0-&gt;MAR; 1-&gt;W</li><li>$T_1$: PC-&gt;MDR</li><li>$T_2$: MDR-&gt;M(MAR);向量地址-&gt;PC</li></ul><h2 id="组合逻辑设计步骤"><a href="#组合逻辑设计步骤" class="headerlink" title="组合逻辑设计步骤"></a>组合逻辑设计步骤</h2><h3 id="列出操作时间表"><a href="#列出操作时间表" class="headerlink" title="列出操作时间表"></a>列出操作时间表</h3><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/4.png" srcset="/img/loading.gif" width="500px" height="250px"></p><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/5.png" srcset="/img/loading.gif" width="500px" height="250px"></p><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/6.png" srcset="/img/loading.gif" width="500px" height="250px"></p><h3 id="写出微操作命令的最简表达式"><a href="#写出微操作命令的最简表达式" class="headerlink" title="写出微操作命令的最简表达式"></a>写出微操作命令的最简表达式</h3><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/7.png" srcset="/img/loading.gif" width="350px" height="180px"></p><h3 id="画出逻辑图"><a href="#画出逻辑图" class="headerlink" title="画出逻辑图"></a>画出逻辑图</h3><p><img src="/2020/05/27/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/8.png" srcset="/img/loading.gif" width="350px" height="180px"></p><ul><li>思路清晰，简单明了</li><li>庞杂，调试困难，修改困难</li><li>速度快(RISC)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之图概述</title>
    <link href="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/1.png" srcset="/img/loading.gif" width="280px" height="200px"><br>图G由两个集合V和E组成，记为G=(V,E)，V是顶点的<strong>有穷非空</strong>集合，E是V中顶点偶对的<strong>有穷</strong>集合，这些顶点偶对称为边,V(G)表示图的顶点集合，E(G)表示图的边集合。</p><ul><li>在线性表中，数据元素叫做元素，树中将数据元素叫结点，而图中数据元素叫做顶点。</li><li>线性表可以没有数据元素，称作空表，树中也可以没有结点，叫做空树，但图中不允许没有顶点。</li><li>线性表中，相邻数据元素之间具有线性关系，树结构中，相邻两层结点具有层次关系，图中，任何两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li><li>有向图中，顶点对<x ,y>是有序的，称为从顶点x到顶点y的一条有向边，也成为弧，x为弧尾，y为弧头。</x></li><li>无向图中，顶点对(x,y)是无序的，称为顶点x与顶点y的一条边，没有方向。</li></ul><h1 id="图的基本术语"><a href="#图的基本术语" class="headerlink" title="图的基本术语"></a>图的基本术语</h1><ul><li>子图： 两个图G=(V,E)，G’=(V’,E’),如果$V’\subseteq V$且$E’\subseteq E$，则称G’为G’的子图。</li><li>无向完全图: 若具有n(n-1)/2条边(任意两个顶点之间都存在边)，则称为无向完全图。</li><li>有向完全图: 若具有n(n-1)条弧(任意两个顶点之间都存在方向互为相反的两条弧)，则称为有向完全图。</li><li>稀疏图和稠密图: 有很少条边或弧，如$e&lt;nlog_2n$的图称为稀疏图，反之称为稠密图。</li><li>权和网: 实际应用中，每条边可以标上具有含义的数值，该数值称为该边的权，带权的图通常称为网。</li><li>邻接点: 对于无向图G，如果$(v,v’)\in E$,则称顶点v与v’为邻接点，或者说相关联、相邻接。</li><li>度、入度和出度: 顶点v的度是指v相关联的边的数目，记为TD(v)；入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v)，顶点的度=入度+出度，图的边数=每个顶点度之和的一半。</li><li>路径和路径长度: 无向图中，路径是顶点之间的一个顶点序列，有向图中，路径也是有向的；路径长度是一条路径上经过的边或弧的数目。</li><li>回路或环: 第一个顶点和最后一个顶点相同的路径称为回路或环。</li><li>简单路径、简单回路、简单环: 序列中顶点不重复出现的路径称为简单路径，除了第一个和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路。</li><li>连通、连通图、连通分量: 在无向图G中，如果两个顶点之间有路径，则两个顶点是连通的；如果图中任意两个顶点都是连通的，则称为连通图；连通分量是无向图中的极大连通子图。</li><li>强连通图和强连通分量: 有向图中，如果$v_i$与$v_j$和$v_j$与$v_i$之间都有路径，则称为强连通图，有向图中极大强连通子图称作强连通分量。</li><li>连通图的生成树: 能够构成一棵树的n-1条边的连通子图称为连通图的生成树;一棵n个结点的树有n-1条边，如果一个图有n个顶点和小于n-1条边，则是非连通图，如果多于n-1条边，则一定有环。</li><li>有向树和生成森林: 有一个顶点入度为0，其余顶点入度为1的图，称为有向树，一个有向树的生成森林是若干棵有向树组成的。</li></ul><h1 id="图的类型定义"><a href="#图的类型定义" class="headerlink" title="图的类型定义"></a>图的类型定义</h1><pre><code>CreateGraph(*G,V,VR);        //按照顶点集V和边弧集VR的定义构造图G。DestroyGraph (*G);            //图G存在则销毁。LocateVex(G,u);                //若图G中存在顶点u，则返回图中的位置。GetVex(G,v);                //返回图G中顶点y的值。PutVex(G,v,value);            //将图G中顶点v赋值value。FirstAdjVex(G,*v);            //返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。NextAdjVex(G,v,*w);            //返回顶点v相对于顶点w的下一个邻接顶点,若w是v的最，一个邻接点则返回“空”。InsertVex(*G,v);            //在图G中增添新顶点V。DeleteVex(*G,v);            //删除图G中顶点v及其相关的弧。InsertArc(*G,v,w);            //在图G中增添弧&lt;v,w&gt;,若G是无向图，还需要增添对称弧&lt;w,v&gt;。DeleteArc(*G,v,w);            //在图G中删除弧&lt;v,w&gt;,若G是无向圈，则还删除对称弧&lt;w,v&gt;。DFSTraverse(G);                //对圈G中进行深度优先遍历，在遍历过程对每个顶点调用。BFSTraverse(G);                //对图G中进行广度优先遍历，在遍历过程对每个顶点调用。</code></pre><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>由于图的结构比较复杂，无法以元素在存储区的位置来表示关系，所以图没有顺序存储结构 ，可以借助二维数组来表示元素间的关系，即邻接矩阵表示法，图的链式存储结构有邻接表，十字链表，邻接多重表等。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。<br>设G(V,E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。</p><script type="math/tex;mode=display">arc[i][j]=\begin{cases}1& (若<v_i,v_j>或(v_i,v_j)\in E)\\0& 反之\end{cases}</script><p><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="500px" height="230px"></p><p>如上图，顶点数组为<script type="math/tex">vertex[4]=\{v_0,v_1,v_2,v_3\}</script>，边数组是一个二维数组，如果两个元素之间有边，则对于二维数组的值为1，如果无边则为0，对于<script type="math/tex">arc[i][i](i=1,2,3...n)</script>的元素来说，由于不存在自身到自身的边，所以对于元素均为0，因此无向图的边数组是一个对称矩阵。<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" width="500px" height="230px"><br>上图是一个有向图，顶点数组为<script type="math/tex">vertex[4]=\{v_0,v_1,v_2,v_3\}</script>，弧数组是一个矩阵，主对角线上的数值依然为0.<br>因为有向图的边$<v1 ,v2>$与边$<v2 ,v1>$不同，所以两个顶点之间可能存在两条边，因此有向图的邻接矩阵并不对称，有向图讲究入度和出度，入度与出度之和为该顶点的度，如果G(V,E)是一个网，并且顶点到顶点之间有路径，弧的对应值应该存放路径上的权值，如果顶点到顶点之间无路径，则可以使用无穷大表示。</v2></v1></p><h3 id="图的存储结构代码表示"><a href="#图的存储结构代码表示" class="headerlink" title="图的存储结构代码表示"></a>图的存储结构代码表示</h3><pre><code>typedef char VertexType;    //顶点类型typedef int EdgeType;        //边上的权值#define MAXVEX 100            //最大顶点数#define INFINITY 65535        //代表无穷大typedef struct {    VertexType vexs[MAXVEX];        //顶点表    EdgeType arc[MAXVEX][MAXVEX];    //邻接矩阵    int numVertexes, numEdges;        //图中当前节点数和边数}MGraph;void CreateMgraph(MGraph *G) {    int  i, j, k, w;    cout &lt;&lt; &quot;输入顶点数和边数&quot; &lt;&lt; endl;    cin &gt;&gt; G-&gt;numVertexes &gt;&gt; G-&gt;numEdges;    for (i = 0; i &lt; G-&gt;numVertexes; i++) {        cin &gt;&gt; G-&gt;vexs[i];    }    for (i = 0; i &lt; G-&gt;numVertexes; i++) {        //初始化        for (j = 0; j &lt; G-&gt;numVertexes; j++) {            G-&gt;arc[i][j] = INFINITY;        }    }    for (k = 0; k &lt; G-&gt;numEdges; i++) {        cout &lt;&lt; &quot;请输入边(vi,vj)上的i、j和权值&quot; &lt;&lt; endl;        cin &gt;&gt; i &gt;&gt; j &gt;&gt; w;        G-&gt;arc[i][j] = w;        G-&gt;arc[j][i] = G-&gt;arc[i][j];        //矩阵对称    }}</code></pre><h3 id="邻接矩阵的优缺点"><a href="#邻接矩阵的优缺点" class="headerlink" title="邻接矩阵的优缺点"></a>邻接矩阵的优缺点</h3><ul><li>优点<ul><li>便于判断两个顶点之间是否有边</li><li>便于计算各顶点的度</li></ul></li><li>缺点<ul><li>不便于增加和删除顶点</li><li>不便于统计边的数目，因为时间复杂度为$O(n^2)$</li><li>时间复杂度较高，并且浪费空间。</li></ul></li></ul><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表是图的一种链式存储结构，在邻接表中每个顶点之间建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，使用数组加链表的结合存储方式称为邻接表。<br>邻接表的处理方法如下：</p><ol><li>图中顶点用一个一维数组存储，也可以用单链表存储，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</li><li>图中每个顶点的所有邻接点构成一个线性表，由于临界点个数不定，所以采用单链表方式存储，下图是一个无向图的邻接表结构。<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" width="500px" height="150px"></li></ol><p>图中定点表的各个结点由data和firstedge两个域表示，<strong>data</strong>是数据域，存储顶点信息，<strong>firstedge</strong>是指针域，指向边表的第一个结点，即此顶点的第一个邻接点，边表结点由adjvex和next组成，<strong>adjvex</strong>是邻接点域，存储某顶点的邻接点在顶点表中的下标，<strong>next</strong>则存储指向边表中下一个结点的指针。<br>对于有向图，邻接表的结构也是类似的，但由于有向图区别方向，所以将顶点为弧尾来存储边表，并且还需要一个有向图的逆邻接表存储，邻接表负责存储入度的结点，逆邻接表负责存储出度的结点。<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" width="400px" height="350px"></p><p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息，如下图所示：<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h3 id="无向图邻接表代码示例"><a href="#无向图邻接表代码示例" class="headerlink" title="无向图邻接表代码示例"></a>无向图邻接表代码示例</h3><pre><code>#define MAXVEX 30typedef char VertexType;        //顶点类型typedef int EdgeType;            //权值类型typedef struct EdgeNode {        //边表结点    int adjvex;                    //存储该顶点对应下标    EdgeType weight;            //权值    struct EdgeNode *next;}EdgeNode;typedef struct VertexNode {        //顶点表结点    VertexType data;            //顶点域    EdgeNode *firstedge;        //边表头指针}VertexNode,AdjList[MAXVEX];typedef struct {    AdjList adjList;    int numVertexes, numEdges;        //图中当前顶点数和边数}GraphAdjList;void CreateALGraph(GraphAdjList *G) {    int i, j, k;    EdgeNode *e;    cout &lt;&lt; &quot;输入顶点数和边数&quot; &lt;&lt; endl;    cin &gt;&gt; G-&gt;numVertexes &gt;&gt; G-&gt;numEdges;    for (i = 0; i &lt; G-&gt;numVertexes; i++) {        //建立顶点表        cin &gt;&gt; G-&gt;adjList[i].data;        G-&gt;adjList[i].firstedge = NULL;    }    for (k = 0; k &lt; G-&gt;numEdges; k++) {            //头插法        cout &lt;&lt; &quot;输入边(vi,vj)上的顶点序号&quot; &lt;&lt; endl;        cin &gt;&gt; i &gt;&gt; j;        e = (EdgeNode*)malloc(sizeof(EdgeNode));        e-&gt;adjvex = j;        e-&gt;next = G-&gt;adjList[i].firstedge;        //e指向当前顶点指向的结点        G-&gt;adjList[i].firstedge = e;        //由于是无向图，因此顶点i与顶点j相互指向        e = (EdgeNode*)malloc(sizeof(EdgeNode));        e-&gt;adjvex = i;        e-&gt;next = G-&gt;adjList[j].firstedge;        G-&gt;adjList[j].firstedge = e;    }}</code></pre><p>该算法时间复杂度为O(n+e)，建立有向图邻接表与此类似，在生成图时，只需要对应申请一个结点空间便可，网图可将权值存储在<strong>weight</strong>中。</p><h3 id="邻接表表示法的优缺点"><a href="#邻接表表示法的优缺点" class="headerlink" title="邻接表表示法的优缺点"></a>邻接表表示法的优缺点</h3><ul><li>优点<ul><li>便于增加和删除顶点</li><li>便于统计边的数目</li><li>空间效率高</li></ul></li><li>缺点<ul><li>不便于判断顶点之间是否有边</li><li>不便于计算有向图各顶点的度</li></ul></li></ul><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>十字链表是有向图的另一种链式存储方式，可以看作是有向图的邻接表和逆邻接表的结合，目的是为了便于求得图中顶点的度，十字链表存储结构中，有向图的顶点结构如下图所示：<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/7.png" srcset="/img/loading.gif" width="250px" height="50px"></p><p>其中<strong>data</strong>表示顶点的数据，<strong>firstIn</strong>表示指向以该顶点为弧头的第一个弧结点，<strong>firstOut</strong>表示指向以该顶点为弧尾的第一个弧结点，为了表示有向图中所有的顶点，采用一个顶点数组存储每一个结点，弧结点定义如下：<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/8.png" srcset="/img/loading.gif" width="300px" height="50px"></p><p>其中<strong>tailvex</strong>表示弧起点在顶点表的下标，<strong>headvex</strong>是指弧终点在顶点表中的下标，<strong>headlink</strong>是指入边表指针域，指向终点相同的下一条边，<strong>taillink</strong>是指边表指针域，指向起点相同的下一条边，如果是网，还可以再增加一个<strong>weight</strong>域来存放权值，十字链表结构如下图所示：<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/9.png" srcset="/img/loading.gif" width="500px" height="250px"></p><h3 id="十字链表存储结构代码示例"><a href="#十字链表存储结构代码示例" class="headerlink" title="十字链表存储结构代码示例"></a>十字链表存储结构代码示例</h3><pre><code>#define MAX_VERTEX_NUM 20typedef int infoType;typedef char vertexTpe;typedef struct ArcBox{                //弧结点    int tailvex,headvex;            //该弧的尾和头顶点的位置    struct ArcBox *hlink,*tlink;    //分别为弧头和弧尾相同的弧的链域    InfoType *info;                    //该弧相关信息的指针}ArcBox;typedef struct VexNode{                //顶点结构    VertexType data;                    ArcBox *firstin,*firstout;        //指向该顶点的入弧和出弧}VexNode;typedef struct{    VexNode xlist[MAX_VERTEX_NUM];    //表头向量    int vexnum,arcnum;                //有向图的当前顶点数和弧数}OLGraph;</code></pre><h3 id="十字链表简易代码示例"><a href="#十字链表简易代码示例" class="headerlink" title="十字链表简易代码示例"></a>十字链表简易代码示例</h3><pre><code>#define MAX_VERTEX_NUM 20typedef int InfoType;typedef char VertexType;typedef struct ArcBox {                //弧结点    int tailvex, headvex;            //该弧的尾和头顶点的位置    struct ArcBox *hlink, *tlink;    //分别为弧头和弧尾相同的弧的链域    InfoType *info;                    //该弧相关信息的指针}ArcBox;typedef struct VexNode {                //顶点结构    VertexType data;    ArcBox *firstin, *firstout;        //指向该顶点的入弧和出弧}VexNode;typedef struct {    VexNode xlist[MAX_VERTEX_NUM];    //表头向量    int vexnum, arcnum;                //有向图的当前顶点数和弧数}OLGraph;int locateVertex(OLGraph &amp;G, char c) {        //寻找顶点的下标    int index = -1;        for (int i = 0; i &lt; G.vexnum; i++) {         if (c == G.xlist[i].data) {             index = i; break;         }     } return index;}void CreateOLGraph(OLGraph &amp;g) {    g.arcnum = 0;    cout &lt;&lt; &quot;请输入有向图的当前顶点数&quot; &lt;&lt; endl;    cin &gt;&gt; g.vexnum;    for (int i = 0; i &lt; g.vexnum; i++) {        //输入顶点数据        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点&quot; &lt;&lt; endl;        cin &gt;&gt; g.xlist[i].data;        g.xlist[i].firstin = NULL;        g.xlist[i].firstout = NULL;    }}void AddArcBox(OLGraph &amp;g,int t,int h) {            //插入弧(头插法)    ArcBox *arb = (ArcBox*)malloc(sizeof(ArcBox));    arb-&gt;headvex = h;    arb-&gt;tailvex = t;    arb-&gt;info = NULL;    ArcBox *ptail = g.xlist[t].firstout;        ArcBox *phead = g.xlist[h].firstin;    if (!ptail) { arb-&gt;tlink = NULL; }    else { arb-&gt;tlink = ptail; }         if (!phead) { arb-&gt;hlink = NULL; }    else { arb-&gt;hlink = phead; }         g.xlist[t].firstout = arb;    g.xlist[h].firstin = arb;    g.arcnum++;}void InsertNode(OLGraph &amp;g) {                    //插入顶点    cin &gt;&gt; g.xlist[g.vexnum].data;    g.xlist[g.vexnum].firstin = NULL;    g.xlist[g.vexnum].firstout = NULL;    g.vexnum++;}int GetDepth(OLGraph g,int i) {                    //得到顶点的度    int num = 0;    ArcBox* v = g.xlist[i].firstin;    while (v) {        v = v-&gt;hlink;        num++;    }    v = g.xlist[i].firstout;    while (v) {        v = v-&gt;tlink;        num++;    }    return num;}int printDG(OLGraph &amp;g) {            //打印    for (int i = 0; i &lt; g.vexnum; i++) {        ArcBox *ptail = g.xlist[i].firstout;        ArcBox *phead = g.xlist[i].firstin;        cout&lt;&lt;&quot;以顶点&quot;&lt;&lt;i&lt;&lt;&quot;为弧尾的链域 &quot;&lt;&lt;g.xlist[i].data;                while(ptail){                        cout&lt;&lt;&quot;--&gt;&quot;&lt;&lt;&quot;|&quot;&lt;&lt;ptail-&gt;tailvex&lt;&lt;&quot;|&quot;&lt;&lt;ptail-&gt;headvex &lt;&lt; &quot;|&quot;;                        ptail = ptail-&gt; tlink;                }        cout&lt;&lt;&quot;--&gt;NULL&quot;&lt;&lt;endl;        cout&lt;&lt;&quot;以顶点&quot;&lt;&lt;i&lt;&lt;&quot;为弧头的链域 &quot;&lt;&lt;g.xlist[i].data;                while(phead){                        cout&lt;&lt;&quot;--&gt;&quot;&lt;&lt;&quot;|&quot;&lt;&lt;phead-&gt;tailvex&lt;&lt;&quot;|&quot;&lt;&lt;phead-&gt;headvex &lt;&lt; &quot;|&quot;;                        phead = phead-&gt;hlink;                }                cout&lt;&lt;&quot;--&gt;NULL&quot;&lt;&lt;endl;        }        return 1;}//测试int main() {    OLGraph g;    CreateOLGraph(g);    AddArcBox(g, 0, 2);    AddArcBox(g, 2, 3);    AddArcBox(g, 0, 3);    printDG(g);    getchar();    getchar();    return 0;}</code></pre><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>邻接多重表是无向图的另一种链式存储方式，使用邻接表更容易对其顶点进行操作，如果对于边操作就比较麻烦，因此有了邻接多重表的结构，重新定义的边表节点结构如下图：<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="300px" height="40px"></p><p>其中ivex和jvex是与某条边依附的两个顶点在顶点表中下标，ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边，这既是邻接多重表结构。<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/11.png" srcset="/img/loading.gif" width="450px" height="260px"></p><p>邻接多重表与邻接表的差别在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点，如果要删除某边，只需要将两个链域指向空即可。</p><h3 id="邻接多重表存储代码示例"><a href="#邻接多重表存储代码示例" class="headerlink" title="邻接多重表存储代码示例"></a>邻接多重表存储代码示例</h3><pre><code>#define MAX_VERTEX_NUM 20typedef enum{unvisited,visited} VisitIf;typedef struct EBox{    VisitIf mark;        //访问标记    int ivex,jvex;        //该边依附的两个顶点的位置    struct EBox *ilink,*jlink;    //分别指向依附这两个顶点的下一条边    InfoType *info;        //该边信息指针}Ebox;typedef struct VexBox{    VertexType data;    EBox *firstedge;    //指向第一条依附该顶点的边}VexBox;typedef struct{    VexBox adjmulist[MAX_VERTEX_NUM];    int vexnum,edgenum;        //无向图的当前顶点数和边数}AMLGraph;</code></pre><h3 id="邻接多重表简易代码示例"><a href="#邻接多重表简易代码示例" class="headerlink" title="邻接多重表简易代码示例"></a>邻接多重表简易代码示例</h3><pre><code>#define MAX_VERTEX_NUM 20        //最大顶点数typedef int InfoType;typedef char VertexType;typedef enum { unvisited, visited } VisitIf;typedef struct EBox {    VisitIf mark;                //访问标记    int ivex, jvex;                //该边依附的两个顶点的位置    struct EBox *ilink, *jlink;    //分别指向依附这两个顶点的下一条边    InfoType *info;                //该边信息指针}Ebox;typedef struct VexBox {    VertexType data;    EBox *firstedge;            //指向第一条依附该顶点的边}VexBox;typedef struct {    VexBox adjmulist[MAX_VERTEX_NUM];    int vexnum, edgenum;        //无向图的当前顶点数和边数}AMLGraph;void CreateAML(AMLGraph &amp;g) {    cout &lt;&lt; &quot;请输入无向图的顶点数&quot; &lt;&lt; endl;    cin &gt;&gt; g.vexnum;    for (int i = 0; i &lt; g.vexnum; i++) {        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点的数据&quot; &lt;&lt; endl;        cin &gt;&gt; g.adjmulist[i].data;        g.adjmulist[i].firstedge = NULL;    }}void InsertEBox(AMLGraph &amp;g,int i,int j) {    //边结点初始化    Ebox *b = (Ebox*)malloc(sizeof(Ebox));    b-&gt;info = NULL;    b-&gt;ivex = i;    b-&gt;jvex = j;    b-&gt;mark = unvisited;    b-&gt;ilink = NULL;    b-&gt;jlink = NULL;    //找到这个边相邻的第一个顶点    if (g.adjmulist[i].firstedge == NULL) {    //如果第一个顶点边域为空，则第一个顶点的边域指向该边。        g.adjmulist[i].firstedge = b;    }    else {        //否则找到该顶点的最后一个邻边        Ebox *temp = g.adjmulist[i].firstedge;        while (temp-&gt;ilink) {            temp = temp-&gt;ilink;        }        if (b-&gt;ivex == temp-&gt;ivex)            temp-&gt;ilink = b;        if (b-&gt;ivex == temp-&gt;jvex)            temp-&gt;jlink = b;    }    //找到这个边相邻的第二个顶点    if (g.adjmulist[j].firstedge == NULL) {        g.adjmulist[j].firstedge = b;    }    else {        Ebox *temp = g.adjmulist[j].firstedge;        while (temp-&gt;jlink) {            temp = temp-&gt;jlink;        }        if (b-&gt;jvex == temp-&gt;jvex)            temp-&gt;jlink = b;        if (b-&gt;jvex == temp-&gt;ivex)            temp-&gt;ilink = b;    }    g.edgenum++;}void AMLPrint(AMLGraph g) {    cout &lt;&lt; &quot;顶点如下&quot; &lt;&lt; endl;    for (int i = 0; i &lt; g.vexnum; i++) {        cout &lt;&lt; g.adjmulist[i].data &lt;&lt; &quot;  &quot;;    }    cout &lt;&lt; endl &lt;&lt; &quot;边集如下&quot; &lt;&lt; endl;    for (int i = 0; i &lt; g.vexnum; i++) {        Ebox *temp = g.adjmulist[i].firstedge;        while (temp){            if (i == temp-&gt;ivex) {                if (!temp-&gt;mark) {                    cout &lt;&lt; &quot;(&quot; &lt;&lt; temp-&gt;ivex &lt;&lt; &quot;,&quot; &lt;&lt; temp-&gt;jvex &lt;&lt; &quot;)&quot; &lt;&lt; &quot;    &quot;;                    temp-&gt;mark = visited;                }                temp = temp-&gt;ilink;            }            else{                if (!temp-&gt;mark) {                    cout &lt;&lt; &quot;(&quot; &lt;&lt; temp-&gt;ivex &lt;&lt; &quot;,&quot; &lt;&lt; temp-&gt;jvex &lt;&lt; &quot;)&quot; &lt;&lt; &quot;    &quot;;                    temp-&gt;mark = visited;                }                temp = temp-&gt;jlink;            }        }    }    cout &lt;&lt; endl;}//测试int main() {    AMLGraph g;    CreateAML(g);    InsertEBox(g, 0, 1);    InsertEBox(g, 0, 3);    InsertEBox(g, 0, 4);    InsertEBox(g, 1, 3);    InsertEBox(g, 2, 4);    InsertEBox(g, 0, 2);    AMLPrint(g);    system(&quot;pause&quot;);    return 0;}</code></pre><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>边集数组由两个一维数组构成，一个存储顶点的信息，另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权组成，边集数组关注的是边的集合，但在边集数组中查找一个顶点的度需要扫描整个边数组，效率较低，这里不详细叙述，在克鲁斯卡尔算法中在进行介绍。<br><img src="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E6%A6%82%E8%BF%B0/12.png" srcset="/img/loading.gif" width="600px" height="250px"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>无向图<ul><li>邻接矩阵，无向图的邻接矩阵较多为稀疏矩阵，浪费空间且时间复杂度高</li><li>邻接表，采用链式存储，便于顶点的操作，且节省空间，时间复杂度较低</li><li>邻接多重表，解决了邻接表操作图的边困难的问题，主要针对边进行操作。</li></ul></li><li>有向图<ul><li>邻接表，便于查找图顶点的入度</li><li>逆邻接表，便于查找图顶点的出度</li><li>十字链表，结合了邻接表与逆邻接表，便于计算顶点的度</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制单元与微操作命令</title>
    <link href="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="微操作命令分析"><a href="#微操作命令分析" class="headerlink" title="微操作命令分析"></a>微操作命令分析</h1><h2 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h2><p><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/1.png" srcset="/img/loading.gif" width="280px" height="200px"></p><ul><li>PC-&gt;MAR-&gt;地址线</li><li>1-&gt;R(读操作允许信号置为1)</li><li>M(MAR)-&gt;MDR(M表示MAR内的地址所在的内存单元的值)</li><li>MDR-&gt;IR</li><li>OP(IR)-&gt;CU,(OP代表IR中保存的命令的操作码)</li><li>(PC)+1-&gt;PC,(括号加PC，代表取PC的值)</li></ul><p>指令的地址保存在PC中，PC将地址送入MAR经过地址总线送入存储器中，然后CU向存储器发出读信号，该信号经过控制总线送入存储器中，读出的数据从由存储器送给MDR，再由MDR送入IR，指令就被取出到IR当中。<br>在取指周期其实还要完成译码的任务，译码要确定指令要做什么操作，这个操作由指令的操作码给出，所以要将指令的操作码部分送给CU，然后再由CU译码确定指令的操作。取指周期还要对PC进行更新，所以PC的值要+1，把结果再保存进PC当中。</p><h2 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h2><p><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/2.png" srcset="/img/loading.gif" width="280px" height="200px"></p><ul><li>指令形式地址-&gt;MAR</li><li>Ad(IR)-&gt;MAR</li><li>1-&gt;R(发出读信号)</li><li>M(MAR)-&gt;MDR(MAR保存的地址所在内存单元中的数据M送入MDR)</li><li>MDR-&gt;Ad(IR)(真实地址送入IR)</li></ul><p>间址周期说明指令采用的是间接寻址，我们要通过间址周期把操作数的地址，从存储器当中取出，放入IR当中所保存的指令的地址码部分。<br>指令所在的地址由IR给出，首先将形式地址传送给MAR，也就是IR中的地址码部分给MAR，再由MAR经过地址总线传给存储器，要实现这个操作需要由CU控制，发出“将IR的地址码部分送入MAR”的控制信号，也就是IR中的操作码部分进行译码，然后控制器向存储器发出读信号，存储器接收到控制信号后，将指定的内存单元的数据取出，然后通过数据总线，将数据传送给MDR，被取出的数据也是一个地址，所以送入IR中的地址码部分，此时IR中的地址码部分就是操作数的真实地址。</p><h2 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h2><p>在取指周期和间址周期，我们假设指令字长=机器字长=存储字长，执行周期由于各指令长短不一，相对比较复杂。</p><h3 id="非访存指令"><a href="#非访存指令" class="headerlink" title="非访存指令"></a>非访存指令</h3><ol><li>CLA，对ACC进行清零，控制器将0送入ACC</li><li>COM，取反，将ACC中的内容按位取反。</li><li>SHR，算术右移，数据右移后左边会空出一位，原来是数据的符号位，这一位只要用原来的符号位进行填充就可以，这条命令包含两个操作，L(ACC)-&gt;R(ACC)，将ACC左边的内容，写入ACC的右侧，ACC0-&gt;ACC0,最高位重新写回ACC，这两条操作可以同时进行。</li><li>CSL，循环左移，R(ACC)-&gt;L(ACC),ACC0-&gt;ACCn</li><li>STP，停机指令，0-&gt;G</li></ol><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><ol><li>加法指令，ADD X<ul><li>Ad(IR)-&gt;MAR (ACC以及保存了被加数，需要取出加数)</li><li>1-&gt;R(读命令)</li><li>M(MAR)-&gt;MDR</li><li>(ACC)+(MDR)-&gt;ACC(相加后存入ACC)</li></ul></li><li>存数指令，STA X<ul><li>Ad(IR)-&gt;MAR</li><li>1-&gt;w(写命令)</li><li>ACC-&gt;MDR</li><li>MDR-&gt;M(MAR)(MDR的内容存储到MAR指令的单元)</li></ul></li><li>取数指令，LDA X<ul><li>Ad(IR)-&gt;MAR</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;ACC(取出数据存入ACC寄存器)</li></ul></li></ol><h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><ol><li>无条件转移，JMP X，Ad(IR)-&gt;PC</li><li>条件转移，BAN X(上次计算的结果值如果为负，则转移)</li></ol><h3 id="三类指令的指令周期"><a href="#三类指令的指令周期" class="headerlink" title="三类指令的指令周期"></a>三类指令的指令周期</h3><ul><li>非访存指令周期: 取指周期、执行周期</li><li>直接访存指令周期: 取指周期、执行周期</li><li>间接访存指令周期: 取指周期、间址周期、执行周期</li><li>转移指令周期: 取指周期、执行周期</li><li>间接转移指令周期: 取指周期、间址周期、执行周期</li></ul><h2 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h2><p>保存断点分为两种方式，程序断点存入”0”地址，或者程序断点进栈。</p><h3 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h3><ul><li>0-&gt;MAR(0的地址送入MAR)</li><li>1-&gt;W(发送写命令)</li><li>PC-&gt;MDR(断点保存在PC中，所以将PC的内容送入MDR)</li><li>MDR-&gt;M(MAR)(写入操作，完成了保存断点操作)</li><li>向量地址-&gt;PC(硬件向量法)</li><li>0-&gt;EINT(中断允许触发器,关中断)</li></ul><h3 id="程序断点进栈"><a href="#程序断点进栈" class="headerlink" title="程序断点进栈"></a>程序断点进栈</h3><ul><li>(SP)-1-&gt;MAR(要将程序断点写入新的栈顶地址)</li><li>1-&gt;W</li><li>PC-&gt;MDR</li><li>MDR-&gt;M(MAR)</li><li>中断识别程序入口地址M-&gt;PC(软件查询法)</li><li>0-&gt;EINT(置”0”)</li></ul><h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><h2 id="控制单元的外特性"><a href="#控制单元的外特性" class="headerlink" title="控制单元的外特性"></a>控制单元的外特性</h2><p><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/3.png" srcset="/img/loading.gif" width="500px" height="250px"><br>输入信号包括来自指令寄存器的操作码部分，CU要对操作码进行译码，CU在时钟信号的控制之下进行工作，还要各种标志，这些标志是指令执行的必要条件，通过系统总线CPU外部的信号可以进入CU。<br>控制单元的输出信号包括两部分，一个是CPU内部的控制信号，另一个是到系统总线的控制信号。</p><h3 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h3><ol><li>时钟，CU受时钟控制，一个时钟脉冲可以发一个操作命令或一组需同时执行的操作命令。</li><li>指令寄存器，OP(IR)-&gt;CU，控制信号与操作码有关</li><li>标志，CU受标志控制</li><li>外来信号，如INTR中断请求、HRQ总线请求</li></ol><h3 id="输出信号"><a href="#输出信号" class="headerlink" title="输出信号"></a>输出信号</h3><ol><li>CPU内的各种控制信号<ul><li>Ri-&gt;Rj(寄存器之间进行数据传输)</li><li>(PC)+1-&gt;PC(对指令地址进行修改)</li><li>数据运算和逻辑运算</li><li>ALU的控制信号也由CU发出</li></ul></li><li>送至控制总线的信号<ul><li>MREQ，访存控制信号</li><li>IO/M，访IO/存储器的控制信号</li><li>RD，读命令</li><li>WR，写命令</li><li>INTA，中断响应信号</li><li>HLDA，总线响应信号</li></ul></li></ol><h2 id="控制信号举例"><a href="#控制信号举例" class="headerlink" title="控制信号举例"></a>控制信号举例</h2><h3 id="不采用CPU内部总线的方式"><a href="#不采用CPU内部总线的方式" class="headerlink" title="不采用CPU内部总线的方式"></a>不采用CPU内部总线的方式</h3><h4 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h4><p>PC,指出了下一条指令的地址，将指令取到送入IR中，然后送入CU当中译码，CU要有时钟信号控制，还有寄存器AC、运算器ALU、MDR、MAR。<br>取指令PC送入MAR，MAR将地址送入内存，取出的指令送入MDR，如果取回的是指令，需要送入AC当中，如果是加法指令取回的是数据，需要放入AC寄存器，如果取回的是加法指令直接送入ALU进行运算，如果是间址寻址取到的是操作数的地址，需要将地址再送入MAR，将操作数取回，IR要将寄存器的操作码部分送入CU，时钟要送入CU中，控制CU发送控制信号，CU发出各种控制信号控制ALU完成运算，下图是加法指令为例：<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/4.png" srcset="/img/loading.gif" width="460px" height="250px"></p><h4 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a>间址周期</h4><p>同样以加法指令为例，但加法指令的数据部分并不是真实地址，下面假设从MDR拿到形式地址。IR的蓝色部分表示操作数，棕色部分表示地址码。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/5.png" srcset="/img/loading.gif" width="460px" height="250px"></p><h4 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h4><p>由于上次的操作并没有对MDR清零，所以操作数的地址保存在MDR与IR中，假设取操作数地址来源于MDR中，MDR-&gt;MAR,MAR-&gt;内存，CU发送读信号，读出的数据送入MDR，此时AC存的被加数，MDR存的加数，将AC-&gt;ALU,MDR-&gt;ALU,在CU控制下完成运算操作，将结果存入AC.<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/6.png" srcset="/img/loading.gif" width="460px" height="250px"></p><h3 id="采用CPU内部总线的方式"><a href="#采用CPU内部总线的方式" class="headerlink" title="采用CPU内部总线的方式"></a>采用CPU内部总线的方式</h3><h4 id="取指周期-2"><a href="#取指周期-2" class="headerlink" title="取指周期"></a>取指周期</h4><p>为了能够保存参加运算的两个操作数，和输出的运算结果，在这种CPU内部总线结构中，需要在ALU两个输入端加入两个寄存器，其中AC作为一个寄存器，还需要将加入一个Y寄存器，在ALU的输出端加入一个Z寄存器，保存运算的结果。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/7.png" srcset="/img/loading.gif" width="400px" height="300px"></p><blockquote><p>$PC_o$表示PC保存的值</p></blockquote><h4 id="间址周期-2"><a href="#间址周期-2" class="headerlink" title="间址周期"></a>间址周期</h4><p>CPU内部总线相当于结合了地址、数据以及控制总线，但操作逻辑上和之前不采用总线的CPU结构一样，这里不再叙述。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/8.png" srcset="/img/loading.gif" width="400px" height="300px"></p><h4 id="执行周期-2"><a href="#执行周期-2" class="headerlink" title="执行周期"></a>执行周期</h4><p>值得注意的是Y用来保存加数，AC保存被加数，结果由ALU运算后存入Z中。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/9.png" srcset="/img/loading.gif" width="400px" height="300px"></p><h2 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h2><h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><ul><li>机器周期概念：所有指令执行过程中的一个基准时间</li><li>确定机器周期需考虑的因素：每条指令的执行步骤，每一步骤所需的时间</li><li>基准时间的确定：以完成最复杂指令功能的时间为准,一般最复杂的是访问存储器的指令，所以将访问一次存储器的时间为基准，若指令字长=存储子长，则取指周期=机器周期</li></ul><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>一个机器周期内可完成若干个微操作，每个微操作需要一定的时间，因此将一个机器周期分为若干个时间相等的时间段(节拍、状态、时钟周期)。<br>时钟周期是控制计算机操作的最小单位时间，用时钟周期控制产生一个或几个微操作命令。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/10.png" srcset="/img/loading.gif" width="500px" height="250px"></p><h3 id="多级时序系统-1"><a href="#多级时序系统-1" class="headerlink" title="多级时序系统"></a>多级时序系统</h3><p>机器周期、节拍(状态)组成多级时序系统<br>一个指令周期包含若干个时钟周期<br>一个机器周期包含若干个时钟周期<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/11.png" srcset="/img/loading.gif" width="500px" height="250px"></p><h3 id="机器速度与机器主频的关系"><a href="#机器速度与机器主频的关系" class="headerlink" title="机器速度与机器主频的关系"></a>机器速度与机器主频的关系</h3><p>在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比</p><script type="math/tex;mode=display">MINPS_1/MINPS_2 = f_1/F_2</script><p>机器速度不仅与主频有关，还与机器周期中所含时钟周期(主频的倒数)数以及指令周期中所含的机器周期数有关.</p><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>产生不同微操作命令序列所用的时序控制方式</p><h3 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h3><p>任一微操作均有统一基准时标的时序信号控制(定宽定距)。</p><ul><li>可以采用定长的机器周期，以最长的微操作系列和最复杂的微操作作为标准，机器周期内的节拍数相同。<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/12.png" srcset="/img/loading.gif" width="500px" height="120px"></li><li>采用不定长的机器周期，机器周期内节拍数不等<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/13.png" srcset="/img/loading.gif" width="500px" height="230px"></li><li>采用中央控制和局部控制相结合的方法<br><img src="/2020/05/24/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%8E%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/14.png" srcset="/img/loading.gif" width="500px" height="230px"></li></ul><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><ul><li>异步控制方式<ul><li>无基准时标信号</li><li>无固定的周期节拍和严格的时钟同步</li><li>采用应答方式</li></ul></li><li>联合控制方式<ul><li>同步与异步相结合</li></ul></li><li>人工控制方式<ul><li>Reset</li><li>连续和单条指令执行转换开关</li><li>符合停机开关</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="哈夫曼树的基本概念"><a href="#哈夫曼树的基本概念" class="headerlink" title="哈夫曼树的基本概念"></a>哈夫曼树的基本概念</h2><ul><li>哈夫曼树又称为最优树，是一类带权路径长度最短的树，在实际中有广泛的应用。</li><li>路径： 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</li><li>路径长度：路径上的分支数目称作路径的长度</li><li>树的路径长度：从树根到每一结点的路径长度之和</li><li>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述，在数据结构中实体有结点和边两大类，对应有结点权和边权。</li><li>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作$WPL=\displaystyle \sum^{n}_{k=1}{w_k l_k}$.</li><li>哈夫曼树：假设有m个权值{${w_1,w_2…,w_m}$},可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为wi，则其中带权路径长度WPL最小的二叉树称作最优二叉树或哈夫曼树。</li></ul><p>下图所示的三种二叉树都含有四个带权叶子结点，带权结点分别a(8),b(2),c(3),d(6).<br><img src="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1.png" srcset="/img/loading.gif" width="600px" height="200px"></p><p>从图中可以看出，叶子结点所在的位置不同，构成的二叉树WPL也不同，可以直观的发现，在哈夫曼树中，权值越大的结点距离根结点的距离越近。</p><h2 id="哈夫曼树的构造过程"><a href="#哈夫曼树的构造过程" class="headerlink" title="哈夫曼树的构造过程"></a>哈夫曼树的构造过程</h2><ol><li>根据给定的n个权值${w_1,w_2,…w_n}$,构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。</li><li>在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li><li>在森林F中删除这两棵子树，同时将新得到的二叉树加入F中</li><li>重复第二步和第三步，直到F只含一棵树为止，这棵树便是哈夫曼树。</li></ol><p>如下图所示为叶子结点{$a(7),b(5),c(2),d(4)$}的哈夫曼树的构造过程：<br><img src="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/2.png" srcset="/img/loading.gif" width="600px" height="300px"><br>首先对叶子结点的权值进行排序，然后选择权值最小的两个结点分别作为新二叉树的左右子树，新二叉树的根结点为左右子树权值之和，接着依然对新二叉树的根结点与其余两个叶子结点排序，然后再次选择权值最小的两个结点作为左右子树构造新二叉树，直到只剩下最后一棵树，则构造完毕。</p><h2 id="哈夫曼树的存储结构"><a href="#哈夫曼树的存储结构" class="headerlink" title="哈夫曼树的存储结构"></a>哈夫曼树的存储结构</h2><p>哈夫曼树是一种二叉树，可以采用二叉树的存储方法实现，由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的数组中，树中每个结点包含其双亲信息和孩子结点的信息，存储结构可以如下设计：</p><pre><code>typedef struct{    int weight;                    //结点的权值    int parent,lchild,rchild;    //结点的双亲，左孩子，右孩子的下标}HTNode,*HuffmanTree;            //动态分配数组存储哈夫曼树</code></pre><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><ol><li>初始化： 首先动态申请2n个单元，然后循环2n-1次，遍历所有单元，并初始化，再遍历一次，输入前n个单元中叶子结点的权值。</li><li>创建树： 通过循环，选择、删除与合并来创建二叉树。选择当前森林中双亲为0且权值最小的两个树根结点，删除是将两个结点的双亲改为非零，合并是将两个树根结点的权值作为一个新结点的权值依次存入数组n+1之后的单元，记录新结点的下标。</li></ol><h3 id="代码简易实现"><a href="#代码简易实现" class="headerlink" title="代码简易实现"></a>代码简易实现</h3><p>已知叶子节点为{5,29,7,8,14,23,3,11},根据叶子结点构造哈夫曼树。</p><pre><code>typedef struct {    int weight;                    //结点的权值    int parent, lchild, rchild;    //结点的双亲，左孩子，右孩子的下标}HTNode, *HuffmanTree;            //动态分配数组存储哈夫曼树void Select(HuffmanTree HT, int n, int &amp;s1, int &amp;s2) {    s1 = s2 = -1;    int i;    for (i = 0; i &lt; n; ++i) {        if (-1 == HT[i].parent) {            if (-1 == s1) s1 = i;            else {                s2 = i;break;            }        }    }    if (HT[s1].weight &gt; HT[s2].weight) {        int t = s1;        s1 = s2;        s2 = t;    }    for (i += 1; i &lt; n; ++i) {        if (-1 == HT[i].parent) {            if (HT[i].weight &lt; HT[s1].weight) {                s2 = s1;                s1 = i;            }            else if (HT[i].weight &lt; HT[s2].weight) {                s2 = i;            }        }    }    /*测试    cout &lt;&lt; s1 &lt;&lt; s2&lt;&lt;endl;*/}int CreateHuffmanT(HuffmanTree &amp;HT,int wgt[],int n) {    int m = 2 * n - 1;    HT = (HTNode*)malloc(sizeof(HTNode) * m);    for (int i = 0; i &lt; m; i++) {        HT[i].lchild = -1;        HT[i].parent = -1;        HT[i].rchild = -1;        HT[i].weight = wgt[i];    }    for (int i = n; i &lt; m;i++) {        int s1, s2;        Select(HT, i, s1, s2);    //挑选权值最小的两个结点        HT[s1].parent = i;        HT[s2].parent = i;        HT[i].lchild = s1;        HT[i].rchild = s2;        HT[i].weight = HT[s1].weight + HT[s2].weight;    }    return 1;}int main() {    int Weight[] = { 5,29,7,8,14,23,3,11 };    HuffmanTree HT;    CreateHuffmanT(HT, Weight, 8);    for (int i = 0; i &lt; 2 * 8 - 1; i++) {    //输出        cout &lt;&lt; HT[i].weight &lt;&lt; &quot; &quot;&lt;&lt; HT[i].parent &lt;&lt; &quot; &quot; &lt;&lt; HT[i].lchild &lt;&lt; &quot; &quot; &lt;&lt; HT[i].rchild &lt;&lt; endl;    }    getchar();    return 0;}</code></pre><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码，基本思想是：为出现次数较多的字符编以较短的编码，为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码</p><h2 id="编码的两个概念"><a href="#编码的两个概念" class="headerlink" title="编码的两个概念"></a>编码的两个概念</h2><ul><li>前缀编码： 如果在一个编码方案中，任一个编码都不是其他任何编码的前缀，则称编码为前缀编码，前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。</li><li>哈夫曼编码： 一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串称为哈夫曼编码。</li><li>哈夫曼编码是最优前缀编码。</li></ul><p>如果要传输一串字符BACEFGAB，使用普通的编码，如下图所示<br><img src="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/3.png" srcset="/img/loading.gif" width="600px" height="80px"></p><p>真正要传输的二进制代码为：010001011101110111001010，如果传输很长的一篇文章，由于各个字母出现的频率不同，采用这种编码会很长，假设字母出现的频率为A(10),B(8),C(12),D(30),E(20),F(14),G(6),所有字母出现的频率之和为100，可以采用哈夫曼编码的形式，构造哈夫曼树，将权值左分支改为0，右分支改为1，如下图。<br><img src="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/4.png" srcset="/img/loading.gif" width="400px" height="280px"></p><p>由此可根据从树根到叶子的路径来进行编码<br><img src="/2020/05/23/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/5.png" srcset="/img/loading.gif" width="600px" height="80px"></p><p>编码的二进制值为00011001011100100001000001，比之前的编码还长了，但当时是随便规定的字符串频率，如果实际的字符串按照哈夫曼树的权值来出现，比如DECFEEFDCA,编码就会进行压缩0111101001111100101101100，一共25位二进制，如果按照之前的编码需要$3\times 10=30$位二进制，压缩了大概17%左右。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令流水与中断系统</title>
    <link href="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><h2 id="如何提高机器速度"><a href="#如何提高机器速度" class="headerlink" title="如何提高机器速度"></a>如何提高机器速度</h2><ul><li>提高访存速度<ul><li>高速存储芯片</li><li>高速Cachhe</li><li>多体并行结构</li></ul></li><li>提高I/O和主机之间的传送速度<ul><li>中断</li><li>DMA</li><li>通道</li><li>I/O处理机</li><li>多总线结构</li></ul></li><li>提高运算器速度<ul><li>高速芯片</li><li>改进算法</li><li>快速进位链</li></ul></li><li>提高整机处理能力<ul><li>高速器件</li><li>改进系统结构，开发系统的并行性</li></ul></li></ul><h3 id="系统的并行性"><a href="#系统的并行性" class="headerlink" title="系统的并行性"></a>系统的并行性</h3><h4 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h4><ul><li>并发，两个或两个以上事件在同一时间段发生</li><li>同时，两个或两个以上事件在同一时刻发生</li></ul><h3 id="并行性的等级"><a href="#并行性的等级" class="headerlink" title="并行性的等级"></a>并行性的等级</h3><ul><li>过程级(程序、进程)，粗粒度，软件实现。</li><li>指令级(指令之间，指令内部)，细粒度，硬件实现。</li></ul><h2 id="指令流水的原理"><a href="#指令流水的原理" class="headerlink" title="指令流水的原理"></a>指令流水的原理</h2><h3 id="指令的串行执行"><a href="#指令的串行执行" class="headerlink" title="指令的串行执行"></a>指令的串行执行</h3><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/1.png" srcset="/img/loading.gif" width="600px" height="60px"><br>一条指令的执行需要经过三个阶段，取指令、译码、执行，每个阶段都需要花费一个时钟周期，如果没有采用流水线技术，那么执行N条这样的指令就需要3N个时钟周期，假设取指令用取指令部件完成，执行指令用执行指令部件完成，那么总有一个部件空闲，如图所示。</p><h3 id="指令的二级流水"><a href="#指令的二级流水" class="headerlink" title="指令的二级流水"></a>指令的二级流水</h3><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/2.png" srcset="/img/loading.gif" width="300px" height="100px"></p><p>若取指和执行阶段时间上完全重叠，在执行指令1时，取指令部件空闲，用来取指令2，这样可以使指令周期减半，速度提高一倍。</p><h3 id="影响指令流水效率加倍的因素"><a href="#影响指令流水效率加倍的因素" class="headerlink" title="影响指令流水效率加倍的因素"></a>影响指令流水效率加倍的因素</h3><h4 id="执行时间-gt-取指时间"><a href="#执行时间-gt-取指时间" class="headerlink" title="执行时间 &gt; 取指时间"></a>执行时间 &gt; 取指时间</h4><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/3.png" srcset="/img/loading.gif" width="400px" height="100px"></p><h4 id="条件转移指令对指令流水的影响"><a href="#条件转移指令对指令流水的影响" class="headerlink" title="条件转移指令对指令流水的影响"></a>条件转移指令对指令流水的影响</h4><p>必须等上条指令执行结束，才能确定下条指令的地址，造成了时间损失，可以采用猜测法，先不管执行结果，指令部件仍按顺序预取下一条指令，这样，如果条件不成立，转移没有发生，则没有时间损失，若条件成立，转移发生，则所取的指令必须丢掉，再取新的指令。</p><h3 id="指令的六级流水"><a href="#指令的六级流水" class="headerlink" title="指令的六级流水"></a>指令的六级流水</h3><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/4.png" srcset="/img/loading.gif" width="600px" height="300px"></p><p>将指令周期分为取指令(FI)、指令移码(ID)、计算操作数地址(CO)、取操作数(FO)、执行指令(EI)、写操作数(WO)6个阶段，形成了六级流水，完成一条指令需要6个时间单位，串行执行总共需要$6\times 9=54$个时间单位，六级流水需要14个时间单位。</p><h3 id="影响指令流水线性能的因素"><a href="#影响指令流水线性能的因素" class="headerlink" title="影响指令流水线性能的因素"></a>影响指令流水线性能的因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p>不同指令争用同一功能部件产生资源冲突，如下图，指令1与指令4冲突，指令2与指令5冲突，指令1、3、6冲突<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/5.png" srcset="/img/loading.gif" width="600px" height="300px"></p><p>解决办法：</p><ul><li>停顿法，等前面的指令完成操作，后面的指令在进行操作</li><li>指令存储器和数据存储器分开</li><li>指令预取技术，设置缓冲区，空闲的单位提前缓存数据或读取数据，适用于访存周期短的情况</li></ul><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p>在一个程序中，如果必须等前一条指令执行完毕后，后一条指令需要前一条指令执行的结果才能执行，那么这两条指令就是数据相关，不同指令因重叠操作，可能改变操作数的读/写，访问顺序.<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/6.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>解决办法： 后推法，采用旁路技术，旁路技术就是操作结果出来后，直接送入下一条指令，不需要先存入寄存器。</p><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/7.png" srcset="/img/loading.gif" width="300px" height="150px"></p><p>控制相关冲突由转移指令引起，当执行转移指令时，依据转移条件的产生结果，可能顺序执行下一条指令，也可能转移到新的目标地址取指令，从而使流水线发生断流。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/8.png" srcset="/img/loading.gif" width="600px" height="300px"></p><p>解决办法：采用猜测法技术，机器先选定转义分支中的一个，按它取指并处理，条件码生成后，如果猜测正确，那么流水线继续进行下去，如果猜测错误，那么之前预取的指令失效。</p><h2 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a>流水线性能</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>单位时间内流水线所完成指令或输出结果的数量</p><ul><li>设m段的流水线各段时间为Δt</li><li>最大吞吐率$T_{pmax} = 1/Δt$</li><li>实际吞吐率，连续处理n条指令的吞吐率为$T_p=n/(mΔt+(n-1)Δt)$</li></ul><h3 id="加速比-S-p"><a href="#加速比-S-p" class="headerlink" title="加速比$S_p$"></a>加速比$S_p$</h3><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/9.png" srcset="/img/loading.gif" width="600px" height="300px"><br>流水线中各功能段的利用率，由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处在工作状态,效率就是流水线中各功能段的利用率.<br>效率 = 流水线各段处于工作时间的时空区/流水线中各段总的时空区$= mnΔt/m(m+n-1)Δt$</p><h2 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h2><h3 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h3><ul><li>每个时钟周期内可并发多条独立指令，配置多个功能部件</li><li>不能调整指令的执行顺序，通过编译优化技术，把可并行执行的指令搭配起来<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/10.png" srcset="/img/loading.gif" width="600px" height="200px"></li></ul><h3 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h3><ul><li>在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次</li><li>不能调整指令的执行顺序，靠编译程序解决优化问题<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/11.png" srcset="/img/loading.gif" width="600px" height="200px"></li></ul><h3 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h3><ul><li>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。</li><li>采用多个处理部件<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/12.png" srcset="/img/loading.gif" width="600px" height="200px"></li></ul><h3 id="动态流水线"><a href="#动态流水线" class="headerlink" title="动态流水线"></a>动态流水线</h3><p>动态流水线就是多种运算可以同时进行，而静态流水线只能是一种运算进行完在进行下一种运算。</p><h2 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h2><h3 id="指令流水线结构"><a href="#指令流水线结构" class="headerlink" title="指令流水线结构"></a>指令流水线结构</h3><p>完成一条指令分6段，每段需要一个时钟周期。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/13.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>若流水线不出现断流，一个时钟周期出一个结果，不采用流水技术，6个时钟周期出一个结果，理想情况下，6级流水的速度是不采用流水技术的6倍。</p><h3 id="运算流水线"><a href="#运算流水线" class="headerlink" title="运算流水线"></a>运算流水线</h3><p>完成浮点加减运算，可分对阶、尾数求和、规格化三段，每段操作时间尽量一致。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/14.png" srcset="/img/loading.gif" width="400px" height="230px"></p><h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="引起中断的各种因素"><a href="#引起中断的各种因素" class="headerlink" title="引起中断的各种因素"></a>引起中断的各种因素</h3><ol><li>人为设置的中断，如转管指令。</li><li>程序性事故，溢出、操作码不能识别、除法非法</li><li>硬件故障</li><li>I/O设备</li><li>外部事件，用键盘中断现行程序</li></ol><h3 id="中断系统需要解决的问题"><a href="#中断系统需要解决的问题" class="headerlink" title="中断系统需要解决的问题"></a>中断系统需要解决的问题</h3><ol><li>各中断源如何向CPU提出请求？</li><li>各中断源同时提出请求怎么办？</li><li>CPU什么条件、什么时间、以什么方式响应中断？</li><li>如何保护现场？</li><li>如何寻找入口地址?</li><li>如何恢复现场，如何返回？</li><li>处理中断的过程中又出现新的中断怎么办？</li></ol><h2 id="中断请求标记和中断判优逻辑"><a href="#中断请求标记和中断判优逻辑" class="headerlink" title="中断请求标记和中断判优逻辑"></a>中断请求标记和中断判优逻辑</h2><h3 id="中断请求标记-INTR"><a href="#中断请求标记-INTR" class="headerlink" title="中断请求标记(INTR)"></a>中断请求标记(INTR)</h3><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/15.png" srcset="/img/loading.gif" width="400px" height="180px"><br>如何向CPU提出请求，给每一个中断源，配置一个INTR中断请求标记触发器，来判断是否发出了中断请求，多个中断源有多个INTR，这些INTR逻辑上组成了中断请求标记寄存器。<br>INTR可以分散在各个中断源的接口电路中，也可以集中在CPU的中断系统内。</p><h3 id="中断判优逻辑"><a href="#中断判优逻辑" class="headerlink" title="中断判优逻辑"></a>中断判优逻辑</h3><ol><li>硬件实现(排队器)<ul><li>分散在各个中断源的接口电路中，使用链式排队器实现</li><li>集中在CPU内<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/16.png" srcset="/img/loading.gif" width="400px" height="230px"><br>图中INTR_1=1，就可以封住比它级别低的中断源请求，INTR_1=1经过非门电路，会变成0信号，那么通过中间那根线传递给INTR_2等的都是0信号，”&amp;”与门，只要输入端有”0”信号就过不去，所以INTR_1=1时可以封住比它级别低的中断源的请求。</li></ul></li><li>软件实现<br>软件实现中断判优只需要写一段程序，并按中断源的优先等级从高至低逐级查询各中断源是否有中断请求，这样就可以保证CPU首先响应级别高的中断源请求。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/17.png" srcset="/img/loading.gif" width="400px" height="230px"></li></ol><h3 id="中断服务程序入口地址的寻找"><a href="#中断服务程序入口地址的寻找" class="headerlink" title="中断服务程序入口地址的寻找"></a>中断服务程序入口地址的寻找</h3><h4 id="硬件向量法"><a href="#硬件向量法" class="headerlink" title="硬件向量法"></a>硬件向量法</h4><p>利用硬件产生中断向量地址，再由向量地址找到中断服务程序入口地址，向量地址是由中断向量地址形成部件产生的，如何通过向量地址找到中断服务程序入口地址？</p><ul><li>当CPU响应中断时，将向量地址送至PC，执行这条指令，便可无条件转向某服务程序的入口地址。</li><li>设置向量地址表，该表存放在存储单元内，存储单元的地址为向量地址，存储单元内容为中断服务程序入口地址，即中断向量，访问向量地址所指示的存储单元，便可获得入口地址。</li></ul><h4 id="软件查询法"><a href="#软件查询法" class="headerlink" title="软件查询法"></a>软件查询法</h4><p>查询到某一中断请求时，接着安排一条转移指令，直接指向此中断源的中断服务程序入口地址，机器便自动进入中断处理，中断源对应入口地址，由程序员或系统事先确定，下图举例。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/18.png" srcset="/img/loading.gif" width="400px" height="230px"></p><blockquote><p>M是入口地址，SKP是跳过下一条指令，判断D是0还是1</p></blockquote><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><ol><li>响应中断的条件：图中有一个关中断操作，或者称为允许中断触发器EINT，它可被开中断指令置1，也可被关中断指令置0，当允许中断触发器为1时，意味着CPU允许响应中断源的请求，为0时，意味着CPU禁止响应中断。</li><li>响应中断的时间：指令执行周期结束时刻由CPU发查询信号，如果由则进入中断周期，如果没有，则进行下一条指令的取指周期。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/19.png" srcset="/img/loading.gif" width="400px" height="330px"></li></ol><h3 id="中断隐指令"><a href="#中断隐指令" class="headerlink" title="中断隐指令"></a>中断隐指令</h3><ol><li>保护程序断点<br>保护程序断点就是将当前PC的内容保存到特定地址内，也可以存入堆栈</li><li>寻找服务程序入口地址<ul><li>向量地址-&gt;PC (硬件向量法)</li><li>终端识别程序入口地址M-&gt;PC (软件查询法)</li></ul></li><li>硬件关中断<br>CPU进入中断周期意味着CPU响应了某个中断源的请求，为了确保CPU响应该中断后所做的一系列操作不至于再受到新的中断请求的干扰，在该中断周期内必须自动关中断，已禁止CPU再次响应新的中断请求。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/20.png" srcset="/img/loading.gif" width="400px" height="200px"></li></ol><blockquote><p>INT中断标记，EINT允许中断，R-S触发器，单重中断：执行中断服务程序时不允许再发生中断，多重中断：保护程序软硬件状态的过程中，不允许发生中断。</p></blockquote><h3 id="保护现场和恢复现场"><a href="#保护现场和恢复现场" class="headerlink" title="保护现场和恢复现场"></a>保护现场和恢复现场</h3><ul><li>保护现场<ul><li>断点，中断隐指令完成</li><li>寄存器内容，中断服务程序完成</li></ul></li><li>恢复现场，中断服务程序完成<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/21.png" srcset="/img/loading.gif" width="400px" height="230px"></li></ul><h3 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h3><h4 id="多重中断的概念"><a href="#多重中断的概念" class="headerlink" title="多重中断的概念"></a>多重中断的概念</h4><p>当CPU正在执行某个中断服务程序时，另一个中断源右提出了新的中断请求，而CPU又响应了这个新的请求，于是暂停正在运行的中断服务程序，转去执行新的中断服务程序，这称为多重中断，又称为中断嵌套。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/22.png" srcset="/img/loading.gif" width="300px" height="250px"></p><h4 id="实现多重中断的条件"><a href="#实现多重中断的条件" class="headerlink" title="实现多重中断的条件"></a>实现多重中断的条件</h4><ul><li>提前设置开中断指令</li><li>优先级别高的中断源有权中断优先级别高低的中断源<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/23.png" srcset="/img/loading.gif" width="400px" height="250px"></li></ul><h3 id="屏蔽技术"><a href="#屏蔽技术" class="headerlink" title="屏蔽技术"></a>屏蔽技术</h3><h4 id="屏蔽触发器的作用"><a href="#屏蔽触发器的作用" class="headerlink" title="屏蔽触发器的作用"></a>屏蔽触发器的作用</h4><p>每个中断请求触发器都有一个屏蔽触发器，将所有屏蔽触发器组合在一起，便构成了一个屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字，每个中断源都对应一个屏蔽字。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/24.png" srcset="/img/loading.gif" width="400px" height="180px"></p><blockquote><p>MASK=0表示未屏蔽，$MASK_i$表示屏蔽，INTR能被置1，$INTP_i$=0表示不能被排队选中。</p></blockquote><h4 id="屏蔽字"><a href="#屏蔽字" class="headerlink" title="屏蔽字"></a>屏蔽字</h4><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/25.png" srcset="/img/loading.gif" width="400px" height="250px"></p><p>图中可以看出，优先级为5的屏蔽字00001111111111111111表示1、2、3、4都是比它优先级高的，这16位二进制数分别对应16个中断源。</p><h4 id="屏蔽技术可改变处理优先级"><a href="#屏蔽技术可改变处理优先级" class="headerlink" title="屏蔽技术可改变处理优先级"></a>屏蔽技术可改变处理优先级</h4><ul><li>响应优先级，不可改变</li><li>处理优先级，可改变(通过重新设置屏蔽字)</li></ul><p><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/26.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>响应优先级A-&gt;B-&gt;C-&gt;D降序排列<br>处理优先级A-&gt;D-&gt;C-&gt;B降序排列</p><p>CPU执行程序轨迹(原屏蔽字)：<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/27.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>CPU执行程序轨迹(新屏蔽字)：<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/28.png" srcset="/img/loading.gif" width="400px" height="180px"></p><blockquote><p>可以人为地屏蔽某个中断源地请求</p></blockquote><h4 id="新屏蔽字地设置"><a href="#新屏蔽字地设置" class="headerlink" title="新屏蔽字地设置"></a>新屏蔽字地设置</h4><p>保护现场-&gt;设置屏蔽字-开中断-中断服务-关中断-恢复现场-恢复屏蔽字-开中断-中断返回</p><blockquote><p>设置屏蔽字一定在开中断之前。</p></blockquote><h4 id="多重中断地断点保护"><a href="#多重中断地断点保护" class="headerlink" title="多重中断地断点保护"></a>多重中断地断点保护</h4><ol><li>断点进栈，中断隐指令完成</li><li>断点存入”0”地址，中断隐指令完成</li><li>程序断点存入”0”地址的断点保护<br>如果进行三次中断，三个断点都存入”0”地址，为了保证断点不丢失，进行断点保护。<br><img src="/2020/05/21/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/29.png" srcset="/img/loading.gif" width="400px" height="250px"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中央处理器</title>
    <link href="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h1><h2 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h2><p>CPU=运算器+控制器，运算器部分主要对数据进行加工，控制器负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令。<br>控制器还必须能控制程序的输入和运算结果的输出，以及对总线的管理，处理机器的异常情况和特殊请求，即处理中断的能力。</p><ul><li>控制器能自动形成指令地址，发出取指令的命令，将对应地址指令取出，称为指令控制</li><li>取指令后，完成每条指令所需的控制命令，称为操作控制</li><li>控制命令产生后，对各种控制命令加以时间的控制，称为时间控制</li><li>执行过程中，需要进行算术运算和逻辑运算，称为数据加工</li><li>处理特殊请求，需要处理中断的能力，称为中断处理</li></ul><h2 id="CPU与系统总线"><a href="#CPU与系统总线" class="headerlink" title="CPU与系统总线"></a>CPU与系统总线</h2><ol><li>指令控制，PC、IR</li><li>操作控制和时间控制，CU时序电路</li><li>数据加工，ALU寄存器</li><li>处理中断，中断系统</li></ol><p><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h2 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h2><h3 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h3><ul><li>通用寄存器，存放操作数，可作某种寻址方式所需的专业寄存器</li><li>数据寄存器，存放操作数，两个寄存器拼接存放双倍字长数据</li><li>地址寄存器，存放地址，其位数应满足最大地址范围，用于特殊的寻址方式，段基址，栈指针</li><li>条件码寄存器，也叫程序状态字寄存器，存放由算术指令和逻辑指令运行或测试的条件码，如运算结果进位标志、运算结果溢出标志等，可做程序分支的依据，如正、负、零、溢出、进位等</li></ul><h3 id="控制器中的寄存器"><a href="#控制器中的寄存器" class="headerlink" title="控制器中的寄存器"></a>控制器中的寄存器</h3><ul><li>程序计数器PC，确定下一条指令的地址，对用户可见</li><li>指令寄存器IR，保存当前正在执行的指令，用户不可见</li><li>存储器数据寄存器MDR，暂时存放由主存读出的一条指令或数据字，用户不可见</li><li>存储器地址寄存器MAR，保存当前CPU所访问的内存单元的地址，用户不可见</li></ul><h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><h2 id="指令周期的概念"><a href="#指令周期的概念" class="headerlink" title="指令周期的概念"></a>指令周期的概念</h2><p>CPU取出并执行一条指令所需的全部时间，即CPU完成一条指令的时间，称为指令周期。指令周期被划分为几个不同阶段，每个阶段所需时间称为机器周期、CPU工作周期或基本周期，通常等于取指时间或访存时间，时钟周期是时钟频率的倒数，也称为节拍脉冲或T周期。</p><ul><li>每条指令的指令周期不同<br><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li><p>具有间接寻址的指令周期<br><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>在间接寻址时，需要多访问一次存储器取出有效地址。</p></li><li><p>带有中断周期的指令周期<br><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>当CPU采用中断方式实现主存和I/O交换信息时，CPU在每条指令的执行周期结束前，都要发出中断查询信号，以检测是否有I/O提出请求。如果有请求，CPU要进入中断响应阶段，称为中断周期。</p></li></ul><h2 id="指令周期流程"><a href="#指令周期流程" class="headerlink" title="指令周期流程"></a>指令周期流程</h2><p><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h2 id="CPU工作周期的标志"><a href="#CPU工作周期的标志" class="headerlink" title="CPU工作周期的标志"></a>CPU工作周期的标志</h2><p>CPU访存有四种性质：</p><ul><li>取指令，取指周期</li><li>取地址，间址周期</li><li>存取操作数或结果，执行周期</li><li>存程序断点，中断周期<br><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ul><h2 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h2><h3 id="取指周期数据流"><a href="#取指周期数据流" class="headerlink" title="取指周期数据流"></a>取指周期数据流</h3><p><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>PC存放下一条指令的地址，首先PC将下一条指令的地址送入MAR，MAR将地址经过地址总线送入存储器，然后存储器已经知道了这条指令的地址，然后进行读操作，由CU控制，CU把控制信号送到控制总线，由控制总线送到存储器，然后存储器执行读操作，将相应的数据送到数据总线，经过数据总线送入MDR，再由MDR送入IR。<br>如果下一条指令没有跳转，那么下一条指令的地址就是PC+1，由CU控制+1操作，将+1之后的PC指保存进PC中，为下一条指令做准备。</p><h3 id="间址周期数据流"><a href="#间址周期数据流" class="headerlink" title="间址周期数据流"></a>间址周期数据流</h3><p><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>间址周期表示当前要执行的指令采用间接寻址的方式，假设要取的操作数地址的内存单元的地址保存在MDR中，首先将MDR的地址码部分送入MAR中，取出这条指令所需操作数的内存单元的地址，MAR将地址送入地址总线，经过地址总线送入存储器，CU发出读操作，操作信号送入控制总线，在送入存储器，存储器执行读操作，将相应的数据送入数据总线，此时的数据其实是一个地址，是这条指令所需要的操作数所在的内存单元的地址，在经过地址总线送入MDR，这样MDR保存了真正需要的操作数的地址</p><h3 id="中断周期数据流"><a href="#中断周期数据流" class="headerlink" title="中断周期数据流"></a>中断周期数据流</h3><p>中断周期包括三部分：</p><ul><li>保存断点</li><li>形成中断服务程序的入口地址</li><li>硬件关中断</li></ul><p><img src="/2020/05/20/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>由CU决定将断点保存在哪个内存单元，CU形成地址，将地址送入MAR，MAR经过地址总线将地址存入存储器，保存断点是一个写操作，CU会向存储器发送写命令，保存断点是保存当前PC的值，PC将地址送入MDR，由MDR送入数据总线，在保存入存储器中，这样就完成了保存断点的过程。中断服务程序的入口地址由CU给出，CU直接将该地址送入PC中</p><blockquote><p>不同指令的执行周期操作命令不同，没有统一格式。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构之树"><a href="#数据结构之树" class="headerlink" title="数据结构之树"></a>数据结构之树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树的结构是一个递归的定义，树是以分支关系定义的层次结构，树(Tree)是$n(\geq 0)$个结点的有限集，它或为空树(n=0)，或为非空树，对于非空树T：</p><ol><li>有且仅有一个称之为根的结点.</li><li>除根结点以外的其余结点可分为m(m&gt;0)个互不相交的有限集$T_1,T_2,…,T_m$其中每个集合本身又是一棵树，并且称为根的子树.</li></ol><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><ul><li><strong>结点</strong>：树中的一个独立单元，包含一个数据元素及若干指向其子树的分支。</li><li><strong>结点的度</strong>：结点拥有的子树数称为结点的度。</li><li><strong>树的度</strong>：树的度是树内各结点度的最大值。</li><li><strong>叶子</strong>：度为0的结点称为叶子或终端结点。</li><li><strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点，除根节点之外，非终端结点也称为内部结点。</li><li><strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲。</li><li><strong>兄弟</strong>：同一个双亲的孩子之间互称兄弟。</li><li><strong>祖先</strong>：从根到该结点所经分支上的所有结点</li><li><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙</li><li><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，树中任一结点的层次等于其双亲结点的层次加1。</li><li><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟。</li><li><strong>树的深度</strong>：树中结点的最大层次称为树的深度或高度。</li><li><strong>有序树和无序树</strong>：如果将树中结点的各子树看成从左到右是有次序的(即不能互换),则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</li><li><strong>森林</strong>：森林是m棵互不相交的树的集合，对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</li><li>任何一棵树都是一个二元组Tree(root,F),其中root是根结点，F是m棵树的森林。</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树(Binary Tree)是$n(n\geq 0)$个结点所构成的集合，它或为空树(n=0)，或为非空树，对于非空树T：</p><ul><li>有且仅有一个称之为根的结点</li><li>除根结点以外的其余结点分为两个互不相交的子集$T_1$和$T_2$,分别称为T的左子树和右子树，且$T_1$和$T_2$本身又都是二叉树</li></ul><h2 id="二叉树与树的区别"><a href="#二叉树与树的区别" class="headerlink" title="二叉树与树的区别"></a>二叉树与树的区别</h2><ul><li>二叉树每个结点至多只有两棵子树，即二叉树中不存在度大于2的结点。</li><li>二叉树的子树有左右之分，其次序不能任意颠倒</li></ul><h2 id="树与二叉树ADT定义"><a href="#树与二叉树ADT定义" class="headerlink" title="树与二叉树ADT定义"></a>树与二叉树ADT定义</h2><h3 id="树的ADT定义"><a href="#树的ADT定义" class="headerlink" title="树的ADT定义"></a>树的ADT定义</h3><pre><code>InitTree(&amp;T)    //构造空树TDestroyTree(&amp;T)    //销毁树CreateTree(&amp;T,definition)    //definiton给出树T的定义，按照定义构造树TClearTree(&amp;T)        //将树T清为空树TreeEmpty(T)        //树存在，若T为空树，则返回true，否则falseTreeDepth(T)        //返回T的深度Root(T)                //返回T的根Value(T,cur_e)        //返回cur_e结点的值Assign(T,cur_e,value)    //结点cur_e赋值为valueParent(T,cur_e)        //若cur_e是T的非根结点，返回它的双亲Leftchild(T,cur_e)    //若cur_e是T的非叶子结点，返回它的左孩子RightSibling(T,cur_e)    //若cur_e有右兄弟，返回它的右兄弟InsertChild(&amp;T,p,i,c)    //p指向T中某个结点，$1\leq i\leq p$所指结点的度+1，非空树c与T不相交，插入c为T中p所指结点的第i棵子树。DeleteChild(&amp;T,p,i)        //p指向T中某个结点，$1\leq i\leq p$指结点的度，删除T中p所指结点的第i棵子树TraverseTree(T)        //树T存在，按某种次序对T的每个结点访问一次.</code></pre><h3 id="二叉树的ADT定义"><a href="#二叉树的ADT定义" class="headerlink" title="二叉树的ADT定义"></a>二叉树的ADT定义</h3><pre><code>InitBiTree(&amp;T)    //构造空树TDestroyBiTree(&amp;T)    //销毁树CreateBiTree(&amp;T,definition)    //definiton给出树T的定义，按照定义构造树TClearBiTree(&amp;T)        //将树T清为空树BiTreeEmpty(T)        //树存在，若T为空树，则返回true，否则falseBiTreeDepth(T)        //返回T的深度Root(T)                //返回T的根Value(T,cur_e)        //返回cur_e结点的值Assign(T,cur_e,value)    //结点cur_e赋值为valueParent(T,cur_e)        //若cur_e是T的非根结点，返回它的双亲Leftchild(T,cur_e)    //若cur_e是T的非叶子结点，返回它的左孩子RightSibling(T,cur_e)    //若cur_e有右兄弟，返回它的右兄弟InsertChild(&amp;T,p,i,c)    //p指向T中某个结点，$1\leq i\leq p$所指结点的度+1，非空树c与T不相交，插入c为T中p所指结点的第i棵子树。DeleteChild(&amp;T,p,i)        //p指向T中某个结点，$1\leq i\leq p$指结点的度，删除T中p所指结点的第i棵子树PreOrderTraverse(T)    //先序遍历InOrderTraverse(T)    //中序遍历PostOrderTraverse(T)    //后序遍历LevelOrderTraverse(T)    //层序遍历</code></pre><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul><li>在二叉树的第i层上至多有$2^{i-1}$个结点</li><li>深度为k的二叉树至多有$2^k-1$个结点</li><li>对任何一棵二叉树T，如果其终端结点树为$n_0$,度为2的结点数为$n_2$,则$n_0=n_2+1$.</li></ul><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul><li>深度为k且含$2^k-1$个结点的二叉树。</li><li>每一层上的结点数都是最大结点数，即每一层i的结点数都具有最大值$2^{i-1}$</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应，称之为完全二叉树，特点如下：</p><ul><li>叶子结点只可能在层次最大的两层上出现；</li><li>对于任一结点若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1.</li><li>具有n个结点的完全二叉树的深度为$[log_2n]+1$.</li><li>如果对一棵有n个结点的完全二叉树的结点按层序编号，(第一层到第$[log_2n]+1$层，每层从左到右)，则对任一结点i：<ul><li>如果i=1，结点i是二叉树的根，无双亲，如果i&gt;1，则其双亲是结点[i/2]</li><li>如果2i&gt;n,则结点i无左孩子，否则其左孩子是结点2i</li><li>如果2i+1&gt;n，则结点i无右孩子，否则其右孩子是结点2i+1</li></ul></li></ul><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><pre><code>#define MAXTSIZE 100    //二叉树的最大结点数typedef TElemType SqBiTree[MAXTSIZE] //0号单元存储根结点SqBiTree bt;</code></pre><p>顺序存储结构使用一组地址连续的存储单元存储数据元素，为表示结点间的逻辑关系，需要按一定次序存放在数组中，这里按层序存储如下：<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" srcset="/img/loading.gif" width="450px" height="280px"></p><p>图示是一棵满二叉树也是完全二叉树，对于完全二叉树，只要从根起按层序存储即可，依次从上而下，从左至右存储元素，而对于一般二叉树，如果用顺序存储结构，会非常浪费空间，如下图所示：<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" srcset="/img/loading.gif" width="450px" height="280px"></p><p>由此可见这种顺序存储结构仅适用于完全二叉树，因为在最坏情况下一个深度为k的k个结点的单支树，需要$2^k-1$的一维数组来存放，对于一般的二叉树，通常使用链式存储更为合适。</p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><pre><code>typedef struct BiNode{    TElemType data;        //结点数据域    struct BiTNode *lchild,*rchild;    //左右孩子指针}BiTNode,*BiTree;</code></pre><p>二叉树链式存储结构的结点由一个数据元素和分别指向左、右子树的两个指针构成，有时为了便于找到结点的双亲，还可在结点结构中增加一个指向双亲的结点指针域，这两种存储结构分别称为二叉链表和三叉链表。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul><li>先序遍历<br>先访问根结点，再先序遍历左子树，然后先序遍历右子树</li><li>中序遍历<br>先中序遍历左子树，再访问根结点，最后中序遍历右子树</li><li>后序遍历<br>先后序遍历左子树，再后序遍历右子树，最后访问根结点</li><li>递归遍历<br>初始化一个栈存s放根节点，如果根节点不为空，则根节点入栈，循环遍历根的左子树，如果根节点为空，s退栈，然后访问s的数据，循环遍历根的右子树。</li></ul><h3 id="遍历代码示例"><a href="#遍历代码示例" class="headerlink" title="遍历代码示例"></a>遍历代码示例</h3><pre><code>//先序void PreOrderTraverse(Bitree T){    if (T){        visit(T-&gt;data, level);        PreOrderTraverse(T-&gt;ltree);        PreOrderTraverse(T-&gt;rtree);    }}//中序void PreOrderTraverse(Bitree T){    if (T){        PreOrderTraverse(T-&gt;ltree);        visit(T-&gt;data, level);        PreOrderTraverse(T-&gt;rtree);    }}//后续void PreOrderTraverse(Bitree T){    if (T){        PreOrderTraverse(T-&gt;ltree);        PreOrderTraverse(T-&gt;rtree);        visit(T-&gt;data, level);    }}//中序遍历非递归算法void InOrderTraverse(BiTree t) {    stack&lt;BiTree&gt; s;    BiTree p = t;    BiTNode *q = new BiTNode;    while (p || !s.empty()) {        if (p) {            s.push(p);            p = p-&gt;leftChild;        }        else {            q = s.top();            s.pop();            cout &lt;&lt; q-&gt;data;            p = q-&gt;rightChile;        }    }}//层序遍历</code></pre><h3 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h3><ol><li>先序和中序序列可以唯一确定二叉树</li><li>后序和中序序列可以唯一确定二叉树</li><li>先序和后序无法唯一确定二叉树，因为后序序列先访问左再访问右，如AB,BA，无法确定B是左子树还是右子树。</li></ol><h3 id="先序遍历的顺序建立二叉链表"><a href="#先序遍历的顺序建立二叉链表" class="headerlink" title="先序遍历的顺序建立二叉链表"></a>先序遍历的顺序建立二叉链表</h3><p>算法步骤:</p><ul><li>扫描字符序列，读入字符ch</li><li>如果ch是一个’ ‘字符，则表明该二叉树为空树，否则<ul><li>申请一个 结点空间</li><li>给结点数据赋值</li><li>递归创建左子树</li><li>递归创建右子树</li></ul></li></ul><h3 id="二叉树简易代码示例"><a href="#二叉树简易代码示例" class="headerlink" title="二叉树简易代码示例"></a>二叉树简易代码示例</h3><pre><code>typedef struct BiTNode {    char data;    struct BiTNode *leftChild, *rightChile;}*BiTree,BiTNode;int CreateTree(BiTree *t) {            //先序创建二叉树    char c;    scanf_s(&quot;%c&quot;, &amp;c,1);    if (c == &#39; &#39;) {        *t = NULL;    }    else {        *t = (BiTNode *)malloc(sizeof(BiTNode));        (*t)-&gt;data = c;        //t是指向BiTree的指针， *t表示BiTree，BiTree是指向BiTNode的指针,*t = *BiTNode        CreateTree(&amp;(*t)-&gt;leftChild);        CreateTree(&amp;(*t)-&gt;rightChile);    }    return 1;}int Traverval(BiTree t) {            //先序遍历    if (t) {        printf(&quot;%c&quot;, t-&gt;data);        Traverval(t-&gt;leftChild);        Traverval(t-&gt;rightChile);    }    return 0;}void InOrderTraverse(BiTree t) {    //中序遍历的非递归算法    stack&lt;BiTree&gt; s;    BiTree p = t;    BiTNode *q = new BiTNode;    while (p || !s.empty()) {        if (p) {            s.push(p);            p = p-&gt;leftChild;        }        else {            q = s.top();            s.pop();            cout &lt;&lt; q-&gt;data;            p = q-&gt;rightChile;        }    }}void Copy(BiTree t, BiTree &amp;tre) {    //复制二叉树    if (!t) {        tre = NULL;    }    else{        tre = new BiTNode;        tre-&gt;data = t-&gt;data;        Copy(t-&gt;leftChild, tre-&gt;leftChild);        Copy(t-&gt;rightChile, tre-&gt;rightChile);    }}int Depth(BiTree t) {                //计算深度    if (!t)return 0;    else {        int m = Depth(t-&gt;leftChild);        int n = Depth(t-&gt;rightChile);        return m &gt; n ? m + 1 : n + 1;    }}int NodeCount(BiTree t) {            //统计结点    if (!t) {        return 0;    }    else{        return 1 + NodeCount(t-&gt;leftChild) + NodeCount(t-&gt;rightChile);    }}//测试样例输出&#39;A&#39;,&#39;B&#39;,&#39; &#39;,&#39; &#39;,&#39;C&#39;,&#39; &#39;,&#39; &#39;;//输出ABCint main() {    BiTree t = NULL;    CreateTree(&amp;t);    Copy(t, s);    InOrderTraverse(s);    cout&lt;&lt;Depth(t)&lt;&lt; NodeCount(t);    Traverval(t);    getchar();    return 0;}</code></pre><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>在普通的二叉树中，不论二叉树形态如何，子叶的左右指针域必然为空，也就是空链域的个数总是多过非空链域的个数，n个结点的二叉链表共有2n个链域，非空链域为n-1个，空链域为n+1个。<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" srcset="/img/loading.gif" width="650px" height="300px"></p><p>为了有效利用空链域，当对二叉树进行中序遍历时可以得到二叉树得中序序列为DBEAFCG,可以直观得看出各结点得前驱和后继，但这种关系只能在遍历中得知，因此在建立二叉树时如果记录前驱后继得关系，在后续的遍历会很方便。<br>现在将二叉树结点中多加两个标志位：</p><ul><li>LTag，0表示链接lchild域结点的左孩子，1表示链接lchild域结点的前驱</li><li>RTag，0表示链接lchild域结点的右孩子，1表示链接rchild域结点的后继</li></ul><p>试做如下规定：</p><ul><li>若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱。</li><li>若结点有右子树，则其rchild域指示其后孩子，否则令rchild域指示其后继。</li></ul><p><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" srcset="/img/loading.gif" width="650px" height="300px"><br>经过链接后，二叉链表的空链域得到了充分的利用,将这种存储结构称为线索链表，将空指针的连接方式称为二叉树的线索化，结构代码如下：</p><pre><code>typedef enum {Link,Thread} Pointertag;    //Link链接，Thread线索typedef struct BitNode{    char data;    struct BitNode *ltree, *rtree;    Pointertag rtag;    Pointertag ltag;}BitNode, *BitTree;</code></pre><h4 id="二叉树的中序线索化"><a href="#二叉树的中序线索化" class="headerlink" title="二叉树的中序线索化"></a>二叉树的中序线索化</h4><p>线索化的过程其实是修改空指针的过程，为了记录遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点，由此记录遍历过程中访问结点的关系。<br>算法步骤：</p><ul><li>如果p非空，左子树递归线索化。</li><li>如果p的左孩子为空，则给p加上左线索，将Ltag置为1，让p的左孩子指向pre，否则将p的Ltag置为0.</li><li>如果pre的右孩子为空，则给pre加上右线索，将其Rtag置为1，让pre的右孩子指向p，否则将pre的Rtag置为0.</li></ul><pre><code>BitTree pre;                        //指向刚刚访问过的节点void InThreading(BitTree tree)        //中序遍历进行线索化{    if (tree){        InThreading(tree-&gt;ltree);        if (!tree-&gt;ltree){            tree-&gt;ltag = Thread;            tree-&gt;ltree = pre;        }        if (!pre-&gt;rtree){            pre-&gt;rtag = Thread;            pre-&gt;rtree = tree;        }        pre = tree;        InThreading(tree-&gt;rtree);    }}int InOrderThread_Head(BitTree *head, BitTree tree)    ///添加头节点的线索化{    (*head) = (BitTree)malloc(sizeof(BitNode));        if ((*head) == NULL){        return 0;    }    (*head)-&gt;rtree = *head;    (*head)-&gt;rtag = Link;    if (!tree){        (*head)-&gt;ltree = *head;        (*head)-&gt;ltag = Link;    }    else{        pre = *head;        (*head)-&gt;ltree = tree;        (*head)-&gt;ltag = Link;        InThreading(tree);        pre-&gt;rtree = *head;        pre-&gt;rtag = Thread;        (*head)-&gt;rtree = pre;    }}</code></pre><h4 id="遍历中序线索二叉树"><a href="#遍历中序线索二叉树" class="headerlink" title="遍历中序线索二叉树"></a>遍历中序线索二叉树</h4><p>二叉树经过线索化之后，实际上相当于将二叉树转化成了一个双向链表，遍历方式也非常简单，算法步骤如下：</p><ul><li>指针p指向根节点</li><li>p为非空树或遍历未结束，循环以下操作<ul><li>沿左孩子向下，到达最左结点，访问此结点</li><li>沿右线索反复查找当前结点的后继结点并访问，直至右线索为0或遍历结束。</li><li>转向p的右子树，沿右子树的左孩子向下，重复此过程。</li></ul></li></ul><p>遍历过程如下：<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/5.png" srcset="/img/loading.gif" width="650px" height="300px"></p><hr><p>代码示例：</p><pre><code>    void InOrderThreading(BitTree tree) {        BitTree p = tree-&gt;ltree;        while (p != tree){            while (p-&gt;ltag == Link){    //到达最左结点                p = p-&gt;ltree;            }            printf(&quot;%c&quot;, p-&gt;data);            while (p-&gt;rtag == Thread &amp;&amp; p-&gt;rtree != tree){    //访问后继结点                p = p-&gt;rtree;                printf(&quot;%c&quot;, p-&gt;data);            }            p = p-&gt;rtree;        }    }</code></pre><h4 id="线索二叉树总代码示例"><a href="#线索二叉树总代码示例" class="headerlink" title="线索二叉树总代码示例"></a>线索二叉树总代码示例</h4><pre><code>typedef enum {Link,Thread} Pointertag;        //Link链接，Thread线索typedef struct BitNode{    char data;    struct BitNode *ltree, *rtree;    Pointertag rtag;    Pointertag ltag;}BitNode, *BitTree;BitTree pre;                                //指向刚刚访问过的节点//前序创建二叉树void CreatBitTree(BitTree *tree){    char c;    scanf_s(&quot;%c&quot;, &amp;c, 1);    if (&#39; &#39; == c){        *tree = NULL;    }    else{        *tree = (BitTree)malloc(sizeof(BitNode));        (*tree)-&gt;data = c;        (*tree)-&gt;rtag = Link;        (*tree)-&gt;ltag = Link;        CreatBitTree(&amp;((*tree)-&gt;ltree));        CreatBitTree(&amp;((*tree)-&gt;rtree));    }}//中序遍历进行线索化void InThreading(BitTree tree){    if (tree){        InThreading(tree-&gt;ltree);        if (!tree-&gt;ltree){            tree-&gt;ltag = Thread;            tree-&gt;ltree = pre;        }        if (!pre-&gt;rtree){            pre-&gt;rtag = Thread;            pre-&gt;rtree = tree;        }        pre = tree;        InThreading(tree-&gt;rtree);    }}//添加头节点int InOrderThread_Head(BitTree *head, BitTree tree){    (*head) = (BitTree)malloc(sizeof(BitNode));        if ((*head) == NULL){        return 0;    }    (*head)-&gt;rtree = *head;    (*head)-&gt;rtag = Link;    if (!tree){        (*head)-&gt;ltree = *head;        (*head)-&gt;ltag = Link;    }    else{        pre = *head;        (*head)-&gt;ltree = tree;        (*head)-&gt;ltag = Link;        InThreading(tree);        pre-&gt;rtree = *head;        pre-&gt;rtag = Thread;        (*head)-&gt;rtree = pre;    }}//遍历二叉树void InOrderThreading(BitTree tree) {    BitTree p = tree-&gt;ltree;    while (p != tree){        while (p-&gt;ltag == Link){            p = p-&gt;ltree;        }        printf(&quot;%c&quot;, p-&gt;data);        while (p-&gt;rtag == Thread &amp;&amp; p-&gt;rtree != tree){            p = p-&gt;rtree;            printf(&quot;%c&quot;, p-&gt;data);        }        p = p-&gt;rtree;    }}//测试int main(){    BitTree mytree;    BitTree temp;    CreatBitTree(&amp;mytree);    InOrderThread_Head(&amp;temp, mytree);    InOrderThreading(temp);    system(&quot;pause&quot;);    return 0;}</code></pre><h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置，双亲表示法的结点形式如下图<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/6.png" srcset="/img/loading.gif" width="180px" height="50px"></p><p>下图所示是一棵树及其双亲表示的存储结构<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/7.png" srcset="/img/loading.gif" width="330px" height="250px"><br>这种存储结构的优点是求结点的双亲和根比较方便，但求结点的孩子时需要遍历整个结构，可以对结点进行改进，比如增加左右兄弟的指针域用来指示兄弟的位置。</p><p><strong>双亲表示法结构定义代码</strong></p><pre><code>#define MAX_SIZE 100typedef int TElemType;                //结点数据类型typedef struct PTNode{    TElemType data;                    //结点数据    int parent;                        //双亲位置}PTNode;typedef struct{                        //树结构    PTNode nodes[MAX_TREE_SIZE];    //结点数组    int r,n;                        //根的位置和结点数}PTree;</code></pre><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>由于树中每个结点可能有多棵子树，可以使用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点，这种方法叫做多重链表表示法，由于树的每个结点的度不同，可以设计两种方案来解决。</p><ul><li>方案一，指针域的个数就等于树的度，但是如果树中各结点的度相差很大时，显然是浪费空间的，因为很多结点并没有利用，如下图所示<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/8.png" srcset="/img/loading.gif" width="430px" height="250px"></li><li>方案二，针对方案一进行改进，这种方案每个结点指针域的个数等于该结点的度，额外使用一个位置来存储结点指针域的个数，这种方法克服了浪费空间的缺点，但由于各结点的链表结构不同，在运算上会带来时间的损耗，方法实现如下图<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/9.png" srcset="/img/loading.gif" width="430px" height="250px"></li><li>孩子表示法，上述方案都有缺点，因此有了第三种方案，也就是孩子表示法，具体是将每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，如下图所示<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/10.png" srcset="/img/loading.gif" width="430px" height="250px"></li></ul><p>这种结构方便查找某个结点的孩子、兄弟等，遍历整棵树也十分方便，孩子表示法结构定义代码</p><pre><code>#define MAX_TREE_SIZE 100typedef struct CTNode{    //孩子结点    int child;    struct CTNode *next;}*ChildPtr;typedef struct{            //表头结构    TElemType data;    ChildPtr firstchild;    //头指针域，存储该结点的孩子链表的头指针}CTBox;typedef struct{            //树结构    CTBox nodes[MAX_TREE_SIZE];    int r,n;            //根的位置和结点数}CTree;</code></pre><p>这种结构的缺点是如果要知道某个结点的双亲，需要遍历整个树，因此可以将双亲表示法和孩子表示法结合起来，也被称为双亲孩子表示法，如下图所示<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/11.png" srcset="/img/loading.gif" width="430px" height="250px"></p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>上述的方案是从双亲和孩子的角度考虑树的存储结构，如果从树结点的兄弟考虑，会发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此可以设置两个指针，分别指向该结点的第一个孩子和其结点的右兄弟，结构代码如下：</p><pre><code>typedef struct CSNode{    TElemType data;    struct CSNode *firstchild,*rightsib;}CSNode,*CSTree;</code></pre><p><strong>方法实现如图所示</strong><br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/12.png" srcset="/img/loading.gif" width="330px" height="250px"></p><p>这种结构只需要通过firstchild找到结点的长子，再通过长子结点的rightsib找到其兄弟结点，可以在此结构上增加一个parent指针域来快速查找双亲，这种表示法最大的好处是把一棵复杂的树变成了二叉树，便于利用二叉树的算法来实现对树的操作，上图经过变形后，如下图所示：<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/13.png" srcset="/img/loading.gif" width="330px" height="250px"></p><h2 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><ol><li>加线，在所有兄弟结点之间加一条线</li><li>去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定角度，使结构层次分明，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/14.png" srcset="/img/loading.gif" width="330px" height="250px"></li></ol><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以可以理解为，森林中的每一棵树都是兄弟，转化步骤如下</p><ol><li>把每个树转换为二叉树</li><li>第一棵二叉树不动，第二棵树起，依次将后一棵二叉树的根结点作为前一棵树的根结点的右孩子，用线连接，就得到了二叉树。<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/15.png" srcset="/img/loading.gif" width="330px" height="250px"></li></ol><h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><p>一棵二叉树够转换成一棵树还是森林，需要看其根节点是否有右孩子，有就是森林，没有就是一棵树，转换森林步骤如下：</p><ol><li>从根节点开始，若右孩子存在，把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，这是一个递归过程，直到所有右孩子连线全部删除，即得到分离的二叉树</li><li>将每棵分离后的二叉树转换为树，即构成森林<br><img src="/2020/05/18/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/16.png" srcset="/img/loading.gif" width="330px" height="250px"></li></ol><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><p>树的遍历分为两种方式</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li></ol><p>森林的遍历也分两种方式</p><ol><li>前序遍历，先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式遍历除去第一棵树的剩余树构成的森林。</li><li>后序遍历，先访问森林中第一棵树，后根遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ol><blockquote><p>森林的前序遍历和二叉树前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻址方式与RISC技术</title>
    <link href="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>寻址方式确定本条指令的操作数地址，或者下一条要执行指令的指令地址，指令的地址码字段往往不是操作数真实的地址，而是形式地址，用A表示。形式地址结合指令的寻址方式可以计算出操作数的真实地址，称为有效地址用EA表示。<br>(PC)表示寄存器PC的数值，不加括号表示存储介质或编码。<br>寻址方式分为指令寻址和数据寻址。</p><ul><li>确定指令存放位置的过程称为指令寻址方式</li><li>确定操作数存放位置的过程称为数据寻址方式</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>找到下一条将要执行指令的地址，称为指令寻址，指令基本上按执行顺序存放在主存中，执行过程中，指令总是从内存单元被取到指令寄存器IR中。</p><ul><li>顺序寻址，(PC)+1-&gt;PC</li><li>跳跃寻址，由转移指令指出<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/1.png" srcset="/img/loading.gif" width="450px" height="230px"></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>找到当前正在执行指令的数据地址，称为数据寻址。起始数据被存放在内存中，在指令执行的过程中，内存的数据可能被装入其他地方，所以数据的寻址涉及寄存器、内存单元、堆栈、I\O端口、立即数的访问。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="350px" height="50px"></p><p>形式地址：指令字中的地址<br>有效地址：操作数的真实地址<br>约定 指令字长=存储子长=机器字长</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>这个寻址方式直接给出操作数，不需要给出地址去其他地方找操作数。<br>优点：只需要取出指令，便可立即获得操作数，采用立即寻址特征的指令只需要取指令时访问存储器，而在执行阶段不必再访问存储器。<br>缺点：由于A表示的就是立即数 ，因此A的位数限制了立即数表示的范围，例如，A占8位，则立即数的表示范围为-128-127，因为立即数都是补码表示的。<br>立即寻址方式通常用于对某寄存器或内存单元赋初值。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="300px" height="100px"></p><ul><li>形式地址A就是操作数</li><li>指令执行阶段不访存</li><li>A的位数限制了立即数的范围</li></ul><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>通过直接寻址给出的地址取到操作数，然后再将操作数送往运算器或其他地方。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="300px" height="100px"></p><ul><li>EA=A,有效地址由形式地址直接给出</li><li>执行阶段访问一次存储器</li><li>A的位数决定了该指令操作数的寻址范围</li><li>操作数的地址不易修改，只能修改A</li></ul><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>隐含寻址指指令字中不明显地给出操作数地址，其操作数地址隐含在操作码或某个寄存器中。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="360px" height="220px"></p><ul><li>操作数地址隐含在操作码中</li><li>指令字中少了一个地址字段，可缩短指令字长</li></ul><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>直接寻址的地址码字段A的位数较小，因此寻址范围较小，间接寻址可以解决这个问题。<br>直接寻址是直接给出操作数的有效地址，即直接可以通过该地址找到操作数，但间接寻址指令给出的地址是操作数的有效地址的地址。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="360px" height="220px"></p><ul><li>EA=(A)，有效地址由形式地址间接提供</li><li>执行指令阶段2次访存</li><li>可扩大寻址范围</li><li>便于编制程序</li></ul><h4 id="间接寻址编程举例"><a href="#间接寻址编程举例" class="headerlink" title="间接寻址编程举例"></a>间接寻址编程举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="360px" height="220px"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>与直接寻址类似，在直接寻址的指令字中，地址码字段给出的是主存的地址，而在寄存器寻址的指令字中，地址码字段直接给出了寄存器编号Ri，则操作数的有效地址EA=Ri。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="250px" height="280px"></p><ul><li>EA=R_i，有效地址即为寄存器编号</li><li>执行阶段不访存，只访问寄存器，执行速度快</li><li>寄存器个数有限，可缩短指令字长</li></ul><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(R_i)，有效地址在寄存器中</li><li>有效地址在寄存器中，操作数在寄存器中，执行阶段访存</li><li>便于编址循环程序</li></ul><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>操作数的有效地址需要通过某个基础地址来形成，基础地址需要设置一个基址寄存器(BR)，其操作数的有效地址EA等于指令字中的形式地址A与基址寄存器中的内容相加。<br>优点： 扩大操作数的寻址范围，便于解决多道程序问题。</p><h4 id="采用专用寄存器作基址寄存器"><a href="#采用专用寄存器作基址寄存器" class="headerlink" title="采用专用寄存器作基址寄存器"></a>采用专用寄存器作基址寄存器</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA = (BR)+A，BR为基址寄存器</li><li>可扩大寻址范围</li><li>有利于多道程序</li><li>BR内容由操作系统或管理程序确定</li><li>在程序的执行过程中BR内容不变，形式地址A可变</li></ul><h4 id="采用通用寄存器作基址寄存器"><a href="#采用通用寄存器作基址寄存器" class="headerlink" title="采用通用寄存器作基址寄存器"></a>采用通用寄存器作基址寄存器</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>由用户指定哪个通用寄存器作为基址寄存器</li><li>基址寄存器的内容由操作系统确定</li><li>在程序的执行过程中R0内容不变，形式地址A可变</li></ul><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>变址寻址的有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(IX)+A，IX为变址寄存器(专用)，通用寄存器也可以作为变址寄存器</li><li>可扩大寻址范围</li><li>IX的内容由用户给定</li><li>在程序的执行过程中IX内容可变，形式地址A不变</li><li>便于处理数组问题</li></ul><h4 id="设数据块首地址为D，求N个数的平均值"><a href="#设数据块首地址为D，求N个数的平均值" class="headerlink" title="设数据块首地址为D，求N个数的平均值"></a>设数据块首地址为D，求N个数的平均值</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(PC)+A，A是相对于当前指令的位移量(可正可负，补码)</li><li>A的位数决定操作数的寻址范围</li><li>程序浮动</li><li>广泛用于转移指令</li></ul><h4 id="相对寻址举例"><a href="#相对寻址举例" class="headerlink" title="相对寻址举例"></a>相对寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>M随程序所在存储空间的位置不同而不同，而指令BNE*-3与ADD X，D相对位移量不变.<br>指令BNE*-3操作数的有效地址为EA=(M+3)-3=M</p><h4 id="按字节寻址的相对寻址举例"><a href="#按字节寻址的相对寻址举例" class="headerlink" title="按字节寻址的相对寻址举例"></a>按字节寻址的相对寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/16.png" srcset="/img/loading.gif" width="350px" height="200px"><br>设当前指令地址PC=2000H，转移后的目的地址为2008H，因为取出JMP*+8后，PC=2002H，故JMP*+8指令的第二字节为2008H-2002H=06H。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><h4 id="堆栈的特点"><a href="#堆栈的特点" class="headerlink" title="堆栈的特点"></a>堆栈的特点</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/17.png" srcset="/img/loading.gif" width="350px" height="200px"></p><ul><li>硬堆栈，多个寄存器</li><li>软堆栈，指定的存储空间</li></ul><p>先进后出(一个入出口)，栈顶地址由SP指出<br>进栈(SP)-1-&gt;SP，出栈(SP)+1-&gt;SP</p><h4 id="堆栈寻址举例"><a href="#堆栈寻址举例" class="headerlink" title="堆栈寻址举例"></a>堆栈寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SP的修改和主存编址方法有关"><a href="#SP的修改和主存编址方法有关" class="headerlink" title="SP的修改和主存编址方法有关"></a>SP的修改和主存编址方法有关</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="九种寻址方式总结"><a href="#九种寻址方式总结" class="headerlink" title="九种寻址方式总结"></a>九种寻址方式总结</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/22.png" srcset="/img/loading.gif" width="800px" height="350px"></p><h1 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h1><h2 id="设计指令格式时应考虑的各种因素"><a href="#设计指令格式时应考虑的各种因素" class="headerlink" title="设计指令格式时应考虑的各种因素"></a>设计指令格式时应考虑的各种因素</h2><ul><li>指令系统的兼容性</li><li>其他因素<ul><li>操作类型，包括指令个数及操作的难易程度</li><li>数据类型，确定哪些数据类型可参与操作</li><li>指令格式<ul><li>指令字长是否固定</li><li>操作码位数，是否采用扩展操作码技术</li><li>地址码位数，地址个数、寻址方式类型</li></ul></li><li>寻址方式，指令寻址、操作数寻址</li><li>寄存器个数，寄存器的多少直接影响指令的执行时间</li></ul></li></ul><h3 id="IBM360"><a href="#IBM360" class="headerlink" title="IBM360"></a>IBM360</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/20.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Intel-8086"><a href="#Intel-8086" class="headerlink" title="Intel 8086"></a>Intel 8086</h3><ol><li>指令字长 1~6个字节<br>INC AX 1字节<br>MOV WORD PTR[0204],0138 6字节</li><li>地址格式<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/21.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h1 id="RISC技术"><a href="#RISC技术" class="headerlink" title="RISC技术"></a>RISC技术</h1><h2 id="RISC的产生和发展"><a href="#RISC的产生和发展" class="headerlink" title="RISC的产生和发展"></a>RISC的产生和发展</h2><ul><li>RISC(Reduced Instruction Set Computer)</li><li>CISC(Complex Instruction Set Computer)</li></ul><p>典型程序中80%的语句仅仅使用处理机中20%的指令，执行频度高的简单指令，因复杂指令的存在，执行速度无法提高，于是提出用20%简单指令组合不常用的80%指令功能。</p><h2 id="RISC的主要特性"><a href="#RISC的主要特性" class="headerlink" title="RISC的主要特性"></a>RISC的主要特性</h2><ul><li>选用使用频度较高的一些简单指令，复杂指令的功能由简单指令组合</li><li>指令长度固定，指令格式种类少、寻址方式少</li><li>只能LOAD/STORE指令访存</li><li>CPU中有多个通用寄存器</li><li>采用流水技术 ，一个时钟周期内 完成一条指令</li><li>采用组合逻辑实现控制器</li></ul><h2 id="CISC的主要特征"><a href="#CISC的主要特征" class="headerlink" title="CISC的主要特征"></a>CISC的主要特征</h2><ul><li>系统指令复杂庞大，各种指令使用频度相差大</li><li>指令 长度不固定、指令格式种类多、寻址方式多</li><li>访存 指令 不受限制</li><li>CPU 中设有 专用寄存器</li><li>大多数指令需要 多个时钟周期 执行完毕</li><li>采用 微程序 控制器</li></ul><h2 id="RISC和CISC的比较"><a href="#RISC和CISC的比较" class="headerlink" title="RISC和CISC的比较"></a>RISC和CISC的比较</h2><ol><li>RISC更能充分利用VLSI芯片的面积</li><li>RISC 更能提高计算机运算速度，指令数、指令格式、寻址方式少，通用寄存器多，采用组合逻辑，便于实现指令流水</li><li>RISC便于设计，可降低成本，提高可靠性</li><li>RISC不易实现指令系统兼容</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器指令与操作数</title>
    <link href="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
    <url>/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><h2 id="机器指令的定义"><a href="#机器指令的定义" class="headerlink" title="机器指令的定义"></a>机器指令的定义</h2><p>计算机唯一能识别的语言是机器语言，而机器语言是由一条条语句构成，人们习惯把构成机器语言的这些语句称为机器指令，全部机器指令的集合又称为机器的指令系统。</p><h2 id="机器指令的格式"><a href="#机器指令的格式" class="headerlink" title="机器指令的格式"></a>机器指令的格式</h2><p>一条指令由操作码和地址码组成，指令的字长分为固定字长和可变字长。</p><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/1.png" srcset="/img/loading.gif" width="300px" height="100px"></p><ol><li>长度固定，用于指令字长较长的情况，RISC。如IBM370，操作码8位</li><li>长度可变，操作码分散在指令字的不同字段中，不允许较短操作码是较长操作码的前缀，各条指令操作码不能重复。</li><li>扩展操作码技术，操作码的位数随地址数的减少而增加<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/2.png" srcset="/img/loading.gif" width="500px" height="280px"></li></ol><blockquote><p>三地址指令操作码，每减少一种最多可构成$2^4$种二地址指令<br>二地址指令操作码，每减少一种最多可多构成$2^4$种一地址指令</p></blockquote><h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p>地址码也被称为操作数字段，地址码的作用：</p><ul><li>需要指出操作数的地址，即用哪里的数来操作。</li><li>需要指出操作后的结果放在哪里，即给出结果存放的地址。</li><li>需要指出该条指令执行结束后怎么办，即需要指出下一条指令的地址。</li></ul><ol><li>四地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/4.png" srcset="/img/loading.gif" width="500px" height="250px"><br>A4用于存放下一条将要执行指令的地址，若指令字长32位，操作码8位，四个地址码字段各6位，直接寻址范围$2^6=64$,访存4次</li><li>三地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/5.png" srcset="/img/loading.gif" width="500px" height="180px"><br>A1与A2进行OP后，结果保存在A3中，假设指令字长32位，操作码8位，地址码各8位，寻址范围$2^8=256$，若地址字段均为主存地址，需要四次访存。</li><li>二地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/6.png" srcset="/img/loading.gif" width="500px" height="220px"><br>A1与A2进行OP后，结果存入A1或A2中，假设指令字长32位，操作码8位，地址码各12位，寻址范围$2^{12}=4K$</li><li>一地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/7.png" srcset="/img/loading.gif" width="500px" height="150px"><br>从A1读取操作数，进行OP操作后，操作码字段通常为加一，减一，求反求补等。<br>指令可隐含约定另一个操作数由ACC提供，运算结果存放在ACC中。</li><li>零地址，无地址码<br>不需要操作数的指令，如空操作指令，停机指令，关中断指令等</li></ol><h2 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h2><p>指令字长指一条指令所占用存储空间的大小，由于主存一般按字节编址，指令字长一般为字节的整数倍。若某指令长度等于机器字长，则称此指令为单字长指令，指令字长决定于操作码的长度，操作数地址的长度，操作数地址的个数。<br>数据字：计算机中某个字表示数据<br>指令字：计算机中某个字表示指令</p><ol><li>指令字长固定，指令字长=存储子长</li><li>指令字长可变，按字节的倍数变化</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>当用一些硬件资源代替指令字中的地址码字段后<ul><li>可扩大指令的寻址范围</li><li>可缩短指令字长</li><li>可减少访存次数</li></ul></li><li>当指令的地址字段为寄存器时<ul><li>三地址 OP R1,R2,R3</li><li>二地址 OP R1,R2</li><li>一地址 OP R1</li><li>可缩短指令字长</li><li>指令执行阶段不访存</li></ul></li></ul><h1 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><ul><li>地址 无符号整数</li><li>数字 定点数、浮点数、十进制数</li><li>字符 ASCII</li><li>逻辑数 逻辑运算</li></ul><h2 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h2><p>例 1，2，3，4，5，6，7，8，H的存放方式<br>字地址为高字节地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/8.png" srcset="/img/loading.gif" width="230px" height="80px"></p><p>字地址为低字节地址<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/9.png" srcset="/img/loading.gif" width="230px" height="80px"></p><h2 id="数据在存储器中的存放方式-1"><a href="#数据在存储器中的存放方式-1" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h2><h4 id="从任意位置开始存储"><a href="#从任意位置开始存储" class="headerlink" title="从任意位置开始存储"></a>从任意位置开始存储</h4><p><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/10.png" srcset="/img/loading.gif" width="500px" height="150px"><br>优点: 不浪费存储资源<br>缺点：除了访问第一个字节之外，访问其他任何类型的数据，都可能花费两个存储周期的时间，读写控制比较复杂。</p><h4 id="从一个存储字的起始位置开始访问"><a href="#从一个存储字的起始位置开始访问" class="headerlink" title="从一个存储字的起始位置开始访问"></a>从一个存储字的起始位置开始访问</h4><p><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/11.png" srcset="/img/loading.gif" width="500px" height="150px"><br>优点: 无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。<br>缺点：浪费了宝贵的存储资源</p><h4 id="边界对准方式，从地址的整数倍位置开始访问"><a href="#边界对准方式，从地址的整数倍位置开始访问" class="headerlink" title="边界对准方式，从地址的整数倍位置开始访问"></a>边界对准方式，从地址的整数倍位置开始访问</h4><p><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/12.png" srcset="/img/loading.gif" width="500px" height="150px"><br>数据存放的起始地址是数据长度(按编址单位进行计算)的整数倍，本方案是前两个方案的折中。</p><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><ul><li>数据传送<br><img src="/2020/05/17/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0/13.png" srcset="/img/loading.gif" width="500px" height="150px"></li><li>算术逻辑操作<br>加、减、乘、除、增1、减1、求补、浮点运算、十进制运算、与、或、非、异或、位操作、位测试、位清除、位求反.<br>如8086：ADD SUB MUL DIV INC DEC CMP NEG AAA AAS AAM AAD AND OR NOT XOR TEST</li><li>移位操作<ul><li>算术移位</li><li>逻辑移位</li><li>循环移位</li></ul></li><li>转移<ul><li>无条件转移 JMP</li><li>条件转移<ul><li>结果为零转 (z=1) JZ</li><li>结果为溢出转 (o=1) JO</li><li>结果有进位转 (c=)1 JC</li><li>跳过一条指令 SKP</li></ul></li><li>程序调用和返回</li><li>陷阱与陷阱指令<ul><li>一般不提供给用户，出现事故时，由CPU自动产生</li><li>设置供用户使用的陷阱指令</li></ul></li></ul></li><li>输入输出</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表</title>
    <link href="/2020/05/14/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2020/05/14/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h1><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p>串(String)(或字符串)是由零个或多个字符组成的有限序列,一般记为</p><script type="math/tex;mode=display">s="a_1a_2\cdots a_n" (n\geq 0)</script><ul><li>串中字符的数目n称为串的长度，零个字符的串称为空串，长度为零。</li><li>串中任意个连续的字符组成的子序列称为该串的子串，包含子串的串相应地称为主串。</li><li>两个串长度相等，并且各个对应位置的字符都相等时才相等。</li><li>一个或多个空格组成的串称为空格串</li></ul><h2 id="串的抽象类型定义"><a href="#串的抽象类型定义" class="headerlink" title="串的抽象类型定义"></a>串的抽象类型定义</h2><pre><code>StrAssign(&amp;T,Chars)        //chars是字符串常量，生成一个其值等于chars的串TStrCopy(&amp;T,S)            //串存在，由串S复制得串TStrEmpty(S)                //串存在，判断S是否为空串StrCompare(S,T)            //串S与T存在，若S&gt;T返回值&gt;0,S=T,返回值=0，S&lt;T,返回值&lt;0StrLength(S)            //串存在，返回S的元素个数，称为串的长度ClearString(&amp;S)            //串存在，将S清为空串Concat(&amp;T,S1,S2)        //串S1与S2存在，用T返回S1与S2拼接的新串SubString(&amp;Sub,S,pos,len)    //串存在，1&lt;=pos&lt;=StrLength(S)且0&lt;=len&lt;=Strlength(S)-pos+1，用Sub返回串S的第pos个字串起长度为len的字串Index(S,T,pos)            //串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S)，若主串S中存在和串T值相同的字串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0Replace(&amp;S,T,V)            //S,T,V存在，T是非空串，用V替换主串S中出现的所有与T相等的不重叠的字串StrInsert(&amp;S,pos,T)        //串S与T存在，T是非空串，用V替换主串S中出现的所有与T相等的不重叠的子串StrDelete(&amp;S,pos,len)    //串S存在，1&lt;=pos&lt;=StrLength(S)-len+1，从串S中删除第pos个字符起长度为len的字串DestroyString(&amp;S)        //串存在，销魂串</code></pre><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><h4 id="串的定长顺序存储结构"><a href="#串的定长顺序存储结构" class="headerlink" title="串的定长顺序存储结构"></a>串的定长顺序存储结构</h4><pre><code>#define MAXLEN 255typedef struct{    char ch[MAXLEN+1];        //储存串的一维数组    int length;                //串的长度}SString;</code></pre><h4 id="串的堆式顺序存储结构"><a href="#串的堆式顺序存储结构" class="headerlink" title="串的堆式顺序存储结构"></a>串的堆式顺序存储结构</h4><pre><code>typedef struct{    char *ch;                //若是非空串，则按串长分配存储区，否则ch为NULL    int length;                //串的当前长度}HString;</code></pre><h3 id="串的顺序存储简易代码"><a href="#串的顺序存储简易代码" class="headerlink" title="串的顺序存储简易代码"></a>串的顺序存储简易代码</h3><p>用一组地址连续的存储单元存储串的字符序列，为了根据实际需要，在程序执行过程中动态分配和释放字符数组空间，使用堆式顺序存储结构。</p><p><strong>堆式顺序存储结构举例</strong>：</p><pre><code>typedef struct {    char *ch;    int length;}HString;int StrAssign(HString *s,const char chars[]) {    int i = 0;    while (chars[i] != NULL) {        i++;    }    s-&gt;ch = (char*)malloc(sizeof(char)*i);    if (s-&gt;ch == NULL) return -1;    s-&gt;length = i;    for (int j = 0; j &lt; i; j++) {        s-&gt;ch[j] = chars[j];    }    return 1;}int StrCopy(HString *t,HString s) {    t-&gt;ch = (char*)malloc(sizeof(char)*s.length);    t-&gt;length = s.length;    for (int i = 0; i &lt; s.length; i++) {        t-&gt;ch[i] = s.ch[i];    }    return 1;}int StrEmpty(HString s) {    if (s.length == 0) return true;    return false;}int StrCompare(HString s,HString t) {    int i = 0;    int Min_length = (s.length &lt; t.length) ? s.length : t.length;    while (s.ch[i] == t.ch[i]) {        if (i = Min_length) return 0;        i++;    }    if (s.ch[i] &gt; t.ch[i])return 1;    if (s.ch[i] &lt; t.ch[i])return -1;}int StrLength(HString s) {    return s.length;}void ClearString(HString *s) {    char  *temp = s-&gt;ch;    s-&gt;ch = NULL;    free(temp);    s-&gt;length = 0;}void Concat(HString *t,HString s1, HString s2) {    t-&gt;length = s1.length + s2.length;    t-&gt;ch = (char*)malloc(sizeof(char)*(t-&gt;length));    int i = 0, j = 0;    while (i &lt; s1.length) {        t-&gt;ch[i] = s1.ch[i];        i++;    }    while (j &lt; s2.length) {        t-&gt;ch[i] = s2.ch[j];        j++;        i++;    }}void SubString(HString *sub,HString s,int pos,int len) {    sub-&gt;length = len;    sub-&gt;ch = (char*)malloc(sizeof(char)*len);    int i = pos+1; int j = 0;    while (i &lt; s.length) {        sub-&gt;ch[j] = s.ch[i];        i++;        j++;    }}void DestroyString(HString *s) {    char *temp = s-&gt;ch;    free(s-&gt;ch);    free(s);}void StrPrint(HString s) {    int i = 0;    while (i &lt; s.length) {        cout &lt;&lt; s.ch[i];        i++;    }    cout &lt;&lt; endl;}//测试int main() {    HString s;    StrAssign(&amp;s, &quot;abcdefg&quot;);        //根据字符串常量生成字符串    HString t;    StrCopy(&amp;t, s);        //复制串s    HString a;    StrAssign(&amp;a, &quot;xcvbad&quot;);    cout &lt;&lt; StrCompare(s, t) &lt;&lt; endl;        //比较字符串    cout &lt;&lt; StrLength(a) &lt;&lt; endl;            //返回字符串长度    HString  b;    Concat(&amp;b, s, a);                        //拼凑字符串    HString c;    SubString(&amp;c, s, 1, 3);                    //返回s串从1位置起长度为3的子串    StrPrint(c);    StrPrint(b);    StrPrint(t);    //StrPrint(s);    getchar();    return 0;}</code></pre><h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><p>顺序串插入与删除并不方便，需要移动大量字符，因此使用单链表方式存储串。<br>如果所存的串元素数量很大，串链中的结点数据域可以采用数组的结构对串进行遍历时间上的优化.<br>如果串的元素比较少，那么使用普通的字符类型作为结点的数据域更加节省空间。</p><p><strong>数组加链表，代码举例</strong></p><pre><code>#define CHUNKSIZE 3typedef struct Chunk {    char ch[CHUNKSIZE];    struct Chunk *next;}Chunk;typedef  struct {    Chunk *head, *tail;    int Chunk_num;    int length;                                                //字符串字符数量}LString;void StrAssign(LString *s, const char chars[]) {    int chars_len = 0;                                        //常量字符长度    int nowChunk_num = 0;                                    //当前已有块数    s-&gt;Chunk_num = 0;    while (chars[chars_len] != NULL) {        chars_len++;    }    s-&gt;Chunk_num = (chars_len / CHUNKSIZE)+1;                    //串链块数    s-&gt;length = chars_len;    //串申请    if (chars_len != 0) {        s-&gt;head = (Chunk*)malloc(sizeof(Chunk));        s-&gt;tail = s-&gt;head;        nowChunk_num++;    }    while (nowChunk_num &lt; s-&gt;Chunk_num) {                        //申请块        Chunk* temp = (Chunk*)malloc(sizeof(Chunk));        s-&gt;tail-&gt;next = temp;        s-&gt;tail = s-&gt;tail-&gt;next;        s-&gt;tail-&gt;next = NULL;        nowChunk_num++;    }    // 串赋值    int chars_p = 0;                                        //chars字符当前位置    Chunk* p = NULL;    if(s-&gt;head != NULL) p = s-&gt;head;                        //串当前指针    while (p != NULL) {        for (int i = 0; (i &lt; CHUNKSIZE &amp;&amp; chars_p &lt; chars_len); i++, chars_p++) {            p-&gt;ch[i] = chars[chars_p];        }        p = p-&gt;next;    }}void StrPrint(LString s) {    Chunk *p = s.head;    while (p != NULL) {        for (int i = 0; i &lt; CHUNKSIZE; i++) {            if(p-&gt;ch[i] &gt;=0 &amp;&amp; p-&gt;ch[i] &lt;= 127)            cout &lt;&lt; p-&gt;ch[i];            else continue;        }p = p-&gt;next;    }    cout &lt;&lt; endl;}int StrCopy(LString *t, LString s) {    t-&gt;length = s.length;    t-&gt;Chunk_num = 0;    Chunk *s_p = NULL;                //s块指针    Chunk *t_p = NULL;                //t块指针    if (s.head != NULL) {        t-&gt;head = (Chunk*)malloc(sizeof(Chunk));        t-&gt;tail = t-&gt;head;        t-&gt;Chunk_num++;    }    while (t-&gt;Chunk_num &lt;s.Chunk_num) {        //t.申请块        Chunk *temp = (Chunk*)malloc(sizeof(Chunk));        t-&gt;tail-&gt;next = temp;        t-&gt;tail = t-&gt;tail-&gt;next;        t-&gt;tail-&gt;next = NULL;        t-&gt;Chunk_num++;    }    t_p = t-&gt;head;    s_p = s.head;    while (s_p != NULL &amp;&amp; t_p != NULL) {        int j = 0;        for (int i = 0; i &lt; CHUNKSIZE &amp;&amp; j &lt; s.length; i++, j++) {            t_p-&gt;ch[i] = s_p-&gt;ch[i];        }        s_p = s_p-&gt;next;        t_p = t_p-&gt;next;    }    return 1;}int StrEmpty(LString s) {    if(s.head == NULL) return 1;    return 0;}int StrCompare(LString s, LString t) {    Chunk *sp = s.head;    Chunk *tp = t.head;    int nowl = 0;    while (sp != NULL &amp;&amp; tp != NULL) {        if (sp == NULL &amp;&amp; tp == NULL)return 0;        for (int i = 0; i &lt; CHUNKSIZE; i++) {            if (sp-&gt;ch[i] == tp-&gt;ch[i]) {                nowl++;                if (nowl &gt; 3) {                    nowl = 0;                    break;                }continue;            }            if (sp-&gt;ch[i] &gt; tp-&gt;ch[i]) return 1;            if (sp-&gt;ch[i] &lt; tp-&gt;ch[i]) return -1;        }        sp = sp-&gt;next; tp = tp-&gt;next;    }    return 1;}int StrLength(LString s) {    return s.length;}int ClearString(LString *s) {    while (s-&gt;head != NULL) {        Chunk* temp = s-&gt;head;        s-&gt;head = s-&gt;head-&gt;next;        free(temp);    }    s-&gt;Chunk_num = 0;    s-&gt;length = 0;    s-&gt;head = NULL;    s-&gt;tail = NULL;    return 1;}int Concat(LString *t, LString s1, LString s2) {    //不浪费空间的连接法，直接连接两个字符串的空间地址    /*t-&gt;length = s1.length + s2.length;    t-&gt;Chunk_num = s1.Chunk_num + s2.Chunk_num;    t-&gt;head = s1.head;    t-&gt;tail = s1.tail;    t-&gt;tail-&gt;next = s2.head;    t-&gt;tail = s2.tail;*/    //重新分配空间    t-&gt;length = s1.length + s2.length;    t-&gt;Chunk_num = t-&gt;length / CHUNKSIZE +1;    LString s1temp;    LString s2temp;    StrCopy(&amp;s1temp, s1);    StrCopy(&amp;s2temp, s2);    t-&gt;head = s1temp.head;    s1temp.tail-&gt;next = s2temp.head;    t-&gt;tail = s2temp.tail;    return 1;}int DestroyString(LString *s) {    while (s-&gt;head != NULL) {        Chunk* temp = s-&gt;head;        s-&gt;head = s-&gt;head-&gt;next;        free(temp);    }    free(s);    return 1;}//需要模式匹配算法，后面介绍void Index() {}void Replace() {}//与链表增删同理void StrInsert() {}void StrDelete() {}//测试int main() {    LString s,t,d,a;    StrAssign(&amp;s, &quot;assfaasfasjkfkhqhnkqwjnfjkhqnjkfbjakbnfjkanfkjqwbjkfndMMMM&quot;);    StrAssign(&amp;d, &quot;asdfghsaesadsadasdadsafsaffdgdj&quot;);    StrCopy(&amp;t, s);    //cout &lt;&lt; StrCompare(s, d)&lt;&lt;endl;    Concat(&amp;a, s, t);    StrPrint(a);    getchar();    return 0;}</code></pre><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>字串的定位运算通常称为串的模式匹配或串匹配。<br>串的模式匹配设有两个字符串S和T，设S为主串，也称为正文串，设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置，著名的算法为：</p><ul><li>BF算法</li><li>KMP算法</li></ul><h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>模式匹算法配不一定是从主串的第一个位置开始，可以指定主串中查找的起始位置pos，如果采用字符串顺序存储结构，可以写出不依赖于其他串操作的匹配算法。<br>最好情况下匹配成功的平均比较次数为：</p><script type="math/tex;mode=display">\displaystyle \sum^{n-m+1}_{i=1}{p_i(i-1+m)=}</script><script type="math/tex;mode=display">1/(n-m+1)\displaystyle \sum^{n-m+1}_{i=1}{i-1+m}=1/2(n+m)</script><p>最坏情况下匹配成功的平均次数为：</p><script type="math/tex;mode=display">\displaystyle \sum^{n-m+1}_{i=1}{p_i(i\times m)=}</script><script type="math/tex;mode=display">1/(n-m+1)\displaystyle \sum^{n-m+1}_{i=1}{i\times m}=</script><script type="math/tex;mode=display">(1/2)m\times (n-m+2)</script><p>算法步骤：</p><ul><li>分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos,j初值为1.</li><li>如果两个串均为比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作<ul><li>S.ch[i]和T.ch[j]比较，若相等，则i与j分别指示串中下一个位置，继续比较后续字符</li><li>若不等，指针后退重新开始匹配，从主串的下一个字符(i=i-j+2)起再重新和模式的第一个字符j=1比较。</li></ul></li><li>如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号。</li></ul><p>简易代码示例：</p><pre><code>int  Cal_length(char s[]) {        //求数组长度    int len = 0;    while (s[len]) {        len++;    }    return len;}int Index_BF(char s[], char t[], int pos) {    int i = pos; int j = 0;    int i_length = Cal_length(s);    int t_length = Cal_length(t);    while (i &lt; i_length &amp;&amp; j &lt; t_length) {        if (s[i] == t[j]) { i++; j++; }        else { i = i - j + 1; j = 0; }    }    if (j &gt;= t_length) { return i - t_length; }    else return 0;}int main() {    char ch[] = &quot;asdfabcgfdsh&quot;;    char ch1[] = &quot;abc&quot;;    cout &lt;&lt; Index_BF(ch, ch1, 2);    getchar();    return 0;}</code></pre><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><ul><li>KMP算法其实是针对BF算法的优化，因为BF算法依次逐位进行匹配，如果出现匹配失败，主串i的值需要回溯到起始的下一个位置，j的值回溯到0，重新开始匹配。</li><li>KMP算法需要计算next数组，并根据next数组的对应值回溯j，next[i]指的是前i位子串的最大相同的前缀后缀的长度，子串计算next数组的值实际上是利用子串自己匹配自己，将对应的值存入next数组。</li><li>KMP算法只需要利用已匹配的信息，根据next数组的值回溯j的值，而主串i的值不需要回溯，因此提高了匹配的效率。</li><li>KMP算法的核心是当失配后，j的值应该如何回溯，因此k=next[k]是KMP算法的精髓，网上有大量博客讲述KMP算法，因此由于本人理解有限，并不在此详细叙述算法过程，给出下例代码仅供参考。</li></ul><p><strong>KMP算法代码如下</strong>：</p><pre><code>void getNext(char t[], int next[]) {    int t_length = strlen(t);    next[0] = -1;    int k = -1;    for (int j = 0; j &lt; t_length - 1;) {        //最后一位不比        if (k == -1 || t[j] == t[k]) {            ++k; ++j;            next[j] = k;        }        else  k = next[k];                //KMP算法的精髓    }        //00012123001120000,00012000001000000}int KMP(char s[], char t[], int pos) {    int i = pos;     int j = -1;    int i_length = strlen(s);    int t_length = strlen(t);    //得到next数组    int* next = (int*)malloc(sizeof(int)*t_length);        //根据子串的长度动态分配    getNext(t, next);    //优化之后主串的i不需要回溯，只需要回溯子串j的位置    while (i &lt; i_length &amp;&amp; j &lt; t_length) {        if (j == -1 || s[i] == t[j]) { i++; j++; }        else { j = next[j]; }         //s[i] != t[j]并且j != -1的情况下，根据next的值回溯j    }    if (j &gt;= t_length) { return i - j; }    //总长 - 匹配成功的子串长    else return 0;}//测试int main() {    char s[] = &quot;dsadsadsafsaf abcababccbaabc gqegqwdsad&quot;;    char t[] = &quot;abcababccbaabc&quot;;    cout&lt;&lt;KMP(s, t, 1);    getchar();    return 0;}</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组类型的定义"><a href="#数组类型的定义" class="headerlink" title="数组类型的定义"></a>数组类型的定义</h2><ul><li>数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素。</li><li>每个元素受$n(n\geq 1)$个线性关系的约束</li><li>每个元素在n个线性关系中的序号i_1,i_2…称为该元素的下表</li><li>数组可以看成线性表的推广，特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。</li><li>二维数组可以看成数据元素是线性表的线性表</li><li>数组一旦被定义，它的维数和维界就不再改变，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作</li></ul><h3 id="抽象数据类型ADT定义"><a href="#抽象数据类型ADT定义" class="headerlink" title="抽象数据类型ADT定义"></a>抽象数据类型ADT定义</h3><pre><code>InitArray(&amp;A,n,boundi,...,boundn)    //若维数n与各维长度合法，构造相应的数组ADestroyArray(&amp;A)                    //销毁数组AValue(A,&amp;e,index1,...,indexn)        //若各下标不超界，则e赋值为所指定的A的元素值Assign(&amp;A,e,index1,...,indexn)        //若下标不超界，则按e的值赋给所指定的A的元素</code></pre><h2 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h2><p>假设每个数据元素占L个存储单元，则二维数组A[0..m-1,0..n-1] (即从下标开始一共m行n列)中任一元素$a_{ij}$的存储位置可由下式确定</p><script type="math/tex;mode=display">LOC(i,j) = LOC(0,0) + (n\times i +j)L</script><p>式中，$LOC(i,j)$是$a_{ij}$的存储位置<br>数组的存储方式分为：</p><ul><li>以列序为主序</li><li>以行序为主序</li></ul><h2 id="特殊矩阵的压缩处理"><a href="#特殊矩阵的压缩处理" class="headerlink" title="特殊矩阵的压缩处理"></a>特殊矩阵的压缩处理</h2><ul><li>对称矩阵<ul><li>若n阶矩阵A中的元素满足<script type="math/tex">a_{ij} = a_{ji}</script>则称为n阶对称矩阵。</li><li>对称矩阵可以为每一对对称元分配一个存储空间，则可以将$2^n$个元压缩到$n(n+1)/2$个元空间中。</li><li>对称矩阵与压缩矩阵的对应关系为:<script type="math/tex;mode=display">A_{ij} = b_{((i(i - 1)/2)+j-1)},(i \geq j)</script><script type="math/tex;mode=display">A_{ij} = b_{((j(j - 1) / 2) + i - 1)},(i < j)</script></li></ul></li><li>三角矩阵<ul><li>n阶上三角矩阵,压缩矩阵与原矩阵的对应关系为<script type="math/tex;mode=display">A_{ij} = b_{((i-1)(2n-i+2)/2)+(j-i)},(i\leq j)</script><script type="math/tex;mode=display">A_{ij} = b_{(n(n+1)/2)},(i>j)</script></li><li>n阶下三角矩阵,压缩矩阵与原矩阵的对应关系为<script type="math/tex;mode=display">A_{ij} = b_{((i(i-1)/2)+j-1)},(i\geq j)</script><script type="math/tex;mode=display">A_{ij} = b_{(n(n+1)/2)},(i<j)</script></li><li>三角矩阵以主对角线划分，存储三角矩阵只需要存储矩阵的上三角或下三角中的元素，再加一个存储常数c的存储空间即可。</li></ul></li><li>对角矩阵<ul><li>对角矩阵所有的非零元都集中在以主对角线为中心的带状区域</li><li>除了集中在对角线区域之外，其他元素都为0</li></ul></li></ul><h4 id="对称矩阵压缩代码示例"><a href="#对称矩阵压缩代码示例" class="headerlink" title="对称矩阵压缩代码示例"></a>对称矩阵压缩代码示例</h4><pre><code>/* 假设矩阵需要压缩存储2 1 2 3 4 51 2 8 9 5 62 8 2 3 7 63 9 3 2 9 44 5 7 9 2 15 6 6 4 1 2*/#define N 6                            //矩阵行列数#define N_y N*(N+1)/2                //压缩后的大小int* GetCompreM(int a[][N]) {        //压缩矩阵    int k = 0;    int *b = (int*)malloc(sizeof(int)*N_y);    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt;= i; j++) {            b[k++] = a[i][j];        }    }    return b;}int GetValue(int *b,int i,int j) {    //根据压缩矩阵计算原矩阵的值    if (i &gt;= j) return b[(i*(i - 1) / 2) + j - 1];    if (i &lt; j) return b[(j*(j - 1) / 2) + i - 1];    return 0;}//测试int main() {    int a[N][N] = {{2,1,2,3,4,5},{1,2,8,9,5,6},{2,8,2,3,7,6},{3,9,3,2,9,4},{4,5,7,9,2,1},{5,6,6,4,1,2}};    int *b = GetCompreM(a);    cout &lt;&lt; GetValue(b, 5, 4);    getchar();    return 0;}</code></pre><h4 id="三角矩阵定义示例"><a href="#三角矩阵定义示例" class="headerlink" title="三角矩阵定义示例"></a>三角矩阵定义示例</h4><pre><code>#define N 6typedef struct{    int b[N*(N+1)/2];    int c;    };</code></pre><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p>稀疏矩阵是指其非零元较零元少，且分布没有一定规律，称之为稀疏矩阵。<br>稀疏矩阵的一般的压缩存储分为两种方式：</p><ul><li>三元组存储</li><li>十字链表存储</li></ul><h3 id="三元组压缩存储"><a href="#三元组压缩存储" class="headerlink" title="三元组压缩存储"></a>三元组压缩存储</h3><p>由于稀疏矩阵零元较多，如果采取普通的矩阵存储，会浪费大量的存储空间，因此引出三元组存储方法，只需要存储非零元的值即可，因此需要存储非零元的横列下标以及对应的值。<br>三元组结构定义如下：</p><pre><code>#define MAXSIZE 10typedef struct {    int row,col;    //原矩阵的行列号    int data;        //原矩阵对应的值}node;typedef struct {    int i,j;        //原矩阵的行列数    int NodeNum;    //原矩阵非零元个数    node data[MAXSIZE];    //存放原矩阵非零元的三元组表};</code></pre><h4 id="三元组存稀疏矩阵代码示例"><a href="#三元组存稀疏矩阵代码示例" class="headerlink" title="三元组存稀疏矩阵代码示例"></a>三元组存稀疏矩阵代码示例</h4><pre><code>/*以下稀疏矩阵为例0 0 0 1 0 20 2 1 0 0 00 0 0 6 0 00 1 0 0 0 70 0 0 0 0 0*/typedef struct {    int row, col;    //原矩阵的行列号    int data;        //原矩阵对应的值}node;typedef struct {    int i, j;        //原矩阵的行列数    int NodeNum;    //原矩阵非零元个数    node *data;    //存放原矩阵非零元的三元组表}ThrList;int CreateThr(ThrList *s,int a[][6]) {        //压缩存储    s-&gt;data = (node*)malloc(sizeof(node) * 7);    s-&gt;NodeNum = 0;    int k = 0;    s-&gt;i = 5;    s-&gt;j = 6;    for (int i = 0; i &lt; 5; i++) {        for (int j = 0; j &lt; 6; j++) {            if (a[i][j] != 0) {                s-&gt;data[k].col = i;                s-&gt;data[k].row = j;                s-&gt;data[k++].data = a[i][j];                s-&gt;NodeNum++;            }        }    }    return 1;}void PrintThr(ThrList s) {                    //打印    for (int i = 0; i &lt; s.NodeNum; i++) {        cout &lt;&lt; s.data[i].data;    }}int GetValue(ThrList s,int i,int j) {        //取值    for (int k = 0; k &lt; s.NodeNum; k++) {        if (s.data[k].col == i &amp;&amp; s.data[k].row == j) {            return s.data[k].data;        }    }    return 0;}//测试int main() {    int a[5][6] = { { 0, 0, 0, 1, 0, 2 }, { 0, 2, 1, 0, 0, 0 }, { 0, 0, 0, 6, 0, 0 }, { 0, 1, 0, 0, 0, 7 }, { 0, 0, 0, 0, 0, 0 } };    ThrList s;    CreateThr(&amp;s,a);    //PrintThr(s);    cout &lt;&lt; GetValue(s, 3, 5);    getchar();    return 0;}</code></pre><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>十字链表也可以对稀疏矩阵进行压缩存储，对于压缩存储稀疏矩阵，无论是使用三元组顺序表，还是使用行逻辑链接的顺序表，归根结底是使用数组存储稀疏矩阵。<br>介于数组 “不利于插入和删除数据” 的特点，以上两种压缩存储方式都不适合解决类似 “向矩阵中添加或删除非 0 元素” 的问题。<br>在图结构中，有向图可以用两个邻接矩阵进行表示，而有向图的存储需要使用对应矩阵的邻接表与逆邻接表，为了减少存储空间，使用十字链表结合了邻接表与逆邻接表。<br>本文暂不叙述十字链表的存储方式，会在学习图之后进行补充。</p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><h2 id="广义表的定义"><a href="#广义表的定义" class="headerlink" title="广义表的定义"></a>广义表的定义</h2><p>广义表是线性表的推广，也成为列表，广义表一般记作</p><script type="math/tex;mode=display">LS=(a_1,a_2,...,a_n)</script><p>LS是广义表的名称，n是其长度，在广义表的定义中，a_i可以是单个元素也可以是广义表，分别称为广义表LS的原子或子表，一般小写字母表示原子，大写字母表示广义表，广义表的定义是一个递归的定义，下面为广义表举例</p><ul><li>A=(),A为空表</li><li>B=(e),B只有一个原子e</li><li>C=(a,(b,c,d)),C有两个元素，一个是原子a，另一个是子表(b,c,d)</li><li>D=(A,B,C),D表含有三个子表</li><li>E=(a,E),E为一个递归表，每一层都有一个原子e与表E</li></ul><h2 id="广义表的重要结论"><a href="#广义表的重要结论" class="headerlink" title="广义表的重要结论"></a>广义表的重要结论</h2><ol><li>广义表的元素可以是广义表，即广义表可以多层次的结构</li><li>广义表的深度定义为所含括弧的重数，其中原子的深度为0，空表的深度为1</li><li>广义表的长度定义为最外层包含元素个数</li><li>广义表可以为其他广义表共享，即称为其他广义表的子表，或者包含其他广义表</li><li>任何一个非空广义表均可分解为表头和表尾两部分</li><li>广义表可以是递归的表</li></ol><h2 id="广义表的运算及定义"><a href="#广义表的运算及定义" class="headerlink" title="广义表的运算及定义"></a>广义表的运算及定义</h2><pre><code>GetLength(&amp;g) //求广义表的长度GetDepth(&amp;g)  //求广义表的深度PrintGL(&amp;g)      //打印广义表CreateGL()      //建立广义表//头尾链表存储结构typedef enum { ATOM, LIST } ElemTag; /* ATOM=0，表示原子；LIST=1，表示子表*/typedef struct GLNode{    ElemTag tag; /*标志位tag用来区别原子结点和表结点*/    union{        AtomType atom; /*原子结点的值域atom*/        struct { struct GLNode * hp, *tp; } htp; /*表结点的指针域htp， 包括表头指针域hp和表尾指针域tp*/    } atom_htp; /* atom_htp 是原子结点的值域atom和表结点的指针域htp的联合体域*/} *GList；//扩展性链表存储结构typedef enum { ATOM, LIST } ElemTag;typedef struct GLNode{    ELemTag tag;    union{        AtomType atom;        struct GLNode *hp;    }    struct GLNode *ht;}*GList;</code></pre><h2 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h2><p>广义表的数据元素有不同的结构，因此一般使用链式存储结构，常用的链式存储结构有两种：</p><ul><li>头尾链表的存储结构<ul><li>确定的表头和表尾可唯一确定广义表</li><li>表结点由三个域组成：标志域，表头指针域，表尾指针域</li><li>原子结点分为两个域：标志域和值域</li><li>标志域用于判断元素是原子还是子表</li></ul></li><li>扩展性链表的存储结构<ul><li>无论原子结点还是表表结点均由三个域组成</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点四则与算术逻辑单元</title>
    <link href="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/"/>
    <url>/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h1><h2 id="浮点加减运算"><a href="#浮点加减运算" class="headerlink" title="浮点加减运算"></a>浮点加减运算</h2><script type="math/tex;mode=display">x=S_x \times 2^{j_x}，y=S_y \times 2^{j_y}</script><h3 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h3><ol><li>求阶差<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/1.png" srcset="/img/loading.gif" width="350px" height="160px"><br>对阶就是判断两个浮点数的值是否相同，如果两数的阶码相同，直接可以加数值部分，即可完成相加，如果阶码不同，则需要对其进行对阶。</li><li>对阶原则，小阶向大阶看齐<br>如果大阶向小阶看齐，需要对其进行左移，容易将高位的1丢失，引发错误。而小阶向大阶看齐，需要对其进行右移，只会影响数据的精度，不会影响具体的数据大小</li></ol><p>例如：$x=0.1101 \times 2^{01},y=(-0.1010) \times 2^{11}$,求x+y<br>解： [x]<em>补=00,01;00.1101， [y]</em>补=00,11;11.0110</p><ol><li>对阶<ol><li>求阶差<script type="math/tex">[Δj]_补=[j_x]_补-[j_y]_补 =</script><br><script type="math/tex">00,01 + 11,01 = 11,10</script>，阶差为负(-2),所以$S_x-&gt;2,j_x+2$</li><li>对阶<script type="math/tex">[x]_补=00,11;00.0011</script></li></ol></li><li>尾数求和，<script type="math/tex">[S_x]_补+[S_y补]=00.0011+11.0110</script><br><script type="math/tex">=11.1001</script>，所以$[x+y]_补=00,11;11.1001$.</li></ol><blockquote><script type="math/tex;mode=display">-[j_y]_补，实际上等于+[-j_y]_补</script></blockquote><h3 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h3><ol><li>规格化数的定义，r=2，<script type="math/tex">1/2 \leq |S| <1</script>.</li><li>规格化数的判断<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/2.png" srcset="/img/loading.gif" width="350px" height="160px"><br>原码: 不论正数、负数，第一数位为1<br>补码: 符号位和第一数位不同</li></ol><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><ol><li><p>$[-1/2]_补$不是规格化的数</p><script type="math/tex;mode=display">S = -1/2 = -0.100\cdots0</script><script type="math/tex;mode=display">[S]_原=1.100\cdots0</script><script type="math/tex;mode=display">[S]_补=1.100\cdots0</script></li><li><p>$[-1]_补$是规格化的数</p><script type="math/tex;mode=display">S=-1</script><script type="math/tex;mode=display">[S]_补=1.000\cdots0</script></li></ol><h3 id="左规"><a href="#左规" class="headerlink" title="左规"></a>左规</h3><p>尾数左移一位，阶码-1，直到数符和第一数位不同为止<br>上例<script type="math/tex">[x+y]_补=00,11;11.1001</script><br>左规后<script type="math/tex">[x+y]_补=00,10;11.0010</script><br>则 x+y=(-0.1110)\times2^{10}</p><h3 id="右规"><a href="#右规" class="headerlink" title="右规"></a>右规</h3><p>当尾数溢出(&gt;1)时，需要右规<br>即尾数出现01.XX或10.XX时，尾数右移一位，阶码+1.</p><p>例：<script type="math/tex">x=0.1101 \times 2^{10},y = 0.1011\times 2^{01}</script>, 求x+y.<br>除阶符、数符外，阶码取3位，尾数取6位<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>在对阶和右规过程中，可能出现尾数末位丢失，引起误差，需考虑舍入。</p><ol><li>0舍1入法，如果末位是0丢弃，如果是1进位</li><li>恒置”1”法，末位始终置为1</li></ol><p>例：<script type="math/tex">x=(-5/8) \times 2^{-5}, y=(7/8)\times 2^{-4}</script>, 求x-y。<br>除阶符、数符外，阶码取3位，尾数取6位。<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/5.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><p>设机器数为补码，尾数为规格化形式，并假设阶符取2位，阶码的数值部分取7位，数符取2位，尾数取n位，则该补码在数轴上的表示为<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/7.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h2 id="算术逻辑单元-鸽了，看不懂"><a href="#算术逻辑单元-鸽了，看不懂" class="headerlink" title="算术逻辑单元(鸽了，看不懂)"></a>算术逻辑单元(鸽了，看不懂)</h2><h3 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h3><p>组合逻辑电路，$K_i$不同取值, $F_i$不同<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/8.png" srcset="/img/loading.gif" width="350px" height="160px"></p><blockquote><p>四位ALU 74181，M=0算术运算，M=1逻辑运算，$S_3$ - $S_0$不同取值，可做不同运算。</p></blockquote><h3 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h3><ol><li>并行加法器<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/9.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>串行进位链<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/10.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>并行进位链(先行进位，跳跃进位)<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/11.png" srcset="/img/loading.gif" width="350px" height="160px"><ol><li>单重分组跳跃进位链<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/12.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>双重分组跳跃进位链<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/13.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>双重分组跳跃进位链，大组进位分析<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/14.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>双重分组跳跃进位链的大组进位线路<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/15.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>双重分组跳跃进位链的小组进位线路<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/16.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>n=16双重分组跳跃进位链<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/17.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>n=32双重分组跳跃进位链<br><img src="/2020/05/13/%E6%B5%AE%E7%82%B9%E5%9B%9B%E5%88%99%E4%B8%8E%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/18.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2020/05/12/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/12/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a>栈的定义和特点</h2><p>栈(stack)是限定仅在表尾进行插入或删除的操作的线性表，表尾端称为栈顶，表头端称为栈底，不含元素的空表称为空栈，栈因为其特性又被称为后进先出(Last In First Out)的线性表。</p><h2 id="栈的ADT类型定义"><a href="#栈的ADT类型定义" class="headerlink" title="栈的ADT类型定义"></a>栈的ADT类型定义</h2><pre><code>InitStack(&amp;s) //构造一个空栈DestroyStack(&amp;s) //栈s存在，销毁栈ClearStack(&amp;s)        //栈s存在，清除栈StackEmpty(s)        //栈s存在，若栈为空返回true，否则返回falseStackLength(s)        //栈s存在，返回栈的长度GetTop(s)            //返回s的栈顶元素Push(&amp;s,e)            //插入元素e为新的栈顶元素Pop(&amp;s,&amp;e)            //栈s存在且非空，删除栈顶元素，返回其值StackTraverse(s)    //栈s存在且非空，遍历栈</code></pre><h3 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h3><ul><li>顺序栈的初始化<ul><li>为顺序栈分配地址空间，并让基地址指向这个空间</li><li>栈顶指针初始化，栈容量初始化</li></ul></li><li>顺序栈的入栈<ul><li>判断栈是否满，若满则返回ERROR</li><li>将新元素压入栈顶，栈顶指针+1</li></ul></li><li>顺序栈的出栈<ul><li>判断栈是否空，若空返回ERROR</li><li>栈顶指针-1，栈顶元素出栈</li></ul></li><li>取顺序栈的栈顶元素<ul><li>栈非空时，取栈顶元素的值</li></ul></li></ul><h4 id="顺序栈的代码实现-C"><a href="#顺序栈的代码实现-C" class="headerlink" title="顺序栈的代码实现(C++)"></a>顺序栈的代码实现(C++)</h4><pre><code>template &lt;class T&gt;class Stack{public:    Stack(unsigned int size);        //在构造器中初始化栈的大小    ~Stack();                        //析构器（释放内存）    void push(T value);    T pop();private:    unsigned int size;    unsigned int sp;    T *pointer;                        //栈指针};template &lt;class T&gt;Stack&lt;T&gt;::Stack(unsigned int size)        //隐含this指针指向这个方法{    this-&gt;size = size;    pointer = new T[size];            //分配这个栈的空间    sp = 0;                            //表示第0个元素}template &lt;class T&gt;Stack&lt;T&gt;::~Stack()            //析构器{    delete []pointer;                //释放构造器中开辟的空间（释放数组，需要加[]）}template &lt;class T&gt;void Stack&lt;T&gt;::push(T value){    pointer[sp++] = value;            //将数据压入栈中，然后栈指针指向下一个地址}template &lt;class T&gt;T Stack&lt;T&gt;::pop(){    return pointer[--sp];            //返回栈指针指向前一个地址的值}int main(){    const int size = 100;    Stack&lt;double&gt; mystack(size);    int n, a = 1;    int i;    char ch;    std::cout &lt;&lt; &quot;How many numbers (1-n) do you need to push?&quot; &lt;&lt; &quot;\n&quot;;    std::cin &gt;&gt; n;    try    {        for (i = 0; i &lt; n; i++)        //压栈(1-n)        {            if (i &gt;= 100)            {                throw &quot;崩溃！，栈溢出！！...&quot;;            }            mystack.push(a);            a++;        }        std::cout &lt;&lt; &quot;All pushed!&quot; &lt;&lt; &quot;\n&quot;;        getchar();        std::cout &lt;&lt; &quot;if you want to pop the stack of all numbers?(Y/N)&quot; &lt;&lt; &quot;\n&quot;;        if ((ch = getchar()) == &#39;Y&#39;)            for (int i = 0; i &lt; n; i++)                //弹栈                std::cout &lt;&lt; mystack.pop() &lt;&lt; &quot;\t&quot;;    }    catch (const char *a)        //catch(...)捕获任何异常    {        std::cout &lt;&lt; a;    }    return 0;}</code></pre><h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3><ul><li>链栈的初始化<ul><li>不需要设置头节点，直接将栈顶指针置空</li></ul></li><li>链栈的入栈<ul><li>为入栈结点分配空间</li><li>设置入栈结点的值</li><li>将新结点插入栈顶</li><li>修改栈顶指针为新节点的地址</li></ul></li><li>链栈的出栈<ul><li>判断栈是否为空</li><li>临时保存栈顶元素空间</li><li>修改栈指针指向新的栈顶元素</li><li>释放原栈顶元素空间</li></ul></li><li>取链栈的栈顶元素<ul><li>返回栈顶元素的值</li></ul></li></ul><h4 id="链栈的简单实现"><a href="#链栈的简单实现" class="headerlink" title="链栈的简单实现"></a>链栈的简单实现</h4><pre><code>struct Stack_l {    int data;    Stack_l *next;};struct Stack {    Stack_l * top;};int InitStack(Stack *s) {    s-&gt;top = NULL;    return 1;}int DestroyStack(Stack *s) {    free(s);    return 1;}int ClearStack(Stack *s) {    while (s != NULL) {        Stack *temp = s;        s-&gt;top = s-&gt;top-&gt;next;        free(temp);    }    s = NULL;    return 1;}int StackEmpty(Stack *s) {    if (s == NULL)        return 1;    else return 0;}int StackLength(Stack *s) {    int length = 0;    Stack_l *temp = s-&gt;top;    while (temp != NULL) {        temp  = temp-&gt;next;        ++length;    }    return length;}int GetTop(Stack *s) {    if(s != NULL) return s-&gt;top-&gt;data;    return 0;}int Push(Stack *s,int e) {    Stack_l *temp = (Stack_l*)malloc(sizeof(Stack_l));    temp-&gt;data = e;    temp-&gt;next = s-&gt;top;    s-&gt;top = temp;    return 1;}int Pop(Stack *s) {    if (s == NULL) return 0;    Stack_l *temp = s-&gt;top;    s-&gt;top = s-&gt;top-&gt;next;    int e = temp-&gt;data;    free(temp);    return e;}void StackTraverse(Stack *s) {    Stack_l *temp = s-&gt;top;    while (temp != NULL) {        cout &lt;&lt; temp-&gt;data &lt;&lt; endl;        temp = temp-&gt;next;    }}int main() {    Stack s;    InitStack(&amp;s);    Push(&amp;s, 1);Push(&amp;s, 2);    Push(&amp;s, 3);Push(&amp;s, 4);    StackTraverse(&amp;s);    Pop(&amp;s);    StackTraverse(&amp;s);    cout &lt;&lt; GetTop(&amp;s) &lt;&lt; StackLength(&amp;s);    getchar();    return 0;}</code></pre><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><p>递归是指，若在一个函数、过程或者数据结构定义的内部又直接或间接出现定义本身的应用，则称它们是递归的(函数自己调用自己)。以下三种情况，经常使用递归：</p><ol><li>定义是递归的，如斐波那契数列</li><li><p>数据结构是递归的，如链表结点有数据和指针组成，指针又由数据和指针组成，示例代码:</p><pre><code> void TraverseList(LinkList p){     if(p){         cout&lt;&lt;p-&gt;data&lt;&lt;endl;         TraverseList(p-&gt;next);     } }</code></pre></li><li><p>问题的解法是递归的，比如汉诺塔(Hanoi)问题</p></li></ol><h4 id="递归过程与递归工作栈"><a href="#递归过程与递归工作栈" class="headerlink" title="递归过程与递归工作栈"></a>递归过程与递归工作栈</h4><p>当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成3件事：</p><ol><li>将所有实参、返回地址等信息传递给被调用函数保存</li><li>为被调用函数的局部变量分配存储区</li><li>将控制转移到被调用函数的入口</li></ol><p>而从被调用函数返回调用函数之前，系统也应该完成3件工作</p><ol><li>保存被调函数的计算结果;</li><li>释放被调函数的数据区</li><li>依照被调函数保存的返回地址将控制转移到调用函数</li></ol><p>当有多个函数构成嵌套调用时，按照”后调用先返回”原则，上述函数之间的信息传递和控制需要通过”栈”来实现。</p><h4 id="递归算法的效率分析"><a href="#递归算法的效率分析" class="headerlink" title="递归算法的效率分析"></a>递归算法的效率分析</h4><ol><li><p>当一个算法中包含递归调用，时间复杂度可以转化成一个递归方程求解，在数学上是求渐近阶的问题，递归方程多样，求解也多样，迭代法是求解递归方程的主要方法，基本步骤为迭代展开递归方程右端，变为一个非递归的和式，通过对和式的估计求解。<br>以阶乘的递归函数Fact(n)为例：</p><pre><code> long Fact(long n){     long temp;     if(n==0) return 1;     else temp=n*Fact(n-1);     return temp; }</code></pre><p>设Fact(n)执行时间为T(n),此递归函数中语句if(n==0) return 1;的执行时间是O(1),递归调用Fact(n-1)的执行时间为T(n-1)，所以else return n*Fact(n-1)的执行时间为O(1)+T(n-1),其中设两数相乘和赋值操作均为O(1)，有如下递归方程：</p><script type="math/tex;mode=display">T(n)=\begin{cases}D& \text{n=0}\\C+T(n-1)& \text{n>=0}\end{cases}</script><p>设n&gt;2,利用上式对$T(n-1)$展开，即在上式中用n-1代替n得到</p><script type="math/tex;mode=display">T(n-1) = C+T(n-2)</script><p>再代入$T(n)=C+T(n-1)$中，有</p><script type="math/tex;mode=display">T(n)=2C+T(n-2)</script><p>同理，当n&gt;3时有</p><script type="math/tex;mode=display">T(n)=3C+T(n-3)</script><p>依此类推,当n&gt;i时有</p><script type="math/tex;mode=display">T(n)=iC+T(n-i)</script><p>最后当i=n时有</p><script type="math/tex;mode=display">T(n)=nC+T(0)=nC+D</script><p>求得递归方程的解为: $T(n)=O(n)$，通过这种方法计算斐波那契数列和汉诺塔普通递归算法时间复杂度均为$O(2^n)$</p></li><li>空间复杂度分析<br>执行递归函数时，系统设立一个”递归工作栈”存储每一层递归所需信息，递归算法空间复杂度需要分析工作栈的大小。<br>对于递归算法，空间复杂度<script type="math/tex;mode=display">S(n)=O(f(n))</script>其中f(n)为”递归空间栈”中工作记录的个数和问题规模n的函数关系。</li></ol><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ol><li>数制的转换</li><li>括号匹配</li><li>表达式求值</li></ol><h4 id="括号匹配代码示例"><a href="#括号匹配代码示例" class="headerlink" title="括号匹配代码示例"></a>括号匹配代码示例</h4><pre><code>#define MAX 100bool isMatch(char left,char right){    if (left == &#39;]&#39;)        return (right == &#39;[&#39;);    if (left == &#39;)&#39;)        return (right == &#39;(&#39;);    if (left == &#39;}&#39;)        return (right == &#39;{&#39;);    cout &lt;&lt; &quot;错误&quot;;}bool left_y(char c){    if (c == &#39;[&#39; || c == &#39;(&#39; || c == &#39;{&#39;)    {        return true;    }    else return false;}bool right_y(char c){    if (c == &#39;]&#39; || c == &#39;)&#39; || c == &#39;}&#39;)    {        return true;    }    else return false;}int main(){    stack&lt;char&gt; mystack;    int lenth = 0;    char str[MAX]{ 0 };     cin &gt;&gt; str;    while (str[lenth]){    //计算长度        lenth++;    }    while (lenth){        if (right_y(str[lenth-1])){            mystack.push(str[lenth-1]);        //如果是右括号入栈            lenth--;                        //下标减1        }        else if (left_y(str[lenth-1])){        //判断是否为左括号            if (mystack.empty()){            //如果栈为空，说明第括号不合法，push后退出循环                mystack.push(str[lenth - 1]);                break;            }            if (isMatch(mystack.top(), str[lenth-1])){                mystack.pop();                lenth--;                if (!mystack.empty())                { continue; }            }            else { break; }        }    }    if (mystack.empty()){cout &lt;&lt; &quot;匹配成功&quot;;}    else {cout &lt;&lt; &quot;匹配失败&quot;;}    cin.get();    return 0;}</code></pre><h4 id="表达式求值代码示例"><a href="#表达式求值代码示例" class="headerlink" title="表达式求值代码示例"></a>表达式求值代码示例</h4><pre><code>stack&lt;int&gt; num;stack&lt;char&gt; ch;int Compare(char c) {        //优先级比较    if (c == &#39;(&#39; || c == &#39;)&#39;) {        return 0;    }    if (c == &#39;+&#39; || c == &#39;-&#39;) {        return 1;    }    if (c == &#39;*&#39; || c == &#39;/&#39;) {        return 2;    }    return -1;}int Cal(int a, int b, int c) {    //计算    if (c == &#39;+&#39;) {        return a + b;    }    if (c == &#39;-&#39;) {        return b - a;    }    if (c == &#39;*&#39;) {        return a * b;    }    if (c == &#39;/&#39;) {        return b / a;    }    return 0;}int main() {    string str;    cin &gt;&gt; str;    for (int i = 0; i &lt;= str.length(); i++) {        if (str[i] &gt;= &#39;0&#39;&amp;&amp; str[i] &lt;= &#39;9&#39;) {    //如果是数字直接压入数字栈            int a = (int)(str[i] - 48);            num.push(a); continue;        }        if (str[i] == &#39;(&#39;) {        //左括弧直接压入字符栈            ch.push(str[i]); continue;        }        if (str[i] == &#39;+&#39; || str[i] == &#39;-&#39; || str[i] == &#39;*&#39; || str[i] == &#39;/&#39; || str[i] == &#39;)&#39; || str[i] == &#39;#&#39;) {            if (!ch.empty()) {                if ((Compare(str[i]) &gt; Compare(ch.top()))) {    //比较当前运算符与栈顶运算符的优先级，如果优先级大直接压栈                    ch.push(str[i]);                }                else if (ch.top() != &#39;(&#39; &amp;&amp; num.size() &gt;= 2) {    //栈顶是左括弧不继续计算，并且计算要求为数字栈至少两个元素                    int a, b;                    a = num.top(); num.pop();                    b = num.top(); num.pop();                    num.push(Cal(a, b, ch.top()));                    ch.pop(); i--; continue;  //栈中优先级小的符号出栈后，重置当前未入栈的符号。                }            }            else ch.push(str[i]);        }        if (str[i] == &#39;)&#39; &amp;&amp; !ch.empty()) {      //判断括号匹配(一定在计算数值后进行括号匹配)            if (ch.top() == &#39;(&#39;) ch.pop();        }    }    cout &lt;&lt; num.top();    cin.get();    cin.get();    return 0;}</code></pre><h2 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h2><p>队列是一种(queue)是一种先进先出(First In First Out,FIFO)的线性表，它只允许在表的一端进行插入，而在另一端删除元素。<br>在队列中，允许插入的一端称为队尾，允许删除的一端则称为队头(front).</p><h3 id="队列的ADT类型定义"><a href="#队列的ADT类型定义" class="headerlink" title="队列的ADT类型定义"></a>队列的ADT类型定义</h3><pre><code>InitQueue(&amp;Q)        //构造一个空栈DestroyQueue(&amp;Q)    //队列存在，销毁队列ClearQueue(&amp;Q)        //队列存在，清空队列QueueEmpty(&amp;Q)        //队列存在，判断队列为空QueueLength(&amp;Q)        //队列存在，返回队列长度GetHead(&amp;Q)            //队列不为空，返回队列队头元素EnQueue(&amp;Q,e)        //队列存在，插入新的队尾元素eDeQueue(&amp;Q，&amp;e)        //队列非空，删除队头元素，返回其值QueueTraverse(Q)    //队列存在且非空，遍历队列</code></pre><h3 id="队列的顺序表示和实现-循环队列"><a href="#队列的顺序表示和实现-循环队列" class="headerlink" title="队列的顺序表示和实现(循环队列)"></a>队列的顺序表示和实现(循环队列)</h3><ul><li>循环队列的初始化<ul><li>为队列分配数组空间，基地址指向数组首地址</li><li>头尾指针置0</li></ul></li><li>求队列长度<ul><li>头尾指针的差值加队列最大长度</li></ul></li><li>循环队列入队操作<ul><li>判断队列是否满</li><li>将新元素插入队尾</li><li>队尾指针+1</li></ul></li><li>循环队列出队操作<ul><li>判断队列是否为空</li><li>保存队头元素</li><li>队头指针+1</li></ul></li><li>取队头元素<ul><li>判断队列是否为空</li><li>返回当前队头元素的值</li></ul></li></ul><h4 id="循环队列顺序存储的简易代码实现"><a href="#循环队列顺序存储的简易代码实现" class="headerlink" title="循环队列顺序存储的简易代码实现"></a>循环队列顺序存储的简易代码实现</h4><pre><code>#define MAXSIZE 10typedef struct Queue {    int *base;    int front;    int rear;    int length;}Queue;int InitQueue(Queue *q) {    q-&gt;base = new int[MAXSIZE];    q-&gt;front = 0;    q-&gt;rear = 0;    q-&gt;length = 0;    return 1;}void DestroyQueue(Queue *q) {    free(q);}void ClearQueue(Queue *q) {    q-&gt;front = 0;    q-&gt;rear = 0;}int QueueEmpty(Queue q) {    if (q.length == 0){        return 1;    }    return 0;}int QueueLength(Queue q) {    return q.length - 1;        //第十位空出，用来判断队列是否满，所以实际长度只有9位}int GetHead(Queue q) {    if (q.base != NULL) return q.base[q.front];    return 1;}int EnQueue(Queue *q,int e) {    if ((q-&gt;rear+1)%MAXSIZE != q-&gt;front) {    //队列未满且        q-&gt;base[q-&gt;rear] = e;        q-&gt;rear++;        q-&gt;rear = q-&gt;rear % MAXSIZE;        q-&gt;length++;        return 1;    }    return -1;}int DeQueue(Queue *q) {    if (q-&gt;length &gt; 0) {        q-&gt;front++;        q-&gt;front = q-&gt;front % MAXSIZE;        q-&gt;length--;    }    return 1;}void QueueTraverse(Queue q) {    int num = 0;    for (int i = q.front; num &lt; q.length; num++,i++) {        i = i % MAXSIZE;        cout&lt;&lt;q.base[i]&lt;&lt;endl;    }}int main() {    Queue q;    InitQueue(&amp;q);    EnQueue(&amp;q, 1);EnQueue(&amp;q, 2);EnQueue(&amp;q, 3);    EnQueue(&amp;q, 4);EnQueue(&amp;q, 5);EnQueue(&amp;q, 6);    EnQueue(&amp;q, 7);EnQueue(&amp;q, 8);EnQueue(&amp;q, 9);    cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; EnQueue(&amp;q, 10) &lt;&lt; endl;;    DeQueue(&amp;q);DeQueue(&amp;q);DeQueue(&amp;q);    DeQueue(&amp;q);DeQueue(&amp;q);    EnQueue(&amp;q, 1);EnQueue(&amp;q, 2);EnQueue(&amp;q, 3);    QueueTraverse(q);    cout&lt;&lt;&quot;队头&quot;&lt;&lt;GetHead(q)&lt;&lt;endl;    getchar();    return 0;}</code></pre><h3 id="队列的链式表示和实现"><a href="#队列的链式表示和实现" class="headerlink" title="队列的链式表示和实现"></a>队列的链式表示和实现</h3><ul><li>链队的初始化<ul><li>生成新节点作为头节点，队头和队尾指针指向此结点</li><li>头结点的指针域置空</li></ul></li><li>链队的入队<ul><li>为入队元素分配空间</li><li>设置新结点数据域</li><li>将新结点插入队尾</li><li>修改队尾指针</li></ul></li><li>链队的出队<ul><li>判断队列是否为空</li><li>临时保存队头元素地址空间</li><li>修改头结点指向</li><li>修改队尾指针</li><li>释放原队头元素空间</li></ul></li><li>取链队的队头元素<ul><li>判断队列是否非空</li><li>返回队头元素的值</li></ul></li></ul><h4 id="链队的代码简易实现"><a href="#链队的代码简易实现" class="headerlink" title="链队的代码简易实现"></a>链队的代码简易实现</h4><pre><code>#define MAX 10struct Point{    int num;    Point *next;};struct List{    int num = 0;    //记录节点数量    Point * rear;    //队尾元素    Point * front;    //队首元素};Point* cs_list(List *list);            //初始化队列bool full_list(List *front);        //确认队列是否已满bool empty_list(List *front);        //确认队列是否为空Point* add_list(List *list);        //在队列末尾添加元素void del_list(List *list);            //删除队列首元素void find_list(List *list);            //查找队列的元素void input_list(List *list);        //输出队列的元素Point* cs_list(List *list)        //队列初始化{    list-&gt;rear = (Point*)malloc(sizeof(Point));    //分配空间，将地址赋给point的首节点    list-&gt;num++;                    //使队列节点数加一    list-&gt;front = list-&gt;rear;        //使队列的尾节点等于队列首节点的指针    scanf_s(&quot;%d&quot;, &amp;list-&gt;rear-&gt;num);    list-&gt;rear-&gt;next = NULL;        //使结点的下一个链接点为空    return list-&gt;rear;                //返回该地址}bool full_list(List *list)        //确认队列是否已满，已满返回true，否则返回false{            if (list-&gt;num &gt;= MAX)    //观察num（节点数）是否为最大值            return true;        else            return false;}bool empty_list(List *list)        //确认队列是否为空，为空返回true，不为空返回false{    if (list-&gt;num == 0)        return true;    else         return false;}Point* add_list(List *list)            //入队列{    Point *temp = (Point*)malloc(sizeof(Point));    //分配空间    list-&gt;rear-&gt;next = temp;    list-&gt;rear = list-&gt;rear-&gt;next;    list-&gt;num++;                    //如果分配成功，使结点数+1    scanf_s(&quot;%d&quot;, &amp;list-&gt;rear-&gt;num);    list-&gt;rear-&gt;next = NULL;    return list-&gt;rear;                //返回该地址}int del_list(List *list)                    //出队列{    Point *temp = list-&gt;front;                //temp储存队首元素    list-&gt;front = list-&gt;front-&gt;next;        //队首元素向后移一位    list-&gt;num--;    int temp_num = temp-&gt;num;    free(temp);                    return temp_num;                }void input_list(List *list){    List *list1 = list;    printf(&quot;%d&quot;, list-&gt;num);    while (list1-&gt;front != NULL)    {        printf(&quot;%d&quot;, list-&gt;front-&gt;num);        list1-&gt;front = list-&gt;front-&gt;next;    }}Point* find_list(List *list,int n){    Point *temp = list-&gt;front;    while (temp-&gt;num != NULL)    {        if (temp-&gt;num == n)            return temp;        else            temp = temp-&gt;next;    }    return NULL;}int main(){    List list;    if (cs_list(&amp;list))    {        printf(&quot;初始化队列成功！\n&quot;);    }    if (full_list(&amp;list))    {        printf(&quot;队列已满\n&quot;);    }    else    {        printf(&quot;队列未满\n&quot;);    }    add_list(&amp;list);    printf(&quot;\n&quot;);    add_list(&amp;list);    printf(&quot;\n&quot;);    del_list(&amp;list);    printf(&quot;\n&quot;);    Point * temp = find_list(&amp;list, 368);    if (temp)    {        printf(&quot;%d&quot;, temp-&gt;num);        printf(&quot;\n&quot;);    }    input_list(&amp;list);    getchar();    getchar();    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2020/05/11/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/05/11/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。<br>同一线性表中的元素必定具有相同的特性，即同属于统一数据对象，相邻数据元素之间存在着序偶关系。<br>由n(n&gt;=0)个数据特性相同的元素构成的有限序列称为线性表。<br>线性表中元素的个数n(n&gt;=0)定义为线性表的长度,n=0时称为空表。</p><h2 id="非空线性表的特点"><a href="#非空线性表的特点" class="headerlink" title="非空线性表的特点"></a>非空线性表的特点</h2><ol><li>存在唯一的一个被称作”第一个 “的数据元素;</li><li>存在唯一的一个被称作”最后一个”的数据元素;</li><li>除第一个之外，结构中的每个数据元素均只有一个前驱;</li><li>除最后一个之外,结构中的每个数据元素均只有一个后继。</li></ol><h2 id="线性表ADT定义"><a href="#线性表ADT定义" class="headerlink" title="线性表ADT定义"></a>线性表ADT定义</h2><pre><code>InitList(&amp;L)        //构造一个空的线性表LDestroyList(&amp;L)        //线性表存在状况下，销毁线性表ClearList(&amp;L)        //线性表存在状况下，将表置空ListEmpty(L)        //线性表存在，空表返回true，否则返回falseListLength(L)        //返回表中数据元素个数GetElem(L,i,&amp;e)        //线性表存在，用e返回L中第i个数据元素的值LocateElem(L,e)        //线性表存在，返回表中第一个与e相同的元素位置，不存在返回0PriorElem(L,cur_e,&amp;pre_e)    //若cur_e不是第一个元素，返回其前驱;NextElem(L,cur_e,&amp;next_e)    //cur_e不是最后一个元素，返回其后继ListInsert(&amp;L,i,e)            //L中第i个位置之前插入新元素e，L长度+1ListDelete(&amp;L,i)            //删除第i个数据元素，L长度-1TraverseList(L)                //遍历线性表</code></pre><h2 id="线性表的实现方法"><a href="#线性表的实现方法" class="headerlink" title="线性表的实现方法"></a>线性表的实现方法</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>用一组地址连续的存储单元依次存储线性表的数据元素。，称为顺序表。<br>逻辑上相邻的数据元素，其物理次序也是相邻的;<br>假设线性表每个元素占用l个存储单元，线性表中第i+1个数据元素的存储位置$LOC(a_i+1)$和第i个数据元素的存储位置$LOC(a_i)$之间满足下列关系：</p><script type="math/tex;mode=display">LOC(a_i+1)=LOC(a_i)+l</script><p>一般来说，线性表的第i个元素ai的存储位置为:</p><script type="math/tex;mode=display">LOC(a_i)=LOC(a_i)+(i-1)*l</script><p>线性表的顺序存储结构是一种随机存取结构。</p><ol><li>初始化： 为线性表分配预定义大小的数组空间，将表长度设为0</li><li>取值： 判断i值是否在表内，若i合理，则将第i个元素赋值给e，时间复杂度$O(1)$.</li><li>查找： 从第一个元素起，循环比较第一个与e相等的值，查找成功返回位置,时间复杂度$O(n)$.</li><li>插入： 判断插入位置是否合法，表是否已满，将后面的元素依次后移，空出的位置插入元素，表长+1,$ASL=O(n)$.</li><li>删除： 判断删除是否合法，后面的元素依次前移，表长-1,$ASL=O(n)$.</li></ol><blockquote><p>ALS(Average Search Length): 平均查找长度</p></blockquote><h3 id="代码简单实现"><a href="#代码简单实现" class="headerlink" title="代码简单实现"></a>代码简单实现</h3><pre><code>#define MAXSIZE 10typedef struct List{    int length;    int *elem;    //基地址}List;void InitList(List *l) {    l-&gt;elem = (int*)malloc(sizeof(int)*MAXSIZE);        //分配空间大小    l-&gt;length = 0;        //长度初始化}int GetElem(List l,int i) {        //取值    if (0 &lt;= i &lt;= l.length) {        return l.elem[i];    }    return -1;}int LocateElem(List l,int e) {        //查找    for (int i = 0; i &lt; l.length; i++) {        if (l.elem[i] == e) {            return i;        }    }    return -1;}int ListInsert(List *l, int i, int e) {    //插入    if (i &gt; l-&gt;length || i &lt; 0) { return -1; }    for (int j = l-&gt;length; j &gt;= i; j--) {        l-&gt;elem[j + 1] = l-&gt;elem[j];    }    l-&gt;elem[i] = e;    l-&gt;length++;    return 1;}int ListDelete(List l, int i) {        //删除    if (i&lt;0 || i&gt;l.length) { return -1; }    for (int j = i; j &lt; l.length; j++) {        l.elem[j] = l.elem[j + 1];    }    l.length--;    return 1;}int main() {        //测试    List l;    InitList(&amp;l);    ListInsert(&amp;l, 0, 3);    ListInsert(&amp;l, 1, 6);    printf(&quot;%d,%d&quot;, l.elem[0],l.elem[1]);    ListDelete(l, 1);    printf(&quot;%d,%d&quot;, l.elem[0], l.elem[1]);    getchar();    return 0;}</code></pre><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>用一组任意的存储单元存储线性表的数据元素，存储单元可以不连续，为了表示数据元素与其后继元素之间的逻辑关系，除了存储数据本身信息之外，还需要存储一个指示其直接后继的信息。<br>这两部分信息组成数据元素的存储映像，称为结点，包括两个域：数据域(存储信息),指针域(存储后继结点的地址)。此链表每个结点只包含一个指针域，称为单链表。<br>单链表是非随机存取的存储结构，取得第i个数据元素必须从头指针开始顺链进行查找，也成为顺序存取的存取结构。</p><h3 id="头节点的作用"><a href="#头节点的作用" class="headerlink" title="头节点的作用"></a>头节点的作用</h3><p>一般情况下，为了处理方便，在单链表第一个结点前附加一个头节点，优点如下：</p><ul><li>便于首元结点的处理</li><li>便于空表和非空表的统一处理</li></ul><h3 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h3><ul><li>单链表初始化<ul><li>生成新结点作为头节点</li><li>头结点指针指向空</li></ul></li><li>单链表取值，$O(n)$<ul><li>指针p指向首节点</li><li>从首节点开始依次顺链查找，当前p不为空，且没有达到i结点，循环向下查找，j计数达到i时，结束查找。</li><li>如果循环结束后，j大于i，或这取值为空，说明i不合法，否则取值成功。</li></ul></li><li>单链表按值查找，$O(n)$<ul><li>指针p指向首元。</li><li>从首元依次向下查找，p所指向的数据不为e，则继续p指针+1，循环操作。</li><li>若查找成功，返回相应地址，否则返回NULL;</li></ul></li><li>单链表插入,$O(n)$<ul><li>判断插入的位置，如果在首元前插入，需要将当前首元地址赋值给插入结点的next，并且将新插入结点设置为首元。</li><li>如果在链表结尾插入，直接将最后结点的next赋值为新插入节点的地址，并且将新节点next置为空。</li><li>如果在链表中间插入，需要查找插入结点之后的节点地址，将其赋值给新节点的next，并查找插入节点之前节点的地址将其的next赋值为新节点地址。</li></ul></li><li>单链表删除,$O(n)$<ul><li>同插入操作一样，需要判断删除节点的位置的三种情况，并分别进行操作。</li></ul></li></ul><blockquote><p>单链表插入操作分为：前插法，后插法</p></blockquote><h3 id="链表简单实现"><a href="#链表简单实现" class="headerlink" title="链表简单实现"></a>链表简单实现</h3><pre><code>struct Node {    int data;    Node* next;};struct List {    Node* Head;    Node* Last;    Node* p;    int num;        //结点数量};List* CreatList(List* list) {    list-&gt;Head = (Node*)malloc(sizeof(Node));  //头节点分配空间    list-&gt;Last = list-&gt;Head;    list-&gt;Head-&gt;next = NULL;    list-&gt;p = list-&gt;Head;    list-&gt;num = 1;    return list;}Node* NodeInsert(List* list) {            //尾插法    Node* temp = (Node*)malloc(sizeof(Node));    list-&gt;Last-&gt;next = temp;    temp-&gt;next = NULL;    list-&gt;Last = list-&gt;Last-&gt;next;    list-&gt;num++;    return temp;}Node* NodeInsert(List* list, int num, int date) {    //指定位置插入结点    Node* temp = (Node*)malloc(sizeof(Node));    temp-&gt;data = date;    Node* find = list-&gt;p;    while (find-&gt;data != num) {        //找到指定位置的结点        find = find-&gt;next;    }    //头节点前插入    if (find == list-&gt;Head) {        temp-&gt;next = list-&gt;Head;        list-&gt;Head = temp;        list-&gt;p = list-&gt;Head;    }    //尾结点后插入    else if (find == list-&gt;Last) {        list-&gt;Last-&gt;next = temp;        temp-&gt;next = NULL;        list-&gt;Last = temp;    }    else {        Node* temp1 = find-&gt;next-&gt;next;        find-&gt;next = temp;        temp-&gt;next = temp1;    }    list-&gt;num++;    return temp;}void ListTraversal(List* list) {    //遍历    Node* temp = list-&gt;p;    int i = 1;    while (temp != NULL) {        temp-&gt;data = i;        temp = temp-&gt;next;        i++;    };}void ListPrint(List* list) {        //遍历打印    Node* temp = list-&gt;p;    while (temp != NULL) {        cout &lt;&lt; (temp-&gt;data) &lt;&lt; endl;        temp = temp-&gt;next;    }}int NodeDelete(List* list, int num) {    Node* temp = list-&gt;p;    while (temp-&gt;data != num) {        temp = temp-&gt;next;    }    //删除头节点    if (temp == list-&gt;Head) {        Node* temp1 = list-&gt;Head;        list-&gt;Head = list-&gt;Head-&gt;next;        list-&gt;p = list-&gt;Head;        delete(temp1);    }    //删除其他结点    else {        Node* temp1 = temp-&gt;next;        temp-&gt;next = temp-&gt;next-&gt;next;        delete(temp1);    }    list-&gt;num--;    return 1;}//测试int main() {    List list1;    CreatList(&amp;list1);    //循环生成结点    int i = 0;    while (i &lt; 6) {        NodeInsert(&amp;list1);        i++;    }    //遍历赋值链表    ListTraversal(&amp;list1);    //特定位置插入赋值的结点(链表地址，结点位置前插入，插入结点的数据值)    NodeInsert(&amp;list1, 2, 8);    //删除结点    NodeDelete(&amp;list1, 1);    ListPrint(&amp;list1);    cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;结点数量为&quot; &lt;&lt; list1.num &lt;&lt; endl;    cin.get();    return 0;}</code></pre><h2 id="链表扩展"><a href="#链表扩展" class="headerlink" title="链表扩展"></a>链表扩展</h2><ul><li>循环链表，链表尾节点连接首节点，成环</li><li>双向链表，链表分为两个指针域，一个指向前驱，一个指向后继</li></ul><h3 id="双向链表举例"><a href="#双向链表举例" class="headerlink" title="双向链表举例"></a>双向链表举例</h3><pre><code>struct Node {    int data;    Node* pre;    Node* next;};struct List {    Node* Head;    Node* Last;    Node* p;    int num;        //结点数量};List* CreatList(List* list) {    list-&gt;Head = (Node*)malloc(sizeof(Node));    list-&gt;Last = list-&gt;Head;    list-&gt;Head-&gt;pre = NULL;    list-&gt;Head-&gt;next = NULL;    list-&gt;p = list-&gt;Head;    list-&gt;num = 1;    return list;}Node* NodeInsert(List* list) {    Node* temp = (Node*)malloc(sizeof(Node));    list-&gt;Last-&gt;next = temp;    temp-&gt;next = NULL;    temp-&gt;pre = list-&gt;Last;    list-&gt;Last = list-&gt;Last-&gt;next;    list-&gt;num++;    return temp;}Node* NodeInsert(List* list, int num,int date) {    Node* temp = (Node*)malloc(sizeof(Node));    temp-&gt;data = date;    Node* find = list-&gt;p;    while (find-&gt;data != num) {        find = find-&gt;next;    }    //头节点前插入    if (find == list-&gt;Head) {        list-&gt;Head-&gt;pre = temp;        temp-&gt;pre = NULL;        temp-&gt;next = list-&gt;Head;        list-&gt;Head = temp;        list-&gt;p = list-&gt;Head;    }    //尾结点后插入    else if (find == list-&gt;Last) {        list-&gt;Last-&gt;next = temp;        temp-&gt;pre = list-&gt;Last;        list-&gt;Last = temp;    }    else {        find-&gt;pre-&gt;next = temp;        temp-&gt;next = find;        temp-&gt;pre = find-&gt;pre;        find-&gt;pre = temp;    }    list-&gt;num++;    return temp;}void ListTraversal(List* list) {    Node* temp = list-&gt;p;    int i = 1;    while (temp != NULL){        temp-&gt;data = i;        temp = temp-&gt;next;        i++;    };}void ListPrint(List* list) {    Node* temp = list-&gt;p;    while (temp != NULL){        cout&lt;&lt;(temp-&gt;data)&lt;&lt;endl;        temp = temp-&gt;next;    }}Node* NodeDelete(List* list,int num) {    Node* temp = list-&gt;p;    while (temp-&gt;data != num) {        temp = temp-&gt;next;    }    //删除头节点    if (temp == list-&gt;Head) {        list-&gt;Head = list-&gt;Head-&gt;next;        list-&gt;Head-&gt;pre = NULL;        list-&gt;p = list-&gt;Head;    }    //删除尾结点    else if (temp == list-&gt;Last) {        list-&gt;Last = temp-&gt;pre;        temp-&gt;pre-&gt;next = NULL;        temp-&gt;pre = NULL;    }    else{        temp-&gt;pre-&gt;next = temp-&gt;next;        temp-&gt;next-&gt;pre = temp-&gt;pre;    }    list-&gt;num--;    return temp;}//测试int main() {    List list1;    CreatList(&amp;list1);    //循环生成结点    int i = 0;    while (i &lt; 6) {        NodeInsert(&amp;list1);        i++;    }    //遍历赋值链表    ListTraversal(&amp;list1);    //特定位置插入赋值的结点(链表地址，结点位置前插入，插入结点的数据值)    NodeInsert(&amp;list1, 1, 8);    //删除结点    //Node* temp = NodeDelete(&amp;list1, 1);    //cout &lt;&lt; temp-&gt;data &lt;&lt; endl;    ListPrint(&amp;list1);    cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;结点数量为&quot; &lt;&lt; list1.num &lt;&lt; endl;    cin.get();    return 0;}</code></pre><h2 id="顺序表和链表比较"><a href="#顺序表和链表比较" class="headerlink" title="顺序表和链表比较"></a>顺序表和链表比较</h2><h3 id="空间性能比较"><a href="#空间性能比较" class="headerlink" title="空间性能比较"></a>空间性能比较</h3><ol><li>存储空间的分配,顺序表需要预先分配空间，无法扩充大小。</li><li>存储密度的大小，链表需要设置指针域，从存储密度上是不经济的。</li></ol><blockquote><p>存储密度=数据元素本身占用的存储量/结点结构占用的存储量</p></blockquote><h3 id="时间性能比较"><a href="#时间性能比较" class="headerlink" title="时间性能比较"></a>时间性能比较</h3><ol><li>存取元素效率，顺序表随机存储$O(1)$,链表顺序存储$O(n)$.</li><li>插入和删除操作效率,顺序表需要移动元素空出空间$O(n)$，链表直接修改指针实现增删$O(1)$;</li></ol><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><ol><li>线性表合并，求解一般集合的并集问题</li><li>有序表合并，求解有序表并集问题，例如一元多项式与稀疏多项式的运算问题。</li></ol><h3 id="稀疏多项式代码示例"><a href="#稀疏多项式代码示例" class="headerlink" title="稀疏多项式代码示例"></a>稀疏多项式代码示例</h3><pre><code>struct Node {    int xishu;    int zhishu;    Node* next;};struct List {    Node* Head;    Node* Last;    Node* p;    int num;        //结点数量};List* CreatList(List* list) {    list-&gt;Head = (Node*)malloc(sizeof(Node));    list-&gt;Last = list-&gt;Head;    list-&gt;Head-&gt;xishu = 0;    list-&gt;Head-&gt;zhishu = 0;    list-&gt;Head-&gt;next = NULL;    list-&gt;p = list-&gt;Head;    list-&gt;num = 1;    return list;}Node* NodeInsert(List* list, int xishu,int zhishu) {    Node* temp = (Node*)malloc(sizeof(Node));    list-&gt;Last-&gt;next = temp;    temp-&gt;next = NULL;    temp-&gt;xishu = xishu;    temp-&gt;zhishu = zhishu;    list-&gt;Last = list-&gt;Last-&gt;next;    list-&gt;num++;    return temp;}void ListPrint(List* list) {    Node* temp = list-&gt;Head-&gt;next;    while (temp != NULL) {        cout &lt;&lt;&quot;系数：&quot; &lt;&lt;temp-&gt;xishu &lt;&lt;&quot;指数：&quot;&lt;&lt; temp-&gt;zhishu &lt;&lt; endl;        temp = temp-&gt;next;    }}List* addList(List* list1, List* list2) {    List listSum;    List* newp = CreatList(&amp;listSum);    Node* p1,* p2;    p1 = list1-&gt;Head-&gt;next;    p2 = list2-&gt;Head-&gt;next;    while (p1 != NULL &amp;&amp; p2 !=NULL) {        if (p1-&gt;zhishu &lt; p2-&gt;zhishu &amp;&amp; p1 != NULL &amp;&amp; p2 != NULL) {            NodeInsert(&amp;listSum, p1-&gt;xishu, p1-&gt;zhishu);            p1 = p1-&gt;next;        }        if (p1 != NULL &amp;&amp; p2 != NULL) {            if (p1-&gt;zhishu == p2-&gt;zhishu) {                NodeInsert(&amp;listSum, p1-&gt;xishu + p2-&gt;xishu, p1-&gt;zhishu);                p1 = p1-&gt;next;                p2 = p2-&gt;next;            }        }        if (p1 != NULL &amp;&amp; p2 != NULL) {            if (p1-&gt;zhishu &gt; p2-&gt;zhishu) {                NodeInsert(&amp;listSum, p2-&gt;xishu, p2-&gt;zhishu);                p2 = p2-&gt;next;            }        }    }    while (p1 != NULL) {        NodeInsert(&amp;listSum, p1-&gt;xishu, p1-&gt;zhishu);        p1 = p1-&gt;next;    }    while (p2 != NULL) {        NodeInsert(&amp;listSum, p2-&gt;xishu, p2-&gt;zhishu);        p2 = p2-&gt;next;    }    ListPrint(newp);    return newp;}int main() {    List list1, list2;    //初始化    CreatList(&amp;list1);    CreatList(&amp;list2);    //构造多项式1    int i = 1;    while (i) {        cout &lt;&lt; &quot;list1是否添加项1:是，0：不是&quot; &lt;&lt; endl;        cin &gt;&gt; i;        if (i == 0)break;        cout &lt;&lt; &quot;请输入系数和指数&quot; &lt;&lt; endl;        int xishu, zhishu;        cin &gt;&gt; xishu &gt;&gt; zhishu;        NodeInsert(&amp;list1, xishu, zhishu);    }    i = 1;    while (i) {        cout &lt;&lt; &quot;list2是否添加项1:是，0：不是&quot; &lt;&lt; endl;        cin &gt;&gt; i;        if (i == 0)break;        cout &lt;&lt; &quot;请输入系数和指数&quot; &lt;&lt; endl;        int xishu, zhishu;        cin &gt;&gt; xishu &gt;&gt; zhishu;        NodeInsert(&amp;list2, xishu, zhishu);    }    cout &lt;&lt; &quot;list1:&quot;&lt;&lt;endl; ListPrint(&amp;list1);    cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;list2:&quot;&lt;&lt;endl; ListPrint(&amp;list2);    cout &lt;&lt; &quot;-------结果--------&quot; &lt;&lt; endl;    addList(&amp;list1, &amp;list2);    while (1) { cin.get(); }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h1><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构研究数据之间的内在关系，合理组织数据，设计高效的算法，用于解决数学问题。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p><h2 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h2><ul><li>数据，如数学计算中用到的整数和实数，文本编辑中用到的字符串，以及经过特殊编码定义后的数据</li><li>数据元素，是数据的基本单位，数据元素用于完整的描述一个对象</li><li>数据项，是组成数据元素的、有独立含义的、不可分割的最小单位。</li><li>数据对象，是性质相同的数据元素的集合，是数据的子集。</li></ul><h2 id="数据的逻辑结构和存储结构"><a href="#数据的逻辑结构和存储结构" class="headerlink" title="数据的逻辑结构和存储结构"></a>数据的逻辑结构和存储结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>集合结构，数据元素之间除了”属于同一集合”的关系外，别无其他关系。</li><li>线性结构，数据元素之间存在一对一的关系。</li><li>树结构，数据元素之间存在一对多的关系。</li><li>图结构或网状结构，数据元素之间存在多对多的关系。</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储结构，特点是数据存放在连续的内存空间内，可以直接对某个元素进行访问。</li><li>链式存储结构，特点是数据存放在不连续的内存空间，无需占用一整块存储空间，但需要对每一个结点附加指针用于存放后继结点的地址，无法直接对某一个元素进行访问。</li></ul><h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是高级程序设计语言中的一个基本概念，编程语言中规定好的，例如int,float,double,boolean,long,char等。<br>数据类型是一个值得集合和定义在这个值集上得一组操作的总称。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象就是抽取出实际问题的本质，抽象数据类型(Abstract Data Type,ADT)一般指由用户定于的、表示应用问题的数学模型，以及这个模型的操作总称。<br>抽象数据类型的概念与面向对象方法的思想是一致的。</p><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><h3 id="算法的定义及特性"><a href="#算法的定义及特性" class="headerlink" title="算法的定义及特性"></a>算法的定义及特性</h3><ul><li>有穷性，算法必须在一定时间内能执行完。</li><li>确定性，算法应不会产生二义性，对于每种情况，应该有确切的操作。</li><li>可行性，算法的所有操作应该可以基于基本操作并且在有限时间内完成。</li><li>输入，算法有零个或多个输入。</li><li>输出，算法有零个或多个输出。</li></ul><h3 id="评价算法优劣的基本标准"><a href="#评价算法优劣的基本标准" class="headerlink" title="评价算法优劣的基本标准"></a>评价算法优劣的基本标准</h3><ul><li>正确性，在合理的数据输入下，当数据规模足够大时，都能在有限的时间内得到正确的结果。</li><li>可读性，好的算法，应该便于人们理解和相互交流。</li><li>健壮性，当输入的数据非法时，好的算法能适当地做出正确反应或者相应地处理。</li><li>高效性，高效性包括时间和空间两个方面，时间复杂度与空间复杂度。</li></ul><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>衡量算法效率的方法主要分为：</p><ul><li>事后统计法，先将算法实现，然后测算其时间和空间开销。</li><li>事前分析法，通常采用事前分析估算法，计算复杂度衡量算法的效率。</li></ul><p>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。<br>一条语句的重复执行次数称为<strong>语句频度</strong>。</p><h3 id="时间复杂度的定义"><a href="#时间复杂度的定义" class="headerlink" title="时间复杂度的定义"></a>时间复杂度的定义</h3><p>算法代码举例</p><pre><code>for(i=1;i&lt;=n;i++)                            //频度为n+1    for(j=1;j&lt;=n;j++){                        //频度为n*(n+1)            c[i][j]=0;                            //频度为n^2        for(k=1;k&lt;=n;k++)                    //频度为n^2 * (n+1)        c[i][j]= c[i][j]+a[i][j]*b[i][j];    //频度为n^3    }</code></pre><p>该算法中所有语句频度之和，是矩阵阶数n的函数，用f(n)表示。</p><script type="math/tex;mode=display">f(n)=2n^3+3n^2+2n+1</script><p>对于相对简单的算法，可以直接计算算法所有语句的频度。当问题规模变大时，我们只需要考虑问题规模充分大时，算法中基本语句执行次数在渐近意义下的阶。</p><script type="math/tex;mode=display">\lim\limits_{x\rightarrow\infty}f(n)/n^3=</script><script type="math/tex;mode=display">\lim\limits_{x\rightarrow\infty}(2n^3+3n^2+2n+1)/n^3=2</script><p>当n充分大时，$f(n)$和$n^3$是同阶的，即数量级相同，用”O”表示数量级，记作$T(n)=O(f(n))=O(n^3)$。<br>一般来说，算法中基本语句重复执行的次数是问题规模n的某个函数$f(n)$,算法的时间量度记作$T(n)=O(f(n))$,它表示随问题规模n的增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的渐近时间复杂度。</p><blockquote><p>数学符号”O”的严格定义为：<br>若$T(n)$和$f(n)$是定义在正整数集合上的两个函数，则$T(n)=O(f(n))$表示存在正的常数C和$n_0$,使得当$n\geq n_0$时都满足$0\leq T(n)\leq C_f(n)$.</p></blockquote><h3 id="算法时间复杂度分析举例"><a href="#算法时间复杂度分析举例" class="headerlink" title="算法时间复杂度分析举例"></a>算法时间复杂度分析举例</h3><p>基本方法: 找出所有语句中语句频度最大的语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数$f(n)$,取其数量级用符号”O”表示。<br>定理：<script type="math/tex">f(n)=a_mn^m+a_{m-1}n^{m-1}+\ldots+a_1n+a_0</script>是一个m次多项式，则$T(n)=O(n^m)$.</p><h4 id="常量阶示例"><a href="#常量阶示例" class="headerlink" title="常量阶示例"></a>常量阶示例</h4><pre><code>{x++;s=0;}</code></pre><p>两条语句频度都为1，算法时间复杂度为$T(n)=O(1)$.</p><h4 id="线性阶示例"><a href="#线性阶示例" class="headerlink" title="线性阶示例"></a>线性阶示例</h4><pre><code>for(i=0;i&lt;n;i++){x++;s=0}</code></pre><p>循环体内两条基本语句频度均为$f(n)=n$,所以算法时间复杂度为$T(n)=O(n)$</p><h4 id="平方阶示例"><a href="#平方阶示例" class="headerlink" title="平方阶示例"></a>平方阶示例</h4><pre><code>x=0;y=0;for(k=1;k&lt;=n;k++)    x++;for(i=1;i&lt;=n;i++)    for(j=1;j&lt;=n;j++)        y++;</code></pre><p>循环语句只需考虑循环体中语句的执行次数，其频度为$f(n)=n^2$,所以该算法的时间复杂度为$T(n)=O(n^2)$,称为平方阶。<br>多数条件下，若干个循环语句时，算法的时间复杂度由最深层循环内基本语句频度决定。</p><h4 id="立方阶示例"><a href="#立方阶示例" class="headerlink" title="立方阶示例"></a>立方阶示例</h4><pre><code>x=1;for(x=1;i&lt;=n;i++)    for(j=1;j&lt;=i;j++)        for(k=1;k&lt;=k;k++)            x++;</code></pre><script type="math/tex;mode=display">\displaystyle \sum^{n}_{i=1} \displaystyle \sum^{i}_{i=1} \displaystyle \sum^{j}_{i=1}1=\displaystyle \sum^{n}_{i=1} \displaystyle \sum^{i}_{i=1}j=\displaystyle \sum^{n}_{i=1}i(i+1)/2=</script><script type="math/tex;mode=display">[n(n+1)(2n+1)/6+n(n+1)/2]/2</script><p>该算法时间复杂度为$T(n)=O(n^3)$,称为立方阶。</p><h4 id="对数阶示例"><a href="#对数阶示例" class="headerlink" title="对数阶示例"></a>对数阶示例</h4><pre><code>for(i=1;i&lt;=n;i=i*2){x++;s=0;}</code></pre><p>设循环体内两条基本语句的频度为$f(n)$,则有$2^{f(n)}\leq n$,$f(n)\geq \log_2 n$,算法时间复杂度为$T(n)=O(log_2 n)$.</p><h3 id="时间复杂度性能"><a href="#时间复杂度性能" class="headerlink" title="时间复杂度性能"></a>时间复杂度性能</h3><p>最好时间复杂度： 算法计算量可能达到的最小值<br>最坏时间复杂度： 算法计算量可能达到的最大值<br>平均时间复杂度： 算法计算量的加权平均值</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>输入数据所占的具体存储量取决于问题本身，与算法无关。空间复杂度只需要分析该算法在实现时所需的辅助空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache与辅助存储器</title>
    <link href="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Cache与辅助存储器"><a href="#Cache与辅助存储器" class="headerlink" title="Cache与辅助存储器"></a>Cache与辅助存储器</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><h3 id="为什么使用Cache？"><a href="#为什么使用Cache？" class="headerlink" title="为什么使用Cache？"></a>为什么使用Cache？</h3><ul><li>避免CPU”空等”现象</li><li>CPU和主存(DRAM)的速度差异<br><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>程序访问的局部性原理</li></ul><h2 id="Cache的工作原理"><a href="#Cache的工作原理" class="headerlink" title="Cache的工作原理"></a>Cache的工作原理</h2><h3 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/2.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存和缓存按块存储，块的大小相同，B为块长。缓存的块远远小于主存的块，如果主存要和Cache映射，那么至少要保证主存中每块大小应与Cache中每块大小相同。<br>每个字块包含N个字，主存的地址应该分成两部分，一部分用来寻找某个字块，另一部分用来寻找该字块中的字或字节。</p><h3 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h3><p>缓存共有C块，主存共有M块，M&gt;&gt;C.</p><ul><li>命中: 主存块调入缓存，主存块与缓存块 建立了对应关系。</li><li>未命中: 主存块未调入缓存，主存块与缓存块未建立对应关系。</li></ul><blockquote><p>用标记记录与某缓存块建立了对应关系的主存块号。</p></blockquote><h4 id="Cache的命中率"><a href="#Cache的命中率" class="headerlink" title="Cache的命中率"></a>Cache的命中率</h4><p>CPU欲访问的信息在Cache中的比率，命中率与Cache的容量与块长有关，一般每块可取4-8个字。<br>块长取一个存取周期内从主存调出的信息长度。</p><blockquote><ul><li>CRAY_1,16体交叉，块长取16个存储字。</li><li>IBM370/168，4体交叉，块长取4个存储字，一个存储字64位，一次取256位。</li></ul></blockquote><h3 id="Cache-主存系统的效率"><a href="#Cache-主存系统的效率" class="headerlink" title="Cache-主存系统的效率"></a>Cache-主存系统的效率</h3><p>效率e与命中率有关，e=访问Cache的时间/平均访问时间 <em>100%。<br>设Cache命中率为h，访问Cache的时间为tc，访问主存的时间为tm，则e=tc/h</em>tc+(1-h)<em>tm</em>100%.</p><h3 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ul><li>写直达法(Write-through)<br>写操作时数据既写入Cache，又写入主存。<br>写操作时间就是访问主存的时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现。</li><li>写回法(Write-back)<br>写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存。<br>写操作时间就是访问Cache的时间，Cache块退出时，被替换的块需写回主存 ，增加了Cache的复杂性。</li></ul><h3 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h3><ol><li>增加Cache的级数，如片载(片内)Cache,片外Cache。</li><li>统一缓存和分立缓存，冯诺依曼结构将指令Cache和数据Cache统一整合，现在计算机可以将指令Cache与数据Cache分开，这个方式与指令执行的控制方式有关。</li><li>Pentium，8K指令Cache，8K数据Cache。</li><li>PowerPC620，32K指令Cache，32K数据Cache。</li></ol><h2 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h2><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/5.png" srcset="/img/loading.gif" width="350px" height="230px"><br>每个缓存块i可以和若干个主存块对应<br>每个主存块i只能和一个缓存块对应</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/6.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存中的任一块可以映射到缓存中的任一块</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>某一主存块j按模Q映射到缓存的第i组中的任一块，当组相联只有一组时，此时组相联映射等同于全相联映射，当每组只有一块时，此时组相联映射等同于直接映射。</p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><ol><li>先进先出(FIFO)算法</li><li>近期最少使用(LRU)算法</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>直接，某一主存块只能固定映射到某一缓存块</li><li>全相联，某一主存块能映射到任一缓存块</li><li>组相联，某一主存块只能映射到某一缓存组中的任一块</li></ul><h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>特点，不直接与CPU交换信息</li><li>磁表面存储器的技术指标<ul><li>记录密度，道密度Dt，位密度Db</li><li>存储容量，C=n<em>k</em>s</li><li>平均寻址时间，寻道时间+等待时间<ul><li>辅存的速度<ul><li>寻址时间</li><li>磁头读写时间</li></ul></li></ul></li><li>数据传输率，Dr=Db*V</li><li>误码率，出错信息位数与读出信息的总位数之比。</li></ul></li></ol><h3 id="磁记录原理和记录方式"><a href="#磁记录原理和记录方式" class="headerlink" title="磁记录原理和记录方式"></a>磁记录原理和记录方式</h3><h4 id="磁记录写原理"><a href="#磁记录写原理" class="headerlink" title="磁记录写原理"></a>磁记录写原理</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="磁记录读原理"><a href="#磁记录读原理" class="headerlink" title="磁记录读原理"></a>磁记录读原理</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h3><h4 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h4><ol><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ol><h4 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ol><li>磁盘驱动器<br><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/11.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>磁盘控制器<ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令</li><li>实现主机和驱动器之间的数据格式转换</li><li>控制磁盘驱动器读写</li><li>磁盘控制器是主机和磁盘驱动器之间的接口<ul><li>对主机，通过总线</li><li>对硬盘(设备)</li></ul></li></ul></li><li>盘片<br>由硬质铝合金材料制成</li></ol><h3 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="软盘片"><a href="#软盘片" class="headerlink" title="软盘片"></a>软盘片</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>采用光存储技术，利用激光写入和读出</p><ul><li>第一代光存储技术，采用非磁性介质，不可擦写</li><li>第二代光存储技术，采用磁性介质，可擦写</li></ul><h4 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h4><p>只读型和只写一次型—热作用(物理或化学变化)<br>可擦写光盘—热磁效应</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主存储器之ROM</title>
    <link href="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/"/>
    <url>/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="主存储器之ROM"><a href="#主存储器之ROM" class="headerlink" title="主存储器之ROM"></a>主存储器之ROM</h1><h2 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h2><ul><li>早期的只读存储器—在厂家就写好了内容</li><li>改进1—用户可以自己写—一次性</li><li>改进2—可以多次写—要能对信息进行擦除</li><li>改进3—电可擦写—特定设备</li><li>改进4—电可擦写—直接连接到计算机上</li></ul><h3 id="掩膜ROM-MROM"><a href="#掩膜ROM-MROM" class="headerlink" title="掩膜ROM(MROM)"></a>掩膜ROM(MROM)</h3><p>MROM有芯片制造商在制造时写入内容，之后只能读不能写入，其基本存储原理是以元件的”有/无”来表示该存储单元的信息(“1”或”0”)。</p><ul><li>行列选择线交叉处有MOS管为”1”</li><li>行列选择线交叉处无MOS管为”0”<h3 id="PROM-一次性编程"><a href="#PROM-一次性编程" class="headerlink" title="PROM(一次性编程)"></a>PROM(一次性编程)</h3>使用熔丝存储数据，用户可根据自己的需要来对其填入内容，属于一次性写入的存储器。部分PROM在出厂时数据全为0，用户可以将其中的部分单元写入1，以实现对其”编程”的目的。</li></ul><p><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="EPROM-多次编程"><a href="#EPROM-多次编程" class="headerlink" title="EPROM(多次编程)"></a>EPROM(多次编程)</h3><p>使用悬浮栅存储数据，为了能多次修改ROM的内容，产生了EPROM，EPRM使用高压写入数据，当需要修改时，可使用紫外线将其全部内容擦除(不能局部擦除)。但是使用紫外线并不方便，因此产生了EEPROM.<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>D端加正电压，形成浮动栅，S与D不导通为”0”</li><li>D端不加正电压，不形成浮动栅，S与D导通为”1”</li></ul><h3 id="EEPROM-多次性编程"><a href="#EEPROM-多次性编程" class="headerlink" title="EEPROM(多次性编程)"></a>EEPROM(多次性编程)</h3><p>EEPROM与EPROM运作原理一样，不但写入数据使用高压，擦除数据也是用了高压。</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul><h3 id="Flash-Memory-闪速型存储器"><a href="#Flash-Memory-闪速型存储器" class="headerlink" title="Flash Memory(闪速型存储器)"></a>Flash Memory(闪速型存储器)</h3><p>闪存虽然属于内存的一种，但不同于内存。众所周知，如果没有电流供应，内存中的内容会消失，闪存在没有电流供应的情况下仍能长久的保持数据，其存储特性相当于硬盘，集合了ROM与RAM的长处。一般闪存按块读取数据。</p><h2 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h2><ol><li>位扩展(增加存储子长)<br>用2片1K<em>4位的存储芯片组成1K</em>8位的存储器，需要10根地址线，8根数据线。(2^10=1K)<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/3.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>字扩展(增加存储字的数量)<br>用2片1K<em>8位存储芯片组成2K</em>8位的存储器，需要11根地址线，8根数据线。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/4.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>字、位扩展<br>用8片1K<em>4位存储芯片组成4K</em>8位的存储器，需要12根地址线，8根数据线。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/5.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><ol><li>地址线的连接</li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li><li>其他(时序、负载)</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>假设同前，要求最小4K为系统程序区，相邻8K为用户程序区。</p><ol><li>写出对应二进制地址码</li><li>确定芯片的数量及类型<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/6.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>分配地址线<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/7.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>确定片选信号</li></ol><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><ul><li>合法代码集合</li></ul><ol><li>{000,001,010,011,100,101,110,111} 检0位错，纠0位错</li><li>{000,011,101,110}合法编码的特点，1的个数为偶数个，或0个，检1位，纠0位。</li><li>{000,111}合法编码为1的个数是3，检1位，纠1位。</li><li>{0000,1111}检2位，纠1位</li><li>{00000,11111}检2位，纠2位。</li></ol><blockquote><p>检测能力与任意两组合法代码之间二进制位的最少差异数有关。</p></blockquote><h3 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h3><p>任意两组合法代码之间二进制位数的最少差异、编码的纠错、检错能力与编码的最小距离有关。<br>L-1=D+C（D&gt;=C）<br>L: 编码的最小距离 L=3<br>D: 检测错误的位数，例：具有一位纠错能力<br>C: 纠正错误的位数</p><h3 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h3><ul><li>汉明码采用奇偶校验</li><li>汉明码采用分组校验</li><li>汉明码的分组是一种非划分方式<br>一组数据为1234567，分成3组，每组有一位校验位，共包括4位数据位，而汉明码的分组如下：<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/8.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><p>若第一组出错，其他两组没错，则出错位为1.若第三组与第一组出错，第二组没错，则出错位置为第三组与第一组公共位置为5，如果第三组与第二组出错，第一组没错，则出错位为6，将三组P3p2p1倒序排列出错的位置恰好为其二进制对应十进制的数据。</p><blockquote><p>奇偶校验：添加一位校验位，判断1的个数是奇数还是偶数，无法纠错。<br>如果将上述数据分组，然后分别添加校验码，可以得到两个校验码，因此可以纠2位。</p></blockquote><h4 id="汉明码分组"><a href="#汉明码分组" class="headerlink" title="汉明码分组"></a>汉明码分组</h4><p>第一组 XXXX1<br>第二组 XXX1X<br>第三组 XX1XX<br>第四组 X1XXX<br>第五组 1XXXX<br>相应1，2，4，8…位置放校验码。1，2，4，8是每一个部分独有的，如果数据的第1位与第3位为1，就是第一组与第三组所共有的数据，以此类推。</p><h4 id="组成汉明码的三要素"><a href="#组成汉明码的三要素" class="headerlink" title="组成汉明码的三要素"></a>组成汉明码的三要素</h4><ol><li>汉明码的组成需要增添？位检测位<br>2^K&gt;=n+k+1</li><li>检测位的位置？<br>2^i(i=0,1,2,3,…)</li><li>检测位的取值？<br>检测位的取值与该位所在的检测”小组”中承担的奇偶教研任务有关。</li></ol><h4 id="各检测位Ci所承担的检测小组为"><a href="#各检测位Ci所承担的检测小组为" class="headerlink" title="各检测位Ci所承担的检测小组为"></a>各检测位Ci所承担的检测小组为</h4><p><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>求0101按”偶校验”配置的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/10.png" srcset="/img/loading.gif" width="350px" height="230px">&lt;/img&gt;<br>按配偶原则配置0011的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="汉明码的纠错过程"><a href="#汉明码的纠错过程" class="headerlink" title="汉明码的纠错过程"></a>汉明码的纠错过程</h4><p>每一组形成新的检测位Pi，其位数与增添的检测位有关。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>已知接收到的汉明码为0100111(按配偶原则配置)试问要求传送的信息是什么？<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>写出按偶校验配置的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h2 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h2><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构</li></ul><ol><li>单体多字系统，增加存储器的带宽<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/15.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>多体并行系统<ul><li>高位交叉，顺序编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/16.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>高位交叉，各个体并行工作<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/17.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>低位交叉，各个体轮流编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/18.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>低位交叉，各个体轮流编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/19.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul></li></ol><h3 id="低位交叉的特点"><a href="#低位交叉的特点" class="headerlink" title="低位交叉的特点"></a>低位交叉的特点</h3><p>在不改变存取周期的前提下，增加存储器的带宽<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/20.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>设四体低位交叉存储器，存取周期为T，总线传输周期为τ，为实现流水线方式存取，应满足T=4τ。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/21.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>连续读取4个字所需的时间为T+(4-1)τ.</p><h3 id="高性能存储芯片"><a href="#高性能存储芯片" class="headerlink" title="高性能存储芯片"></a>高性能存储芯片</h3><ol><li>SDRAM(同步DRAM)</li><li>RDRAM</li><li>带Cache的DRAM<br>在DRAM的芯片内集成了一个由SRAM组成的Cache，有利于猝发式读取。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器概述与RAM</title>
    <link href="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/"/>
    <url>/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><h3 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h3><ol><li>半导体存储器 TTL(集成度低，功耗高，速度快)、MOS(集成度高，功耗低)—易失</li><li>磁表面存储器 （磁头、磁载体）</li><li>磁芯存储器 硬磁材料、环状元件</li><li>光盘存储器 激光、磁光材料</li></ol><h3 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h3><ol><li>存取时间与物理地址无关(随机访问)<ul><li>随机存储器 在程序的执行过程中可读可写</li><li>只读存储器 在程序的执行过程中只读</li></ul></li><li>存取时间与物理地址有关(串行访问)<ul><li>顺序存取存储器 磁带</li><li>直接存取存储器 磁盘</li></ul></li></ol><h3 id="按在计算机中的作用分类"><a href="#按在计算机中的作用分类" class="headerlink" title="按在计算机中的作用分类"></a>按在计算机中的作用分类</h3><ul><li>主存储器<ul><li>RAM<ul><li>静态RAM</li><li>动态RAM</li></ul></li><li>ROM<ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>Flash Memory</li><li>高速缓冲存储器(Cache)</li><li>辅助存储器 磁盘、磁带、光盘</li></ul><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器三个主要特性的关系"><a href="#存储器三个主要特性的关系" class="headerlink" title="存储器三个主要特性的关系"></a>存储器三个主要特性的关系</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="缓存-主存层次和主存-辅存层次"><a href="#缓存-主存层次和主存-辅存层次" class="headerlink" title="缓存-主存层次和主存-辅存层次"></a>缓存-主存层次和主存-辅存层次</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/2.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存与辅存构成的空间，叫做虚拟存储器。我们定义了一个空间存储程序叫做虚地址也就是逻辑地址。</p><blockquote><p>程序的局部性原理：指程序在执行时，呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p></blockquote><h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/3.png" srcset="/img/loading.gif" width="350px" height="230px"><br>MAR保存了需要访问的存储单元的地址，经过译码器选择实际内存中相应的地址，由读写控制电路控制MDR内的内容写入和读出。</p><h3 id="主存和CPU的联系"><a href="#主存和CPU的联系" class="headerlink" title="主存和CPU的联系"></a>主存和CPU的联系</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>MAR是单向的，MDR是双向的</p><h3 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h3><p>12345678H这个数据如何在主存储器中进行存储？<br>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。<br>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p></blockquote><ul><li>设地址线24根 按字节寻址 2^24=16MB</li><li>若字长为16位 按字寻址 8MW (W是16位)</li><li>若字长为32位 按字寻址 4MW</li></ul><blockquote><p>存储子长：一次能读出或者写入的字长，若字长为16位，则一个字有两个字节，所以要留一根地址线指出该字中的哪个字节，即寻址范围是2^(24-1)=8M.</p></blockquote><h4 id="判断编译器的大小端模式"><a href="#判断编译器的大小端模式" class="headerlink" title="判断编译器的大小端模式"></a>判断编译器的大小端模式</h4><pre><code>short int x;char x0,x1;x=0x1122;x0=((char*)&amp;x)[0];    //低地质单元x1=((char*)&amp;x)[1];    //高地址单元</code></pre><p>若x0=0下1，则是大端，反之是小端。</p><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><ol><li>存储容量 主存存放二进制代码的总位数</li><li>存储速度<ul><li>存取时间 存储器的访问时间，读出时间和写入时间</li><li>存取周期 连续两次独立的存储器操作，读或写所需的最小间隔时间，读周期和写周期</li></ul></li><li>存储器的带宽 位/秒</li></ol><h2 id="半导体芯片简介"><a href="#半导体芯片简介" class="headerlink" title="半导体芯片简介"></a>半导体芯片简介</h2><h3 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>地址线(单向)，10|，14|，13</li><li>数据线(双向)，4|，1|，8</li><li><p>芯片容量，1K<em>4位|，16K</em>1位|，8K*8位</p></li><li><p>片选线 CS(低电平有效) CE(使能信号) (片选线是芯片选择信号，它指出了这次操作给出的地址是不是针对这个存储芯片的地址，被选择的存储单元和字节是不是在这个芯片当中)</p></li><li>读/写控制线 WE(低电平写，高电平读)</li><li>OE(允许读)，WE(允许写)</li></ul><h4 id="存储芯片片选线的作用"><a href="#存储芯片片选线的作用" class="headerlink" title="存储芯片片选线的作用"></a>存储芯片片选线的作用</h4><p>用(32片)16K<em>1位的存储芯片组成64K</em>8位的存储器<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>8个芯片一组构成8位输出，这样的芯片布置4组。0-16k-1为第一组</p><h3 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/8.png" srcset="/img/loading.gif" width="350px" height="230px"><br>可以看出这个芯片是16K*8位，线选法像个数列，重合法像二维数组。</p><h4 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h2 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h2><h3 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h3><h4 id="SRAM的基本电路"><a href="#SRAM的基本电路" class="headerlink" title="SRAM的基本电路"></a>SRAM的基本电路</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SRAM基本电路的读操作"><a href="#SRAM基本电路的读操作" class="headerlink" title="SRAM基本电路的读操作"></a>SRAM基本电路的读操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SRAM基本电路的写操作"><a href="#SRAM基本电路的写操作" class="headerlink" title="SRAM基本电路的写操作"></a>SRAM基本电路的写操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="静态RAM芯片举例"><a href="#静态RAM芯片举例" class="headerlink" title="静态RAM芯片举例"></a>静态RAM芯片举例</h3><p>Intel 2114外特性<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/13.png" srcset="/img/loading.gif" width="350px" height="230px"><br>A0-A9代表数据线，说明此芯片有1k存储容量，I/O1-4说明此芯片一次能读出或写入4位数据，CS代表片选信号，低电平选中此芯片，WE是读写信号。</p><h4 id="2114读操作"><a href="#2114读操作" class="headerlink" title="2114读操作"></a>2114读操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="2114写操作"><a href="#2114写操作" class="headerlink" title="2114写操作"></a>2114写操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h3><h4 id="动态RAM基本单元电路"><a href="#动态RAM基本单元电路" class="headerlink" title="动态RAM基本单元电路"></a>动态RAM基本单元电路</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>读出与原存信息相反 读出时数据线有电流为“1”</li><li>写入与输入信息相同 写入时Cs充电为“1”放电为“0”</li></ul><h4 id="动态RAM芯片举例"><a href="#动态RAM芯片举例" class="headerlink" title="动态RAM芯片举例"></a>动态RAM芯片举例</h4><ol><li>三管动态RAM芯片(Intel 1103)读<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/17.png" srcset="/img/loading.gif" width="350px" height="230px"><br>假设给出的行地址为0，则第0行读选择线有效，第0行的所有单元被选中，列地址是5个0，第0列被选中，第0行与第0列交叉的单元电路被选中，这个单元通过读数据线将数据送到读写电路上，实现了读操作。</li><li>三管动态RAM芯片(Intel 1103)写<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/18.png" srcset="/img/loading.gif" width="350px" height="230px"><br>假设行地址译码器给的地址为5个1，则第31行被选中，第31行所有的单元电路准备写操作，假设给出的列地址为00001，第31行第一列的单元电路被选中。</li><li>单管动态RAM4116(16K*1位)外特性<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/19.png" srcset="/img/loading.gif" width="350px" height="230px"><br>这种动态RAM只有7根地址线，分两次传送。第一次将A0-A0传入行地址缓存器，第二次传入列地址缓存器，经过译码器负责选择单元电路。</li><li>4116读原理<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>若给出的行地址为0111111，则第63行有效，63行所有的晶体管都打开，电容当中保存的信息会送出到读放大器的左侧，以第一个晶体管为例，如果晶体管有电，则第一个读放大器的左侧就为1，右侧就为0，假设列地址为7个0，第0列被选中，第0列的列选信号有效，对应的晶体管打开，数据会从第0列的读放大器的右侧送入I/O缓冲。</li><li>4116写原理<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/21.png" srcset="/img/loading.gif" width="350px" height="230px"><br>行地址0111111，63行被选中，所有晶体管打开，数据被送到读写线上，第0列有效，第0列晶体管打开，通过第0列读放大器右端，通过左端写入电容。</li></ol><h4 id="动态RAM刷新"><a href="#动态RAM刷新" class="headerlink" title="动态RAM刷新"></a>动态RAM刷新</h4><p>电容容易漏电，所以必须需要对动态RAM进行刷新。</p><ol><li>集中刷新(存取周期为0.5us)以128<em>128矩阵为例，刷新与行地址有关<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/22.png" srcset="/img/loading.gif" width="350px" height="230px"><br>“死区”为 0.5us</em>128=64us<br>“死时间率”为 128/4000*100%=3.2%</li><li>分散刷新(存取周期为1us)以128*128矩阵为例<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/23.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>分散刷新与集中刷新结合(异步刷新)<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/24.png" srcset="/img/loading.gif" width="350px" height="230px"><br>对于128*128的存储芯片(存取周期为0.5us)，若每隔15.6us刷新一行<br>每行每隔2ms刷新一次，”死区”为0.5us<br>将刷新安排在指令译码阶段，不会出现”死区”</li></ol><h3 id="动态RAM与静态RAM的比较"><a href="#动态RAM与静态RAM的比较" class="headerlink" title="动态RAM与静态RAM的比较"></a>动态RAM与静态RAM的比较</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/25.png" srcset="/img/loading.gif" width="350px" height="230px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定点运算</title>
    <link href="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/"/>
    <url>/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h3><p>在日常计算中将15.0小数点右移2位为1500.0，计算机中小数点位置固定不变。所以需要将数据相对小数点进行移位。<br>在计算机中，移位与加减配合，能够实现乘除运算。</p><ul><li>左移，绝对值扩大</li><li>右移，绝对值缩小<h3 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h3></li><li>正数：原码、补码、反码添补代码都为0</li><li>负数：<ul><li>原码，添补代码为0</li><li>补码，左移添0，右移添1</li><li>反码，添补代码为1</li></ul></li></ul><blockquote><p>符号位不变</p></blockquote><h3 id="算术移位举例"><a href="#算术移位举例" class="headerlink" title="算术移位举例"></a>算术移位举例</h3><ol><li><p>设机器数字长为8位(含1位符号位)，写出A=+26时，三种机器数左、右移移位和两位后的表示形式及对应的真值，并分析结果的正确性。<br>解： A=+26=+11010，则A的原码、补码、反码=0，0011010.<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/1.png" srcset="/img/loading.gif" width="350px" height="150px"></p></li><li><p>设机器数字长为8位(含1位符号位)，写出A=-26时，三种机器数左右移一位和两位后的表示形式及对应的真值，并分析结果的正确性。<br>解： A=-26=-11010<br>原码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/2.png" srcset="/img/loading.gif" width="350px" height="150px"><br>补码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/3.png" srcset="/img/loading.gif" width="350px" height="150px"><br>反码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/4.png" srcset="/img/loading.gif" width="350px" height="150px"></p></li></ol><h3 id="算数移位的硬件实现"><a href="#算数移位的硬件实现" class="headerlink" title="算数移位的硬件实现"></a>算数移位的硬件实现</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/5.png" srcset="/img/loading.gif" width="380px" height="230px"></p><h3 id="算术移位和逻辑移位的区别"><a href="#算术移位和逻辑移位的区别" class="headerlink" title="算术移位和逻辑移位的区别"></a>算术移位和逻辑移位的区别</h3><ul><li>算术移位 有符号数的移位</li><li>逻辑移位 无符号数的移位</li><li>逻辑左移 低位添0，高位移丢</li><li>逻辑右移 高位添0，低位移丢</li></ul><p>例： 01010011<br>逻辑左移： 10100110<br>算术左移： 00100110<br>例： 10110010<br>逻辑右移： 01011001<br>算术右移： 11011001 (补码)</p><blockquote><p>算术移位不会更改符号位，逻辑移位包括符号位全部移位。</p></blockquote><h2 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h2><h3 id="补码加减法运算公式"><a href="#补码加减法运算公式" class="headerlink" title="补码加减法运算公式"></a>补码加减法运算公式</h3><ul><li>加法<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/6.png" srcset="/img/loading.gif" width="300px" height="100px"></li><li>减法<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/7.png" srcset="/img/loading.gif" width="300px" height="100px"></li></ul><blockquote><p>连同符号位一起相加，符号位产生的进位自然丢掉。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>设A=0.1011，B=-0.0101，求[A + B]补<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/8.png" srcset="/img/loading.gif" width="300px" height="150px"></li><li>设A=-9，B=-5，求[A + B]补<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/9.png" srcset="/img/loading.gif" width="330px" height="150px"></li><li>设机器数字长为8位(含1位符号位)，且A=15，B=24，用补码求A-B<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/10.png" srcset="/img/loading.gif" width="330px" height="150px"></li><li>设x=9/16，y=11/16，用补码求x+y。<br>x+y=-0.1100=-12/16 （错）</li><li>设机器数字长为8位(含一位符号位)且A=-97，B=+41，用补码求A-B<br>A-B=+1110110=+118 （错）</li></ol><h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><h4 id="一位符号位判断溢出"><a href="#一位符号位判断溢出" class="headerlink" title="一位符号位判断溢出"></a>一位符号位判断溢出</h4><p>参加操作的两个数(减法时即为被减数和”求补”以后的减数)符号相同，其结果的符号与原操作数的符号不同，即为溢出。<br>硬件实现：<br>最高有效位的进位 ⊕ 符号位的进位=1，即为溢出<br>有溢出：</p><ul><li>1⊕0=1，0⊕1=1</li></ul><p>无溢出：</p><ul><li>0⊕0=0，1⊕1=0</li></ul><h4 id="两位符号位判断溢出"><a href="#两位符号位判断溢出" class="headerlink" title="两位符号位判断溢出"></a>两位符号位判断溢出</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>小数的补码可以以2^k为模，k代表符号位的位数。</p></blockquote><h4 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>A代表ACC，Ga与Gs是两个标记，如果是加法Ga置1，如果是减法Gs置1，求补控制逻辑判断X中如果是减法运算，则对X求补。</p></blockquote><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><h3 id="分析笔算乘法"><a href="#分析笔算乘法" class="headerlink" title="分析笔算乘法"></a>分析笔算乘法</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="笔算乘法改进"><a href="#笔算乘法改进" class="headerlink" title="笔算乘法改进"></a>笔算乘法改进</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/14.png" srcset="/img/loading.gif" width="350px" height="230px"><br>初态部分积为0，然后需要分析乘数的数值部分1011，最后一位为1，则加0.1101，相加后将部分积与乘数右移一位，部分积结果是0.1101，分析乘数数值部分的末位，还是1，再将整体右移一位，部分积为0.0110，乘数为1101，然后相加0.1101，之后得到的结果1.0011，将乘数右移一位，分析数值的末位是0，则相加0.0000，然后得到的结果分析数值末位是1，将得到的结果右移一位，再相加0.1101，结果为1.0001，最后重复上述操作，结果为部分积与乘数之和，0.10001111.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>乘法运算可用加和移位实现，n=4，加4次，移4次</li><li>由乘数的末位决定被乘数是否与原部分积相加，然后-&gt;1位形成新的部分积，同时乘数-&gt;1位(末位移丢)，空出高位存放部分积的低位。</li><li>被乘数只与部分积的高位相加</li><li>硬件，3个寄存器，其中2个具有移位功能，1个全加器。</li></ul><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="原码一位乘运算规则"><a href="#原码一位乘运算规则" class="headerlink" title="原码一位乘运算规则"></a>原码一位乘运算规则</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="原码一位乘递推公式"><a href="#原码一位乘递推公式" class="headerlink" title="原码一位乘递推公式"></a>原码一位乘递推公式</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>已知x=-0.1110，y=0.1101，求[x.y]原。<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/17.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>乘积的符号位x0⊕y0=1⊕0=1</li><li>数值部分按绝对值相乘,x*.y*=0.10110110,则[x.y]原=1.10110110.</li><li>特点：绝对值运算，用移位的次数判断乘法是否结束，逻辑移位</li></ul><h4 id="原码一位乘的硬件配置"><a href="#原码一位乘的硬件配置" class="headerlink" title="原码一位乘的硬件配置"></a>原码一位乘的硬件配置</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/18.png" srcset="/img/loading.gif" width="350px" height="230px"><br>A、X、Q均n+1位，移位和加受末位乘数控制，计数器用于计算移位的次数，s代表符号位。</p><h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><h4 id="补码一位乘运算规则"><a href="#补码一位乘运算规则" class="headerlink" title="补码一位乘运算规则"></a>补码一位乘运算规则</h4><p>以小数为例，设被乘数<script type="math/tex">[x]_补=x_0x_1x_2\cdots x_n</script>,乘数<script type="math/tex">[y]_补=y_0y_1y_2\cdots y_n</script></p><ol><li>被乘数任意，乘数为正<br>与原码乘相似，但加和移位按补码规则运算，乘积的符号自然形成</li><li>被乘数任意，乘数为负<br>乘数<script type="math/tex">[y]_补</script>,去掉符号位，操作同1，最后加<script type="math/tex">[-x]_补</script>，校正。</li><li>Booth算法(被乘数、乘数符号任意)<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/19.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>Booth算法递推公式<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/20.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>已知x=+0.0011，y=-0.1011，求[xy]补。<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/21.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>Booth算法硬件配置<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/22.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="乘法小结"><a href="#乘法小结" class="headerlink" title="乘法小结"></a>乘法小结</h3><ul><li>整数乘法与小数乘法过程完全相同，可用逗号代替小数点</li><li>原码乘 符号位单独处理，补码乘 符号位自然形成</li><li>原码乘去掉符号位运算，即无符号数乘法</li><li>不同的乘法运算需有不同的硬件支持</li></ul><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><h3 id="分析笔算除法"><a href="#分析笔算除法" class="headerlink" title="分析笔算除法"></a>分析笔算除法</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/23.png" srcset="/img/loading.gif" width="350px" height="230px"><br>比较被除数与除数的大小，除数比被除数大，商0，然后除数移位变成0.01101，被除数补零，此时除数小于被除数，商1，余数继续右移一位，再比较余数与除数的大小关系，如果除数比余数大，商0，否则商1。</p><h3 id="笔算除法和机器除法比较"><a href="#笔算除法和机器除法比较" class="headerlink" title="笔算除法和机器除法比较"></a>笔算除法和机器除法比较</h3><ul><li>笔算除法<ul><li>商符单独处理，心算上商</li><li>余数不动低位补”0”,减右移一位的除数</li><li>2倍字长加法器，上商位置不固定</li></ul></li><li>机器除法<ul><li>符号位异或形成</li><li>x*-y*&gt;0上商1，x*-y*&lt;0上商0</li><li>余数左移一位低位补”0”，减除数</li><li>一倍字长加法器，在寄存器最末位上商</li></ul></li></ul><h3 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h3><p>以小数为例</p><script type="math/tex;mode=display">[x]_原=x_0x_1x_2\cdots x_n</script><script type="math/tex;mode=display">[y]_原=y_0y_1y_2\cdots y_n</script><script type="math/tex;mode=display">[x/y]_原=(x_0⊕y_0)x^*/y^*</script><p>式中<script type="math/tex">x^*=0.x_1x_2\cdots x_n</script>,为x的绝对值，<script type="math/tex">y^*=0.y_1y_2\cdots y_n</script>为y的绝对值<br>商的符号位单独处理<script type="math/tex">x_0⊕y_0</script>,数值部分为绝对值相除x*/y*<br>约定： 小数定点除法x* &lt; y*,整数定点除法x* > y*,被除数不等于0，除数不能为0</p><h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p>x=-0.1011,y=-0.1101,求[x/y]原<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/24.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/25.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>恢复余数法不仅需要求x与y的原码，还要求y*的补码与-y*的补码，用于减法运算。<br>x是被除数，取其绝对值，加-y*的补码(相当于减去y)，第一次相加(x*与-y*的补码相加)表示试探，如果商1，代表溢出，因为在小数定点机中，不能大于1.如果商0，代表余数为负，需要恢复余数，则加y*的补码，得到商0前的余数，然后将余数逻辑左移一位，然后再加-y*的补码，得到的余数为正，再商1，将余数左移一位，加-y*的补码，循环后得到最后的值，0.1101.此过程一共上商5次，第一次上商判断溢出，总共移位4次。</p><ul><li>余数为正，上商1。</li><li>余数为负，上商0，恢复余数。</li></ul><h3 id="不恢复余数法-加减交替法"><a href="#不恢复余数法-加减交替法" class="headerlink" title="不恢复余数法(加减交替法)"></a>不恢复余数法(加减交替法)</h3><ul><li>恢复余数法运算规则<ul><li>余数Ri&gt;0，上商”1”，2Ri(余数)-y*</li><li>余数Ri&lt;0，上商”0”，Ri+y* (恢复余数)</li><li><script type="math/tex">2(R_i+y^*)-y^*=2R_i+y^*</script>，(左移一位乘2，所以是2Ri，通过这个值判断新的一次操作是上商0还是1)</li></ul></li><li>不恢复余数法运算规则(加减交替，恢复余数法的改进)<ul><li>上商”1”，2Ri-y*</li><li>上商”0”，2Ri+y*</li></ul></li></ul><p>例： x=-0.1011，y=-0.1101，求[x/y]原<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/26.png" srcset="/img/loading.gif" width="350px" height="230px"><br>首先还是求x与y绝对值的补码以及-y绝对值的补码，首先加-y绝对值的补码用于实现减y操作判断溢出，余数为负数，上商0，然后执行2Ri+y*操作，即余数左移一位，加y*的补码,判断结果余数的正负，余数为正，商1，执行2Ri-y*操作，即余数左移一位，减去y*,循环计算得到结果。<br>结果：$x_0y_0=1⊕1=0$, x*/y*=0.1101,[x/y]=0.1101</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>上商n+1次</li><li>第一次上商判断溢出</li><li>移位n次，加n+1次</li><li>用移位的次数判断除法是否结束</li></ul><h4 id="原码加减交替除法硬件配置"><a href="#原码加减交替除法硬件配置" class="headerlink" title="原码加减交替除法硬件配置"></a>原码加减交替除法硬件配置</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/27.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>移位和加控制逻辑负责判断加减。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的定点与浮点表示</title>
    <link href="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数的定点表示与浮点表示"><a href="#数的定点表示与浮点表示" class="headerlink" title="数的定点表示与浮点表示"></a>数的定点表示与浮点表示</h1><h2 id="为什么要引入浮点表示"><a href="#为什么要引入浮点表示" class="headerlink" title="为什么要引入浮点表示"></a>为什么要引入浮点表示</h2><ul><li>编程困难，程序员要调节小数点的位置</li><li>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长。<ul><li>例如：太阳的质量为0.2<em>10^34克，一个电子的质量大约为0.9</em>10^-27克，两者差距为10^61以上，若用定点数据表示：2^x&gt;10^61，解得x&gt;203位。</li></ul></li><li>数据存储单元的利用率往往很低。</li></ul><h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="浮点数的表示形式"><a href="#浮点数的表示形式" class="headerlink" title="浮点数的表示形式"></a>浮点数的表示形式</h3><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>Sf 代表浮点数的符号</li><li>n 其位数反映浮点数的精度</li><li>m 其位数反映浮点数的表示范围</li><li>jf和m 共同表示小数点的实际位置</li></ul><h3 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h3><p>上溢： 阶码&gt;最大阶码<br>下溢： 阶码&lt;最小解码，按机器零处理<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>设机器数字长为24位，欲表示±3万的十进制数，试问在保证数的最大精度的前提下，除阶符、数符各取1位以外，阶码、尾数各取几位？<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="浮点数的规格化形式"><a href="#浮点数的规格化形式" class="headerlink" title="浮点数的规格化形式"></a>浮点数的规格化形式</h3><ul><li>r=2，尾数最高位为1</li><li>r=4，尾数最高2位不全为0</li><li>r=8，尾数最高3位不全为0</li></ul><blockquote><p>基数不同，浮点数的规格化形式不同。</p></blockquote><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><ul><li>r=2<ul><li>左规，尾数左移一位，阶码减1</li><li>右规，尾数右移一位，阶码加1</li></ul></li><li>r=4<ul><li>左规，尾数左移两位，阶码减1</li><li>右规，尾数右移两位，阶码加1</li></ul></li><li>r=8<ul><li>左规，尾数左移三位，阶码减1</li><li>右规，尾数右移三位，阶码加1</li></ul></li></ul><blockquote><p>基础r越大，可表示的浮点数的范围越大<br>基数r越大，浮点数的精度降低</p></blockquote><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>设m=4，n=10，r=2，尾数规格化后的浮点数表示范围<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>将+19/128写成二进制定点数、浮点数及在定点机和浮点机中的机器数形式。其中数值部分均取10位，数符取1位，浮点数阶码取5位(含一位阶符)，尾数规格化。<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>19/128用二进制表示形式，19每次除2，小数点向左移动一位。</p></blockquote><p>将-58表示成二进制定点数和浮点数，并写出它在定点机和浮点机中的三种机器数及阶码为移码、尾数为补码的形式。<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/7.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="机器零"><a href="#机器零" class="headerlink" title="机器零"></a>机器零</h3><ul><li>当浮点数尾数为0时，不论其阶码为何值按机器零处理。</li><li>当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理，如m=4，n=10。</li><li>当阶码和尾数都用补码表示时，机器零为x,xxxx;0.00…0, 阶码=-16: 1,0000;x.xx…x.</li><li>当阶码用移码，尾数用补码表示时，机器零为0,0000;0.00…0,有利于机器中”判0”电路的实现。</li></ul><h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机运算方法</title>
    <link href="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机的运算方法"><a href="#计算机的运算方法" class="headerlink" title="计算机的运算方法"></a>计算机的运算方法</h1><h2 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>寄存器的位数反映无符号数的表示范围。</p><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><h4 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h4><ul><li>整数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/3.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>小数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/4.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><h4 id="补的概念"><a href="#补的概念" class="headerlink" title="补的概念"></a>补的概念</h4><p>原码的特点是简单，直观，但是如果用原码做加法，一个正数和一个负数相加，结果的符号可正可负，需要找到一个与负数等价的正数来代替这个负数，假设一个时钟的时针指向六点，要想将时针指向三点方向，有两个办法，其一是将时针-3，其二是将时针+9.可见-3可用+9代替，这样将减法变为加法，称+9是-3以12为模的补数。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li>一个负数加上“模”即得该负数的补数</li><li>一个整数和一个负数互为补数时，他们绝对值之和即为模数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/7.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h4 id="正数的补数即为其本身"><a href="#正数的补数即为其本身" class="headerlink" title="正数的补数即为其本身"></a>正数的补数即为其本身</h4><p>两个互为补数的数分别加上模，结果仍互为补数。假设寄存器只能存4位数值，则需要将溢出位丢弃，可见正数的补数和负数的补数相同。为了区分正数与负数的符号，需要再加符号位，为了添加符号问还需要+2^4,则两次一共+2^(4+1)。这样无论正数还是负数的补码，都添加了符号位用于区分。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="补码定义"><a href="#补码定义" class="headerlink" title="补码定义"></a>补码定义</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>n不包括符号位</p></blockquote><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>正数用逗号隔开符号位，小数使用点号隔开符号位</p><h4 id="求补码的快捷方式"><a href="#求补码的快捷方式" class="headerlink" title="求补码的快捷方式"></a>求补码的快捷方式</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/11.png" srcset="/img/loading.gif" width="350px" height="230px"><br>计算100000-1010时可以用11111-1010+1代替.<br>当真值为负时，补码可用原码除符号位外每位取反，末位加1求得。<br>+0与-0补码相同</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p></blockquote><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>正数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/13.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>小数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/14.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="三种机器数的小结"><a href="#三种机器数的小结" class="headerlink" title="三种机器数的小结"></a>三种机器数的小结</h4><ul><li>最高位位符号位，书写上用“，”(正数)或“.”（小数）将数值部分和符号位隔开</li><li>对于正数，原码=补码=反码</li><li>对于负数，符号位为1，其数值部分原码除符号位外每位取反末位加1等于补码，原码除符号位外每位取反等于反码。<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/16.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/17.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><p>因为补码表示很难直接判断其真值的大小，所以使用移码进行比较。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>移码实际是将真值向上移了2^n.</p><h4 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="移码和补码的比较"><a href="#移码和补码的比较" class="headerlink" title="移码和补码的比较"></a>移码和补码的比较</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="移码的特点"><a href="#移码的特点" class="headerlink" title="移码的特点"></a>移码的特点</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>用移码表示浮点数的阶码，能方便的判断浮点数的阶码大小。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线</title>
    <link href="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <url>/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="总线的作用"><a href="#总线的作用" class="headerlink" title="总线的作用"></a>总线的作用</h2><p>总线是连接各个部件的信息传输线,是各个部件共享的传输介质.</p><h3 id="总线上的信息传送"><a href="#总线上的信息传送" class="headerlink" title="总线上的信息传送"></a>总线上的信息传送</h3><ul><li>串行传输,每次只传送一个字节,也只接收一个字节.</li><li>并行传输,每次传输多个字节,接收多个字节,但也要使用更多传输线.</li></ul><h2 id="总线结构的计算机举例"><a href="#总线结构的计算机举例" class="headerlink" title="总线结构的计算机举例"></a>总线结构的计算机举例</h2><h3 id="单总线结构框图"><a href="#单总线结构框图" class="headerlink" title="单总线结构框图"></a>单总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>将所有的设备全部连接到一条总线上,缺点是当某一个设备占用总线时,其他设备不能占用总线,导致整体运行效率降低.</p><h3 id="面向CPU的双总线结构框图"><a href="#面向CPU的双总线结构框图" class="headerlink" title="面向CPU的双总线结构框图"></a>面向CPU的双总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>以CPU为中心,双总线结构在CPU与内存之间使用了一根专用的总线,由于CPU运算时的指令与数据全部来自主存,所以在CPU与主存间使用总线可以保证CPU的运行效率,并且不会影响I/O设备的使用,但如果I/O设备要和主存之间进行信息传输必须经过CPU,导致CPU工作繁忙.</p><h3 id="以存储器为中心的双总线结构框图"><a href="#以存储器为中心的双总线结构框图" class="headerlink" title="以存储器为中心的双总线结构框图"></a>以存储器为中心的双总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>以主存为中心,这种结构不仅让CPU可以直接访问主存,也让I/O设备可以直接对主存进行存储操作.</p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><ul><li>片内总线,芯片内部的总线</li><li>系统总线,计算机各部件之间的信息传输线<ul><li>数据总线,双向,与机器字长,存储子长有关</li><li>地址总线,单向,与存储地址,IO地址有关</li><li>控制总线,有出有入.</li></ul></li><li>通信总线,用于计算机系统之间或计算机系统与其它系统之间的通信.<ul><li>串行通信总线</li><li>并行通信总线</li></ul></li></ul><h2 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h2><h3 id="总线的物理实现"><a href="#总线的物理实现" class="headerlink" title="总线的物理实现"></a>总线的物理实现</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/4.png" srcset="/img/loading.gif" width="350px" height="230px"><br>微型计算机中一般有一个大型印刷电路板,称之为主板,主板上分布总线,总线提供接口可以与其他设备相连接.</p><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><ol><li>机械特性: 尺寸,形状,管脚数及排列顺序.</li><li>电气特性: 传输方向和有效的电平范围.</li><li>功能特性: 每根传输线的功能,传输信号.</li><li>时间特性: 信号的时序关系.</li></ol><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><ol><li>总线宽度: 数据线的根数</li><li>标准传输率: 每秒传输的最大字节数(MBps)</li><li>时钟同步/异步: 同步、不同步</li><li>总线复用: 地址线与数据线复用(8086)</li><li>信号线数: 地址线、数据线和控制线的总和</li><li>总线控制方式: 突发、自动、仲裁、逻辑、计数</li><li>其他指标: 负载能力(能挂多少I/O设备)</li></ol><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/5.png" srcset="/img/loading.gif" width="350px" height="230px"><br>例如ISA总线,时钟为8MHz,每秒可以传送8M次,每次传送16bits信息也就是两个字节,可以很容易计算出带宽为16MBps.</p><blockquote><p>带宽=总线宽度x总线频率.</p></blockquote><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/6.png" srcset="/img/loading.gif" width="350px" height="230px"><br>将总线分为存储总线和I/O总线,存储总线用于连接CPU和主存,I/O总线负责连接I/O设备,然后用通道将I/O总线与主存总线连接.</p><blockquote><p>通道: 具有特殊功能的处理器,由通道对IO统一管理,一般来说通道有自己的控制器与指令系统,并且可以执行一些简单的指令与通道程序.</p></blockquote><h3 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>三总线结构将总线分为I/O总线,储存总线与DMA总线(直接存储器访问,外部设备直接访问内存),DMA总线与I/O接口相连,如果有高速设备需要与主存进行连接,可以通过DMA总线而不需要通过I/O总线.</p><h3 id="三总线结构的又一形式"><a href="#三总线结构的又一形式" class="headerlink" title="三总线结构的又一形式"></a>三总线结构的又一形式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/8.png" srcset="/img/loading.gif" width="350px" height="230px"><br>由于CPU的速度提高的非常快,所以现代计算机在主存与CPU之间增加了小容量高速度的Cache用于缓存主存的一些数据,CPU运行时需要的指令和数据主要从Cache中获取,局部总线连接了CPU和Cache,局部I/O控制器可以连接高速的I/O设备,系统总线通过扩展总线接口,连接了扩展总线,可以将各种外部设备连接到扩展总线,这样解决了I/O设备的扩展问题,外部设备通过扩展总线接口将数据传送进系统总线进而传送给主存和CPU.<br>这种结构的缺点是多种速度的设备都连接到了扩展总线,会影响I/O设备的运行效率.</p><h3 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/9.png" srcset="/img/loading.gif" width="350px" height="230px"><br>四总线结构包括,局部总线、系统总线、高速总线和扩展总线,局部总线连接CPU和Cache/桥,系统总线连接主存和Cache,桥电路连接 高速总线,高速总线连接各种高速设备,高速总线连接扩展总线接口,扩展总线接口连接扩展总线,扩展总线用于连接低速设备.这样避免了外部设备速度不同的问题,分离了高速设备与低速设备.</p><h2 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h2><h3 id="传统微型机总线结构"><a href="#传统微型机总线结构" class="headerlink" title="传统微型机总线结构"></a>传统微型机总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="VL-BUS局部总线结构"><a href="#VL-BUS局部总线结构" class="headerlink" title="VL-BUS局部总线结构"></a>VL-BUS局部总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="多层PCI总线结构"><a href="#多层PCI总线结构" class="headerlink" title="多层PCI总线结构"></a>多层PCI总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>主设备(模块), 对总线有控制权</li><li>从设备(模块),响应从主设备发来的总线命令</li><li>总线判优控制<ul><li>集中式<ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li><li>分布式</li></ul></li></ul><h3 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>总线控制部件集中在了一起,数据线用于信息交换过程中数据的传输,主设备占用总线后要跟从设备进行数据传输要通过地址总线找到对应的从设备.所有的设备都通过BR线发出总线占用或使用的请求.如果某个设备占用了总线控制权,则该设备通过BS告知总线控制部件或其他部件总线忙.BG为总线授权线,通过BG线逐个查询是哪一个设备提出的总线占用请求,该设备通过BS线设置总线忙,它就获得了总线的使用权.这种方式提前设置了设备的优先权,靠后的设备可能不会获得总线占用权.对电路故障敏感,如果向下传送过程中某一个电路出现故障,后面的设备就无法获得总线使用权.</p><h3 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>地址线用于查找从设备,设备地址上传输的地址是计数器给出的,通过这个地址去查找某个设备是否发出了总线占用请求.总线控制部件中有一个计数器,如果某主设备发出总线控制请求,控制部件收到请求后,可以让出总线使用权的情况下,会启动计数器.这个计数器的值通过设备地址这条线向外输出.计数器的值为0,就对I/O接口0进行查询,判断是否提出了响应请求,找到提出请求的设备后通过BS线应答.这种查询方式更加灵活,你可以设置计数器的启动,更改优先级.设备地址线数量与设备数有关.</p><h3 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>每一个I/O接口都连接BG与BR两条线,总线控制部件中有一个排队器.n个设备需要2n条线,多个I/O设备同时发起总线请求,排队器负责选择优先级高的设备控制总线.</p><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><ul><li>目的: 解决通信双方协调配合问题</li><li>总线传输周期(主设备和从设备之间完成一次完整并可靠的通讯需要的时间)<ul><li>申请分配阶段: 主模块申请,总裁仲裁决定</li><li>寻址阶段: 主模块向从模块给出地址和命令</li><li>传输阶段: 主模块和从模块交换数据</li><li>结束阶段: 主模块撤销有关消息</li></ul></li><li>总线通信的四种方式<ul><li>同步通信: 由<strong>统一的时标</strong>控制数据传送</li><li>异步通信: 采用应答方式,没有公共时钟标准</li><li>半同步通信: 同步、异步结合</li><li>分离式通信: 充分挖掘系统总线每个瞬间的潜力</li></ul></li></ul><h3 id="同步式数据输入"><a href="#同步式数据输入" class="headerlink" title="同步式数据输入"></a>同步式数据输入</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/17.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="同步式数据输出"><a href="#同步式数据输出" class="headerlink" title="同步式数据输出"></a>同步式数据输出</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>同步: 发送方用系统时钟前言发信号,接收方用系统时钟后沿判断、识别.<br>异步: 允许不同速度的模块和谐工作,增加一条等待响应信号WAIT.</p><h4 id="以输入数据为例的半同步通信时序"><a href="#以输入数据为例的半同步通信时序" class="headerlink" title="以输入数据为例的半同步通信时序"></a>以输入数据为例的半同步通信时序</h4><ul><li>T1: 主模块发地址</li><li>T2: 主模块发命令</li><li>Tw: 当WAIT为低电平时,等待一个T</li><li>Tw: 当WAIT为低电平时,等待一个T…</li><li>T3: 从模块提供数据</li><li>T4: 从模块撤销数据,主模块撤销命令</li></ul><h3 id="上述三种通信的共同点"><a href="#上述三种通信的共同点" class="headerlink" title="上述三种通信的共同点"></a>上述三种通信的共同点</h3><p>一个总线传输周期(以输入数据为例)</p><ul><li>主模块发地址、命令 (占用总线)</li><li>从模块准备数据 (不占用总线,总线空闲)</li><li>从模块向主模块发数据 (占用总线)</li></ul><h3 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h3><p>一个总线传输周期</p><ul><li>子周期1: 主模块申请占用总线,使用完后即放弃总线的使用权.</li><li>子周期2: 从模块申请占用总线,将各种信息传送至总线上.</li></ul><h4 id="分离式通信特点"><a href="#分离式通信特点" class="headerlink" title="分离式通信特点"></a>分离式通信特点</h4><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信,不等对方回答</li><li>各模块准备数据时,不占用总线</li><li>总线被占用时,无空闲.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机性能与发展</title>
    <link href="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/"/>
    <url>/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机性能与发展"><a href="#计算机性能与发展" class="headerlink" title="计算机性能与发展"></a>计算机性能与发展</h1><h2 id="计算机硬件性能指标"><a href="#计算机硬件性能指标" class="headerlink" title="计算机硬件性能指标"></a>计算机硬件性能指标</h2><ul><li>机器字长，CPU一次能处理数据的位数与CPU中寄存器位数有关。</li><li>运算速度<ul><li>主频</li><li>核数，每个核支持的线程数</li><li>吉普森法</li><li>CPI 执行一条指令所需时钟周期数</li><li>MIPS 每秒执行百万条指令</li><li>FLOPS 每秒浮点运算次数</li></ul></li><li>存储容量<ul><li>主存容量<ul><li>存储单元个数 X 存储字长，如MAR与MDR容量，1Kx8位.</li><li>字节数，如2^13b = 1KB.</li></ul></li><li>辅存容量<ul><li>字节数 80GB.</li></ul></li></ul></li></ul><h2 id="计算机发展及应用"><a href="#计算机发展及应用" class="headerlink" title="计算机发展及应用"></a>计算机发展及应用</h2><p>1946年，美国ENIAC生产了世界第一台10进制运算的计算机，一共18000多个电子管，1500多个继电器 ，150千瓦的功耗，30吨重量，占地1500平方英尺，每秒钟可以进行5000次加法运算，需要手工搬动开关和拔插电缆来进行编程。</p><h3 id="硬件技术对计算机更新换代的影响"><a href="#硬件技术对计算机更新换代的影响" class="headerlink" title="硬件技术对计算机更新换代的影响"></a>硬件技术对计算机更新换代的影响</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="INtel公司的典型微处理器产品"><a href="#INtel公司的典型微处理器产品" class="headerlink" title="INtel公司的典型微处理器产品"></a>INtel公司的典型微处理器产品</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Moore定律"><a href="#Moore定律" class="headerlink" title="Moore定律"></a>Moore定律</h3><p>Intel公司的缔造者之一Gordon Moore提出，微芯片上集成的晶体管数目每三年翻两番。</p><h3 id="编程语言的兴起"><a href="#编程语言的兴起" class="headerlink" title="编程语言的兴起"></a>编程语言的兴起</h3><ul><li>机器语言-面向机器</li><li>汇编语言-面向机器</li><li>高级语言-面向问题</li><li>FORTRAN 科学计算和工程计算</li><li>PASCAL 结构化程序设计</li><li>C++ 面向对象</li><li>Java 适应网络环境</li></ul><h3 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h3><ul><li>语言处理程序: 汇编程序，编译程序，解释程序</li><li>操作系统: DOS，UNIX，Windows，Linux，KylinLinux</li><li>服务性程序: 装备 调试 诊断 排错</li><li>数据库管理系统: 数据库和数据库管理软件</li><li>网络软件<h3 id="软件发展的特点"><a href="#软件发展的特点" class="headerlink" title="软件发展的特点"></a>软件发展的特点</h3></li></ul><ol><li>开发周期长</li><li>制作成本昂贵</li><li>检测软件产品质量的特殊性</li><li>软件是程序以及开发和使用维护程序所需要的所有文档</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组原理概述</title>
    <link href="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计组原理概述"><a href="#计组原理概述" class="headerlink" title="计组原理概述"></a>计组原理概述</h1><h2 id="如何使用计算机解决数学问题"><a href="#如何使用计算机解决数学问题" class="headerlink" title="如何使用计算机解决数学问题"></a>如何使用计算机解决数学问题</h2><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h3 id="编程举例"><a href="#编程举例" class="headerlink" title="编程举例"></a>编程举例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/1.png" srcset="/img/loading.gif" width="350px" height="350px"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="350px"></p><h2 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" width="100px" height="200px"></p><ul><li>存储体 - 存储单元 - 存储元件（1/0）</li><li>大楼 - 房间 - 床位 （无人/有人）</li><li>存储单元：存放一串二进制代码，每一个存储单元赋予一个地址</li><li>存储子： 存储单元中二进制代码的组合</li><li>存储字长： 存储单元中二进制代码的位数</li><li>MAR ： 存储器地址寄存器，反应存储单元的个数</li><li>MDR ： 存储器数据寄存器，反应存储字长</li></ul><blockquote><p>假设存储体为一个长方体，长方体的底面积为容纳的存储器地址，长方体的高为每一个存储器地址内的数据位，设MAR=4bit，MDR=8bit，存储单元个数为16，存储字长为8.</p></blockquote><h2 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="加法操作过程"><a href="#加法操作过程" class="headerlink" title="加法操作过程"></a>加法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" width="350px" height="160px"><br>初态ACC已经保存了被加数，指令M给出加数在内存单元的地址，将加数从内存单元中取出，然后保存进寄存器X中，ALU将寄存器ACC与X中的数据进行运算，并将结果保存进ACC当中。</p><h3 id="减法操作过程"><a href="#减法操作过程" class="headerlink" title="减法操作过程"></a>减法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" width="350px" height="160px"><br>同样ACC保存了被减数，指令中给出了减数的内存地址，将减数从M中取出，并且存入寄存器X中，通过ALU的运算，将结果保存进ACC中。</p><h3 id="乘法操作过程"><a href="#乘法操作过程" class="headerlink" title="乘法操作过程"></a>乘法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/7.png" srcset="/img/loading.gif" width="350px" height="160px"><br>ACC中预先保存了被乘数，将指令中M地址中的乘数保存进MQ寄存器中，然后将ACC中的数据存入X寄存器中，由于乘法是利用累加和移位的操作实现的，所以要将ACC寄存器的数据清零，将X与MQ的数据进行乘法操作，并将结果的高位保存进ACC中，低位保存进MQ中。</p><h3 id="除法操作过程"><a href="#除法操作过程" class="headerlink" title="除法操作过程"></a>除法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/8.png" srcset="/img/loading.gif" width="350px" height="160px"><br>ACC中保存了被除数，将M地址中的除数保存进X寄存器中，ALU实现ACC与X相除，结果保存进MQ中，余数保存进ACC中。</p><h2 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/9.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="主机完成一条指令以取数指令为例"><a href="#主机完成一条指令以取数指令为例" class="headerlink" title="主机完成一条指令以取数指令为例"></a>主机完成一条指令以取数指令为例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"><br>PC将当前预执行指令的地址送入MAR，由MAR送入存储体，在控制器的控制下，存储体将存储单元中保存的取数指令送入MDR，将取出来的指令从MDR送入IR，经过以上操作，取指令完成。将IR中指令的操作码部分送入CU控制单元，由CU控制单元去控制并完成操作的部分。IR中保存取数指令，将IR中取数指令的地址送入MAR，再由MAR送入存储体，将取数指令所指地址中的数据取出，存入MDR，从MDR中将数据存入ACC，这样就完成了取数操作。</p><h3 id="主机完成一条指令以取数指令为例-1"><a href="#主机完成一条指令以取数指令为例-1" class="headerlink" title="主机完成一条指令以取数指令为例"></a>主机完成一条指令以取数指令为例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"><br>PC将当前预执行的指令地址送入MAR，再由MAR送入存储体，将该指令取出，存入MDR，从MDR送入IR中，将IR中指令的操作码送入CU，由CU完成操作。由CU控制IR将指令送入MAR，由MAR送入存储体，告知将有一个数据存入存储体，地址是多少。下一步将ACC中的数据送入MDR，由控制器的控制下将MDR中的数据保存进相应的地址中。</p><h3 id="ax-2-bx-c程序运行过程"><a href="#ax-2-bx-c程序运行过程" class="headerlink" title="ax^2+bx+c程序运行过程"></a>ax^2+bx+c程序运行过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/11.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频传输与无线网络</title>
    <link href="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="因特网如何传输音视频"><a href="#因特网如何传输音视频" class="headerlink" title="因特网如何传输音视频"></a>因特网如何传输音视频</h2><h3 id="Internet上传输音频视频面临的问题"><a href="#Internet上传输音频视频面临的问题" class="headerlink" title="Internet上传输音频视频面临的问题"></a>Internet上传输音频视频面临的问题</h3><ol><li>音频视频 占用的带宽高 网速恒定 延迟低</li><li>数据信息 对带宽要求低 对于网速是否恒定或延迟要求不高</li></ol><h3 id="因特网提供的音视频服务种类"><a href="#因特网提供的音视频服务种类" class="headerlink" title="因特网提供的音视频服务种类"></a>因特网提供的音视频服务种类</h3><ol><li>流式(streaming)存储音频/视频—边下载 边播放</li><li>流式实况音频/视频—边录制边发送，通过网络，现场直播<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/2.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>交互式音频/视频—实时交互式通信</li></ol><h2 id="IP电话概述"><a href="#IP电话概述" class="headerlink" title="IP电话概述"></a>IP电话概述</h2><p>狭义的IP电话就是指在IP网络上打电话。所谓IP网络就是使用IP协议的分组交换网的简称<br>广义的IP电话则不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信(包括话音，视像等)，甚至还包括即时传信IM(Instant Messaging)。</p><h3 id="IP电话的连接方法"><a href="#IP电话的连接方法" class="headerlink" title="IP电话的连接方法"></a>IP电话的连接方法</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="IP电话通话质量"><a href="#IP电话通话质量" class="headerlink" title="IP电话通话质量"></a>IP电话通话质量</h3><p>IP电话的通话质量主要由两个因素决定，一个是通话双方端到端的时延和时延抖动，另一个是话音分组的丢失率。但这两个因素是不确定的，是取决于当时网络上的通信量。<br>经验证明，在电话交谈中，端到端的时延不应超过250ms，否则交谈者就能感到不自然。</p><h2 id="改进“最大努力交付”服务"><a href="#改进“最大努力交付”服务" class="headerlink" title="改进“最大努力交付”服务"></a>改进“最大努力交付”服务</h2><p>网络层的主要目的就是“尽最大努力交付”，对于信息的优先级不考虑，为了优先传播音视频，应用层需要对其进行改善。服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此在最简单的意义上，有服务质量的服务就是能够满足用户的应用需求的服务。<br>服务质量可用若干基本的性能指标来描述，包括可用性，差错率，响应时间，吞吐量，分组丢失率，连接建立时间，故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。</p><h3 id="服务器如何实现优先传输音频或视频"><a href="#服务器如何实现优先传输音频或视频" class="headerlink" title="服务器如何实现优先传输音频或视频"></a>服务器如何实现优先传输音频或视频</h3><ol><li>基于标记的优先级确认<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/4.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>基于分类的优先级确认<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/5.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>流量管制机制<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/6.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>调度机制<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/7.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>呼叫接纳<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/8.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><h3 id="几种无线网络的比较"><a href="#几种无线网络的比较" class="headerlink" title="几种无线网络的比较"></a>几种无线网络的比较</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/9.png" srcset="/img/loading.gif" width="350px" height="160px"></p><blockquote><p>PAN：个人局域网，LAN：无线局域网，MAN：无线城域网，WAN：无线广域网</p><h3 id="无线局域网的组成"><a href="#无线局域网的组成" class="headerlink" title="无线局域网的组成"></a>无线局域网的组成</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/10.png" srcset="/img/loading.gif" width="350px" height="160px"></p></blockquote><p>一个基本服务集BBS包括一个基站和若干个移动站，所有的站在本BBS以内都可以直接通信，但在和本BBS以外的站通信时，都要通过本BBS的基站。基本服务集内的基站叫做接入点AP(Access Point).当网络管理员安装AP时，必须为该AP分配一个不超过32字节的服务集标识符SSID和一个信道。一个基本服务集可以是孤立的，也可通过接入点AP连接到一个主干分配系统DS(Distribution System),然后再接入到另一个基本服务集，构成扩展的服务集ESS(Extended Service Set)。</p><h3 id="移动自组网络"><a href="#移动自组网络" class="headerlink" title="移动自组网络"></a>移动自组网络</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/11.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全概述</title>
    <link href="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="安全分类"><a href="#安全分类" class="headerlink" title="安全分类"></a>安全分类</h2><ol><li>数据存储安全</li><li>应用程序安全</li><li>操作系统安全</li><li>网络安全</li><li>物理安全</li></ol><h2 id="计算机网络上的通信面临以下四种威胁："><a href="#计算机网络上的通信面临以下四种威胁：" class="headerlink" title="计算机网络上的通信面临以下四种威胁："></a>计算机网络上的通信面临以下四种威胁：</h2><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>截获——从网络上窃听他人通信内容</li><li>中断——有意中断他人在网络上的通信</li><li>篡改——故意篡改网络上传送的报文</li><li>伪造——伪造信息在网络上传送</li></ul><p>接获信息的攻击称为被动攻击，而更改信息和拒绝用户使用资源的攻击称为主动攻击。<br>例：ARP欺骗，CAIN通过ARP欺骗，伪装成网关地址，可以篡改DNS解析结果，也能获取密码。</p><h2 id="被动攻击与主动攻击"><a href="#被动攻击与主动攻击" class="headerlink" title="被动攻击与主动攻击"></a>被动攻击与主动攻击</h2><ul><li>中断——拒绝服务式攻击<br>例：Dos拒绝服务式攻击，通过发送没用数据包阻断网络，占用大量下载带宽；DDos分布式攻击，通过在网络中寻找并控制有漏洞的服务器，给指定的服务器发数据包使该服务器瘫痪。</li><li>篡改——修改域名解析结果<br>例：用ARP欺骗将用户想访问的网站指向钓鱼网站，骗取账号密码等。</li><li>伪造——伪装网关<br>例：ARP欺骗，将寻找网关的主机发送的报文截取，然后将自身主机伪装成网关。<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3></li><li>计算机病毒——会传染其他程序，通过修改其他程序来把自身或其变种复制进去完成的</li><li>计算机蠕虫——通过网络的通信功能将自身从一个节点发送到另一个节点并启动运行的程序</li><li>特洛伊木马——某种程序，它执行的功能超出所声称的功能</li><li>逻辑炸弹——一种当运行环境满足某种特定条件时执行其他特殊功能的程序</li></ul><h2 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p><h4 id="原理举例："><a href="#原理举例：" class="headerlink" title="原理举例："></a>原理举例：</h4><p>甲和乙是一对生意搭档，他们住在不同的城市。由于生意上的需要，他们经常会相互之间邮寄重要的货物。为了保证货物的安全，他们商定制作一个保险盒，将物品放入其中。他们打造了两把相同的钥匙分别保管，以便在收到包裹时用这个钥匙打开保险盒，以及在邮寄货物前用这把钥匙锁上保险盒。<br>上面是一个将重要资源安全传递到目的地的传统方式，只要甲乙小心保管好钥匙，那么就算有人得到保险盒，也无法打开。这个思想被用到了现代计算机通信的信息加密中。在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。</p><blockquote><p>优点：效率高<br>缺点：密匙不适合在网上传输，密匙维护麻烦</p></blockquote><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。</li><li>A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。</li><li>A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。</li><li>A将这个消息发给B（已经用B的公钥加密消息）。</li><li>B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>加密秘钥和解密秘钥是不同的一对秘钥<br>公钥加密私钥解密，私钥加密公钥解密<br>使用数字签名，防止抵赖，能够检查签名之后内容是否被更改</p><h3 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h3><p>DES属于常规密钥密码体制，是一种分组密码。在加密前，先对整个明文进行分组，每一个组长为64位，然后对每一个位二进制数据进行加密处理，产生一组64位密文数据，最后将各组密文串联起来，即得出整个的密文。</p><blockquote><p>使用的密钥位64位，实际密钥长度为56位，还有8位用于奇偶效验。</p></blockquote><h4 id="DES的保密性"><a href="#DES的保密性" class="headerlink" title="DES的保密性"></a>DES的保密性</h4><p>DES的保密性仅取决于对密钥的保密，而算法时公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。<br>DES是世界上第一个公认的使用密码算法标准，他曾对密码学的发展做出了重大贡献。<br>目前较为严重的问题是DES的密钥长度，现在已经设计出来搜索DES密钥的专用芯片.</p><blockquote><p>DES算法公开取决于密钥长度，56位密钥破解需要3.5或21分钟，128位密钥破解需要5.4*10^18次方年。</p></blockquote><h2 id="安全套接字SSL"><a href="#安全套接字SSL" class="headerlink" title="安全套接字SSL"></a>安全套接字SSL</h2><p>SSL的位置在应用层和传输层之间，优点是应用层和传输层都不需要来加密。不需要应用层的支持，但是需要在服务器配置证书。</p><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p>在发送方，SSL接收应用层的数据(如HTTP或IMAP报文)，对数据进行加密，然后把加密的数据送往TCP套接字，在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</p><h3 id="SSL提供的功能"><a href="#SSL提供的功能" class="headerlink" title="SSL提供的功能"></a>SSL提供的功能</h3><ul><li>SSL服务器鉴别<br>允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA(Certificae Authority)和它们的公钥。</li><li>加密的SSL会话<br>客户和服务器交互的所有数据都在发送方加密，在接收方解密。</li><li>SSL客户鉴别<br>允许服务器证实客户的身份。<blockquote><p>CA，证书颁发机构，为企业和用户颁发数字证书，确保这些企业与用户的身份是否可靠，如果证书丢失需要发布吊销列表，企业和个人需要信任证书颁发机构。</p></blockquote></li></ul><h3 id="SSL加密步骤"><a href="#SSL加密步骤" class="headerlink" title="SSL加密步骤"></a>SSL加密步骤</h3><p>用户使用浏览器去访问某服务器端的网站，此时网站会把他的公钥给用户浏览器，浏览器通过校验CA证书确保该网站的公钥是可靠的，浏览器会产生一个对称密钥，浏览器使用网站的公钥对它的对称密钥进行加密，发给该网站，网站用它的私钥进行解密，就得到了用户浏览器的对称密钥。</p><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><ul><li>Https = TCP + 443</li><li>IMAPS = TCP + 993</li><li>POPS = TCP + 995</li><li>SMTPS = TCP + 465</li></ul><h2 id="网络层安全IPSec"><a href="#网络层安全IPSec" class="headerlink" title="网络层安全IPSec"></a>网络层安全IPSec</h2><h3 id="安全关联SA-Security-Association"><a href="#安全关联SA-Security-Association" class="headerlink" title="安全关联SA(Security Association)"></a>安全关联SA(Security Association)</h3><p>在使用AH或ESP之前，先要从源主机到目的主机建立一条网络层的逻辑链接，此逻辑连接叫做安全关联SA。<br>IPsec就把传统的因特网无连接的网络层转换为具有逻辑链接的层。<br>SA(安全关联)是构成IPSec的基础，是两个通信实体经协商(利用IKE协议)建立起来的一种协定，它决定了用来保护数据分组安全的安全协议(AH协议或者ESP协议)，转码方式，密钥即密钥的有效存在时间等。</p><h3 id="IPSec中最主要的协议"><a href="#IPSec中最主要的协议" class="headerlink" title="IPSec中最主要的协议"></a>IPSec中最主要的协议</h3><p>鉴别首部AH(Authentication Header)：AH鉴别源点和检查数据完整性，但不能保密。<br>封装安全有效载荷ESP(Encapsulation Security Payload):ESP比AH复杂得多，它鉴别源点，检查数据完整性和提供保密。</p><ol><li>鉴别首部协议AH<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><p>在使用鉴别首部协议AH时，把AH首部插在原数据报数据部分前，同时把IP首部中的协议字段置为51.<br>在传输过程中，中间的路由器都不查看AH首部。当数据包到达终点时，目的主机才处理AH字段，以鉴别源点和检查数据报的完整性。</p><ol><li>封装安全有效载荷ESP<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><p>使用ESP时，IP数据报首部的协议字段置为50，当IP首部检查到协议字段是50时，就知道在IP首部后面紧接着的是ESP首部，同时在原IP数据报后面增加了两个字段，即ESP尾部和ESP数据。</p><h2 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙(firewall)"></a>防火墙(firewall)</h2><p>防火墙是由软件，硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略，接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。<br>防火墙内的网络称为“可信赖网络”(trusted network),而将外部的因特网称为“不可信赖的网络”(untrusted network)。<br>防火墙可用来解决内联网和外联网的安全问题。</p><h3 id="防火墙在互联网中的位置"><a href="#防火墙在互联网中的位置" class="headerlink" title="防火墙在互联网中的位置"></a>防火墙在互联网中的位置</h3><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="防火墙技术一般分为两类"><a href="#防火墙技术一般分为两类" class="headerlink" title="防火墙技术一般分为两类"></a>防火墙技术一般分为两类</h3><ol><li>网络级防火墙<br>用来防止整个网络出现外来非法入侵，属于这类的有分组过滤和授权服务器。前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准测的数据，而后者则是检查用户的登陆是否合法。</li><li>应用级防火墙<br>从应用程序来进行接入控制，通常使用应用网关或代理服务器来区分各种应用。例如，可以只允许通过访问万维网的应用，而阻止FTP应用的通过。</li></ol><h3 id="防火墙的结构"><a href="#防火墙的结构" class="headerlink" title="防火墙的结构"></a>防火墙的结构</h3><p>边缘防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/7.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p>三向外围网<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/8.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p>背靠背防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/9.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p>单一网卡防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层概述</title>
    <link href="/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络应用层概述"><a href="#网络应用层概述" class="headerlink" title="网络应用层概述"></a>网络应用层概述</h1><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><ul><li>域名解析系统DNS(Domain Name System)</li><li>动态主机配置协议DHCP</li><li>文件传送协议FTP(File Transfer Protocol)</li><li>远程终端协议TELNET</li><li>远程桌面RDP</li><li>万维网www(World Wide Web)</li><li>电子邮件(SMTP POP IMAP)</li></ul><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>作用：负责解析域名 将域名解析成IP<br>域名分类： 根域名<br>顶级域名 com，edu，net，cn，org，gov<br>二级域名 baidu，souhu，bilibili<br>三级域名 dba，例如dba.souhu.com</p><blockquote><p>命令：ns lookup得到IP地址</p></blockquote><h3 id="配置内网DNS服务器的作用："><a href="#配置内网DNS服务器的作用：" class="headerlink" title="配置内网DNS服务器的作用："></a>配置内网DNS服务器的作用：</h3><p>可以避免网络阻塞，让其他计算机通过内网DNS服务器解析IP地址，内网DNS服务器向外请求，将常用IP地址缓存到本地，减少内网访问Interne的流量。</p><h2 id="动态主机配置系统DHCP"><a href="#动态主机配置系统DHCP" class="headerlink" title="动态主机配置系统DHCP"></a>动态主机配置系统DHCP</h2><p>客户机在网中发广播请求地址，目标IP是4个255，目标MAC地址是全FF。DHCP收到后，会从地址池里选一个给客户机。如果网络中有2个DHCP服务端且都给了反馈，此时计算机还需要返回一个数据通知他选择了谁提供的地址。<br>另一个DHCP客户端发现没要他的，于是收回他提供的。从这个角度看，网络中不能有太多的DHCP服务端,DHCP服务器必须是固定IP地址，DHCP跨网段配置IP地址需要DHCP配IP地址的计算机，需要在他所在的网络的路由器的网关上配置IPhelper address，再访问到DHCP.</p><h2 id="文本传输协议FTP"><a href="#文本传输协议FTP" class="headerlink" title="文本传输协议FTP"></a>文本传输协议FTP</h2><p><img src="/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="160px"><br>FTP使用两个TCP连接<br>FTP的连接方式包括控制连接和数据连接，每上传或下载一个文件就会建立一个会话。<br>控制连接：标准端口为21，用于发送FTP命令信息<br>数据连接：标准端口为20，用于上传或下载数据</p><h3 id="FTP数据连接"><a href="#FTP数据连接" class="headerlink" title="FTP数据连接"></a>FTP数据连接</h3><p>涉及主动模式和被动模式<br>主动模式：FTP客户端告诉FTP服务器的21端口，它在使用什么端口监听，然后FTP服务器的20端口主动和FTP客户端端口建立连接。</p><blockquote><p>主动模式防火墙需要打开21和20端口</p></blockquote><p>被动模式：FTP服务器打开在指定范围内的某个新端口并且进行监听，被动等待客户端发起连接。</p><blockquote><p>防火墙只能打开21和20端口，被动模式FTP不能下载数据。</p></blockquote><h3 id="FTP传输模式"><a href="#FTP传输模式" class="headerlink" title="FTP传输模式"></a>FTP传输模式</h3><p>文本模式：ASCII模式，以文本序列传输数据。<br>二进制模式：Binary模式，以二进制序列传输数据。</p><h2 id="telnet和RDP协议"><a href="#telnet和RDP协议" class="headerlink" title="telnet和RDP协议"></a>telnet和RDP协议</h2><p>远程终端协议telnet和远程桌面协议RDP都用来进行远程控制，RDP协议有图形界面，而telnet没有，Server多用户操作系统可以多用户同时使用服务器。</p><h2 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h2><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。<br>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h2 id="使用Web代理服务器访问网站"><a href="#使用Web代理服务器访问网站" class="headerlink" title="使用Web代理服务器访问网站"></a>使用Web代理服务器访问网站</h2><p>内网其它主机不能通过路由访问Internet，只能由web代理访问外网，然后内网其它主机访问这个web代理来实现上网功能，如果web代理在外网，反而速度更慢。</p><ol><li>节省内网访问Internet的带宽，便于访问内容变化不大的网站。</li><li>绕过防火墙访问外网，例如访问某个禁止的网站A，但是假如通过在与A同一个网络中的web代理，就可以访问该网站。</li><li>通过web代理避免被跟踪。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议详解</title>
    <link href="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h1><h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/11.png" srcset="/img/loading.gif" width="400px" height="250px"></p><ul><li>TCP是面向连接的传输层协议</li><li>每一条TCP连接只能有两个端点(endpoing)，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>面向字节流</li></ul><p>传输文件时，首先将文件进行分组然后放入缓存中，分组有大有小，将缓存中的数据再随机分组进行传输，接收端接收到分组的数据后放入接收缓存中，如果有丢包现象，要求发送端重新发送该丢包处后的数据 ，接收完成后，将数据存入计算机，最后拼接成完整的文件。</p><h2 id="TCP协议需要解决的问题"><a href="#TCP协议需要解决的问题" class="headerlink" title="TCP协议需要解决的问题"></a>TCP协议需要解决的问题</h2><ul><li>TCP如何实现可靠传输</li><li>TCP协议如何实现流量控制</li><li>TCP协议如何避免网络拥塞</li></ul><h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><ul><li>TCP把连接作为最基本的抽象。</li><li>每一条TCP连接有两个端点。</li><li>TCP连接的端口不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口，TCP连接的端点叫做套接字(socket)，端口号拼接到IP地址即构成了套接字。</li></ul><h2 id="可靠传输原理-停止等待协议"><a href="#可靠传输原理-停止等待协议" class="headerlink" title="可靠传输原理-停止等待协议"></a>可靠传输原理-停止等待协议</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.png" srcset="/img/loading.gif" width="360px" height="180px"><br>实现可靠传输要求发送端每发送一个数据包之后，接收端需要给发送端一个确认，并要求发送下一个数据包。如果发送方发送的数据包丢失，等待一段时间后发送方没有收到接收端的确认收到，则发送方会重新发送数据包。</p><ul><li>再发送完一个分组后，必须暂时保留已发送的分组副本。</li><li>分组和确认分组都必须进行编号</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ul><h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.png" srcset="/img/loading.gif" width="360px" height="180px"><br>接收端收到数据包后向发送端发送确认消息，如果确认消息丢失，发送端没有收到确认将会重新发送数据包，此时接收端会丢弃原有数据包，接收新的数据包。</p><p>如果发送端发送数据包后，接收端回复消息延迟，发送端会以为接收端没有收到数据包，重新发送，然后接收端丢弃原有数据包，接收新的数据包，过一段时间后发送端收到之前的确认消息会忽视。</p><h2 id="可靠通信的实现"><a href="#可靠通信的实现" class="headerlink" title="可靠通信的实现"></a>可靠通信的实现</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.png" srcset="/img/loading.gif" width="380px" height="160px"></p><ul><li>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</li><li>这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest).</li><li>ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</li></ul><p>停止等待协议优点是简单，缺点是信道利用率太低。<br>信道利用率: U = T<sub>D</sub> / T<sub>D</sub> + RTT + T<sub>A</sub></p><h2 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.png" srcset="/img/loading.gif" width="380px" height="160px"></p><p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方确认。<br>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。</p><h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/6.png" srcset="/img/loading.gif" width="380px" height="160px"></p><p>发送端口假设为5，发送端需要发送5个数据包。<br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/8.png" srcset="/img/loading.gif" width="380px" height="160px"><br>接收端收到前四个数据包后，向发送端进行确认，然后发送端会将发送窗口进行右移，如果12收到了，3没有收到，则滑动窗口会会回溯到3位置，重新发送。</p><h2 id="TCP报文首部格式"><a href="#TCP报文首部格式" class="headerlink" title="TCP报文首部格式"></a>TCP报文首部格式</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/9.png" srcset="/img/loading.gif" width="400px" height="250px"></p><ol><li>源端口： 2个字节</li><li>目的端口： 2个字节</li><li>序号： 当前数据的第一个字节在整个文件中的序号</li><li>确认号(ACK)： 接收端发送，提示发送端下一次该发送的数据在整个文件中的序号。接收端收到后，将这个序号之前的数据从缓存中删除。</li><li>数据偏移： 表示当前TCP报文段后多少个字节是TCP的数据部分。数据偏移最多表示二进制1111，即10进制的15，每个1表示4个字节，所以数据偏移最大表示报文首部为60个字节。</li><li>保留： 6位，无作用</li><li>URG： urgent，代表优先级，发送端优先发送而不是在缓存中排队。</li><li>ACK： acknowledge，设置1代表确认建立会话。</li><li>PSH： 设置1代表接收端优先读取，不需要再接收端的缓存中排队</li><li>RST： reset，设置为1代表TCP会话出现严重错误，必须释放和重连。</li><li>SYN： 同步，设置为1代表需要发起会话。</li><li>FIN： finish，设置为1代表释放连接</li><li>窗口： 接收端先发送，发送端根据接收端的窗口大小确定发送端窗口大小。</li><li>检验和： 校验范围，TCP首部和数据</li><li>紧急指针： 只有URG设置为1可用，表示优先级数据的尾部</li></ol><blockquote><p>WindowXP可以利用TCP协议漏洞进行Land与SYN攻击</p></blockquote><h2 id="TCP抓包分析"><a href="#TCP抓包分析" class="headerlink" title="TCP抓包分析"></a>TCP抓包分析</h2><p>访问网站进行抓包，数据包主要分为TCP、UDP和ARP。</p><ul><li>首先ARP协议发送广播询问目标网站IP地址</li><li>DNS进行域名解析</li><li>TCP建立会话，进行三次握手然后发送数据</li></ul><blockquote><p>MSS：能传输的最大数据包，Win： 窗口大小</p></blockquote><h3 id="传输数据流程"><a href="#传输数据流程" class="headerlink" title="传输数据流程"></a>传输数据流程</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/10.png" srcset="/img/loading.gif" width="360px" height="180px"></p><h2 id="以字节为单位的滑动窗口技术实现可靠传输"><a href="#以字节为单位的滑动窗口技术实现可靠传输" class="headerlink" title="以字节为单位的滑动窗口技术实现可靠传输"></a>以字节为单位的滑动窗口技术实现可靠传输</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/12.png" srcset="/img/loading.gif" width="400px" height="250px"><br>A的发送窗口由B的接收窗口大小决定，TCP协议会协商窗口大小参数。<br>在没有收到B确认收到之前，A不能删掉滑动窗口内的内容，A可以持续给B发送，直到A的滑动窗口内数据都发了。<br>B收到后给A的确认消息后反馈ACK，序号是下一个应该发送的字节的序号，A收到后，就可以滑动窗口到对应的位置。例如B反馈ACK是7，那么A的滑窗可以移动到7位置，1-6删除。21-26可以发送。<br>以上是正常状态下的情况。如果出现丢失情况，例如7-9丢失，此时B反馈的ACK=7.因为10-12收到了，因此B发送SACK(选择性确认)，A只发送7-9。</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>TCP每发送一个报文段，就对这个报文段设置一次计时器，只要计时器设置的重传时间到但还没收到确认，就要重传这一段报文。<br>新的RTT<sub>s</sub> = (1 - a)<em>(旧的RTT<sub>s</sub>) +a </em>新的RTT样本<br>超时重传时间应略大于上面的出的加权平均往返时间RTT<sub>s</sub><br>RFC2988推荐的a值为1/8</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>解决通信两端处理时间不一样的问题。通过实时调整滑窗尺寸的大小(尺寸可以是0)来实现流量控制。接收端主动调整滑窗大小，发送端根据接收端发送的报文调整相应的滑窗。发送端也会定时发送报文向接收端确认滑窗信息，避免接收端发送的相关调整滑窗大小的报文丢失带来的影响。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/20.png" srcset="/img/loading.gif" width="400px" height="250px"><br>出现资源拥塞的条件：对资源需求的总和&gt;可用资源<br>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制，它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方维持拥塞窗口,发送方控制拥塞窗口的原则：<br>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。<br>只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><blockquote><p>拥塞窗口cwnd(congestion window)</p></blockquote><h3 id="慢开始算法的原理"><a href="#慢开始算法的原理" class="headerlink" title="慢开始算法的原理"></a>慢开始算法的原理</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/21.png" srcset="/img/loading.gif" width="360px" height="180px"></p><h3 id="设置慢开始门限状态变量ssthresh"><a href="#设置慢开始门限状态变量ssthresh" class="headerlink" title="设置慢开始门限状态变量ssthresh"></a>设置慢开始门限状态变量ssthresh</h3><p>慢开始门限ssthresh的用法如下：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，停止使用满开始算法而改用拥塞避免算法。</li><li>当cwnd=ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法。</li></ul><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。</p><h3 id="慢开始和拥塞避免算法举例"><a href="#慢开始和拥塞避免算法举例" class="headerlink" title="慢开始和拥塞避免算法举例"></a>慢开始和拥塞避免算法举例</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/22.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>拥塞避免并非指完全能够避免拥塞，是在拥塞避免阶段把拥塞窗口控制为按线性规律增长，是网络比较不容易出现拥塞。</p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/23.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>快重传算法首先要求接收方每收到一个失序的报文后就立即发出重复确定。这样做可以让发送方及早知道有报文没有到达接收方。<br>当发送端收到连续三个重复的确定时，就执行”乘法减小”算法，把慢开始门限ssthresh减半，但拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大。</p><h3 id="发送窗口的实际上限值"><a href="#发送窗口的实际上限值" class="headerlink" title="发送窗口的实际上限值"></a>发送窗口的实际上限值</h3><p>发送方的发送窗口的上限值应当取为接收方窗口和拥塞窗口这两个变量中较小的一个，即：发送窗口上限值=Min[rwnd,cwnd]</p><h2 id="TCP的传输连接管理"><a href="#TCP的传输连接管理" class="headerlink" title="TCP的传输连接管理"></a>TCP的传输连接管理</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/14.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>传输连接有三个阶段： 连接建立，数据传送，连接释放</p><ul><li>TCP连接的建立都是采用客户服务器方式</li><li>主动发起连接建立的应用进程叫做客户(client)</li><li>被动等待连接建立的应用进程叫做服务器(server)</li></ul><h2 id="第三次握手的原因"><a href="#第三次握手的原因" class="headerlink" title="第三次握手的原因"></a>第三次握手的原因</h2><p>假如把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A和B之间的通信，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数据分组。可是，B的应答分组在传输中被丢失的情况下，A将不知道B是否已准备好，A认为连接还未建立成功，将忽略B发来的任何数据分组，这样就形成了死锁。</p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/15.png" srcset="/img/loading.gif" width="450px" height="260px"></p><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/16.png" srcset="/img/loading.gif" width="450px" height="260px"></p><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/17.png" srcset="/img/loading.gif" width="450px" height="260px"></p><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/18.png" srcset="/img/loading.gif" width="450px" height="260px"></p><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/19.png" srcset="/img/loading.gif" width="450px" height="260px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层与UDP协议简述</title>
    <link href="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <url>/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输层概述与UDP协议简述"><a href="#传输层概述与UDP协议简述" class="headerlink" title="传输层概述与UDP协议简述"></a>传输层概述与UDP协议简述</h1><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><ul><li>传输层协议UDP和TCP</li><li>网络安全</li><li>TCP可靠传输的实现</li><li>TCP的流量控制</li><li>TCP的拥塞控制</li><li>TCP的运输连接管理</li></ul><h2 id="OSI和DOD模型"><a href="#OSI和DOD模型" class="headerlink" title="OSI和DOD模型"></a>OSI和DOD模型</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/2.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="传输层两个协议"><a href="#传输层两个协议" class="headerlink" title="传输层两个协议"></a>传输层两个协议</h2><p>在TCP/IP协议栈，传输层有两个协议TCP和UDP。</p><ul><li>TCP(Transmission Control Protocol)传输控制协议</li><li>UDP(User Data Protocol)用户数据报协议</li></ul><p>TCP 需要将要传输的文件分段 传输 建立会话 可靠传输 流量控制<br>UDP 一个数据包就能够完成数据通信 不分段 不需要建立会话 不需要流量控制 不可靠传输 (屏幕广播 多播 广播)</p><h2 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/3.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="常见的应用层协议使用端口"><a href="#常见的应用层协议使用端口" class="headerlink" title="常见的应用层协议使用端口"></a>常见的应用层协议使用端口</h2><ul><li>http = TCP + 80</li><li>https = TCP + 443</li><li>RDP = TCP + 3389</li><li>ftp = TCP + 21</li><li>共享文件夹 = TCP + 445</li><li>SMTP = TCP + 25</li><li>POP3 = TCP + 110</li><li>telnet = TCP + 23</li><li>SQL = TCP + 1433</li><li>DNS = UDP + 53</li></ul><h2 id="服务和应用层协议之间的关系"><a href="#服务和应用层协议之间的关系" class="headerlink" title="服务和应用层协议之间的关系"></a>服务和应用层协议之间的关系</h2><ul><li>服务使用TCP或UDP的端口侦听客户端请求</li><li>客户端使用IP地址定位服务器 使用目标端口定位服务</li><li>可以在服务器网卡上设置只开放必要的端口 实现服务器网络安全</li><li>可以更改服务使用的默认端口，迷惑病毒，让系统更安全</li></ul><h2 id="如何查看服务侦听的端口"><a href="#如何查看服务侦听的端口" class="headerlink" title="如何查看服务侦听的端口"></a>如何查看服务侦听的端口</h2><pre><code>netstat -anetstat -an 以数字的形式查看端口netstat -n 查看建立的会话netstat -nb 查看建立会话的进程telnet 192.168.80.100 3389 测试到远程计算机某个端口是否打开</code></pre><h2 id="传输层的功能-1"><a href="#传输层的功能-1" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>为相互通信的应用进程提供了端到端的逻辑通信</li><li>传输层还要对收到的报文进行差错检测</li><li>传输层提供面向连接和无连接的服务</li></ul><h2 id="传输层协议和网络层协议的主要区别"><a href="#传输层协议和网络层协议的主要区别" class="headerlink" title="传输层协议和网络层协议的主要区别"></a>传输层协议和网络层协议的主要区别</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/5.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/6.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>端口用一个16位端口号进行标志</li><li>端口号只具有本地意义，即端口号只为了标志本计算机应用层中的各进程。在因特网中不同的计算机的相同端口号是没有联系的。</li><li>熟知端口，数值一般为0-1023.</li><li>登记端口号，数值为1024-49151.</li><li>客户端口号，数值为49152-65535.</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>UDP是无连接的，即发送数据之前不需要建立连接</li><li>UDP使用最最大努力交付，及不保证可靠交付，同时也不使用拥塞控制。</li><li>UDP是面向报文的，UDP没有拥塞控制，适合多媒体通信的要求。</li><li>UDP支持一对一，一对多，多对多的交互通信。</li><li>UDP的首部开销小，只有8字节。</li></ul><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/7.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/8.png" srcset="/img/loading.gif" width="375px" height="220px"><br>首部中的长度指的是UDP用户数据报的长度(首部+数据)，伪首部用于检验和。</p><h3 id="计算UDP检验和的例子"><a href="#计算UDP检验和的例子" class="headerlink" title="计算UDP检验和的例子"></a>计算UDP检验和的例子</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/9.png" srcset="/img/loading.gif" width="375px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP数据包与路由</title>
    <link href="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h2><p>一个IP数据包由首部和数据两部分组成。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/2.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部的前一部分是固定长度，共字节，是所有IP数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><h3 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h3><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>版本：用来表示TCP/IP协议的版本 v4,v6</li><li>首部长度：确定数据包首部有多长，因为包含可变部分。</li><li>区分服务：确定更高的传输优先级。(QoS机制)</li><li>总长度：确定数据部分长度，一共16位，最多有2^16-1=65535字节。</li></ul><blockquote><p>传输限制：数据包最大65535字节，而数据链路层最大传输1500字节，所以对于大于1500字节的数据包，将会进行分片传输。（最大传输单元MTU）<br>分片传输：将数据进行分割，分别添加IP地址，通过网络发给接收端。接收端在通过网络层进行拼接，传送过程中可能存在丢包现象，或者后发的先到，所以需要对分片的数据包进行编号。<br>泪滴攻击：指的是向目标机器发送损坏的IP包，诸如重叠的包或者过大的包载荷。借由这些手段，该攻击可以通过TCP/IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p></blockquote><p>以太网V2数据帧模式：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>标识：如果出现数据包分片，那么标识用来确定哪些数据包需要组合，进行相同标记。</li><li>标志：占位，目前只有前两位有意义。标志字段的最低位是MF(More Fragment)，MF=1表示后面还有分片，MF=0表示最后一个分片，标志字段中间的一位是DF(Don`t Fragment)，只有当DF=0时才允许分片。</li></ul><p>数据包分片举例：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/5.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>片偏移：偏移等于当前字节在数据部分的第几个再除以8.</li><li>生存时间：就是TTL(Time To Live)，每经过一个路由器就减1，8位二进制，作用是防止数据包在网络中循环。</li><li>协议号：用协议号标识数据部分是什么数据。<blockquote><p>ICMP：1, IGMP：2, TCP：6, UDP：17, IPv6：41, OSPF：89</p></blockquote></li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部检验和：16位，只检验数据报的首部，不检验数据部分，这里不是采用CRC而是简单的计算方法，每经过一个路由器就会检验一次。</li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/7.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>源地址和目的地址：都是IP地址，32位，只符合IPv4.IPv6是128位。</li><li>可变部分：一般没用，IPv6已取消。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="网络畅通的条件"><a href="#网络畅通的条件" class="headerlink" title="网络畅通的条件"></a>网络畅通的条件</h3><p>沿途路由器必须知道下一跳给谁，数据包有去有回。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/8.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>需要管理员手动设置路由表，适用于小规模网络，不能自动调整路由。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol><li>RIP协议<br>作用是周期性广播路由表，选择最佳路径，能够自动学习路由，最大15跳，不适合大规模网络。</li><li>OSPF协议<br>根据带宽选择路径</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICMP与IGMP协议</title>
    <link href="/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ICMP与IGMP协议"><a href="#ICMP与IGMP协议" class="headerlink" title="ICMP与IGMP协议"></a>ICMP与IGMP协议</h1><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol).</p><ul><li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</li><li>ICMP 不是高层协议，而是IP层的协议。</li><li>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据包发送出去。</li></ul><h2 id="ping命令诊断网络故障"><a href="#ping命令诊断网络故障" class="headerlink" title="ping命令诊断网络故障"></a>ping命令诊断网络故障</h2><ul><li>PING(Packet Internet Grope),因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</li><li>ping指的是端对端连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数 防火墙的一个基本功能提供给用户进行选择。</li><li>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</li></ul><h3 id="使用ICMP协议的命令"><a href="#使用ICMP协议的命令" class="headerlink" title="使用ICMP协议的命令"></a>使用ICMP协议的命令</h3><p>TTL是数据报的生存时间，每过一个路由器就会减1，作用是防止数据报在网络中循环。<br>TTL默认初始值如下：</p><ul><li>Linux 64</li><li>Windows 128</li><li>Unix 255</li></ul><h3 id="ping与pathping命令"><a href="#ping与pathping命令" class="headerlink" title="ping与pathping命令"></a>ping与pathping命令</h3><p>pathing能跟踪数据包路径，发现问题位置。<br>Windows上跟踪数据包路径的命令：tracerert ip地址<br>路由器上跟踪数据包路径的命令： traceroute ip地址</p><h2 id="IGMP协议与多播"><a href="#IGMP协议与多播" class="headerlink" title="IGMP协议与多播"></a>IGMP协议与多播</h2><p>数据通信分为点到点通信，广播通信，还有组播通信。组播也称为多播通信。<br>多播通信可以跨网段，将数据同时传递给多个计算机，避免了占用大量带宽。<br>使用多播一般用于直播，网络会议等。<br>IGMP协议的作用就是周期性扫描本网段内有没有主机在访问多播数据包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层概述与ARP协议</title>
    <link href="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IOS网络层概述"><a href="#IOS网络层概述" class="headerlink" title="IOS网络层概述"></a>IOS网络层概述</h1><h2 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h2><p>负责在不同网络之间尽力转发数据包</p><blockquote><ul><li>基于数据包的IP地址转发</li><li>不负责丢失重传</li><li>不负责顺序</li></ul></blockquote><h2 id="数据包在Internet中传输"><a href="#数据包在Internet中传输" class="headerlink" title="数据包在Internet中传输"></a>数据包在Internet中传输</h2><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/2.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>路由器是三层设备：能看到网络层的IP地址来选择路径</p></blockquote><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/3.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h2 id="互联网与虚拟互联网"><a href="#互联网与虚拟互联网" class="headerlink" title="互联网与虚拟互联网"></a>互联网与虚拟互联网</h2><h3 id="互联网互联的设备"><a href="#互联网互联的设备" class="headerlink" title="互联网互联的设备"></a>互联网互联的设备</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/4.png" srcset="/img/loading.gif" width="420px" height="250px"></p><ol><li>物理层中继系统：转发器(repeater)，类似集线器</li><li>数据链路层中继系统：网桥或桥接器(bridge)</li><li>网络层中继系统：路由器(router)</li><li>传输层/应用层中继系统：网关(gateway)</li></ol><blockquote><p>中间设备又称为中间系统或中继系统(relay).<br>网关就是路由器接口的地址。一般是本网段第一个地址。</p></blockquote><h3 id="网络需要解决的问题"><a href="#网络需要解决的问题" class="headerlink" title="网络需要解决的问题"></a>网络需要解决的问题</h3><ol><li>不同寻址方案</li><li>不同最大分组长度</li><li>不同网络接入机制</li><li>不同超时控制</li><li>不同差错恢复方法</li><li>不同状态报告方法</li><li>不同路由选择技术</li><li>不同用户接入控制</li><li>不同服务</li><li>不同管理与控制方式</li></ol><blockquote><p>虚拟互联网将复杂的互联网抽象成一个网络，这样用户只需要关心如何接入互联网而不需要关心互联网的复杂性，简化了问题模型。</p></blockquote><h2 id="网络设备和OSI参考模型的关系"><a href="#网络设备和OSI参考模型的关系" class="headerlink" title="网络设备和OSI参考模型的关系"></a>网络设备和OSI参考模型的关系</h2><h3 id="PC4向PC3传输数据"><a href="#PC4向PC3传输数据" class="headerlink" title="PC4向PC3传输数据"></a>PC4向PC3传输数据</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/5.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h4 id="发送端："><a href="#发送端：" class="headerlink" title="发送端："></a>发送端：</h4><ol><li>应用层准备要传输的数据文件；</li><li>传输层把数据进行分段并编号；(数据段)</li><li>网络层把传输层的每一个数据包增加原IP地址和目标IP地址；(数据包)</li><li>数据链路层把每个数据加上MAC地址；(数据帧)</li><li>物理层把数据帧变成数字信号(bit流)</li></ol><p>如何通过Mac地址进行转发数据:</p><ul><li>使用本计算机地址的子网掩码，判断本地址和目标地址分别在哪个网段，若在同一个网段(不过路由器)，通过ARP协议广播的方式得到目标IP地址的MAC地址，然后就能封装出一个数据帧；</li><li>如果子网掩码不是一个网段(与运算)，通过ARP协议广播的方式得到路由器(网关)的MAC地址，然后把数据通过交换机发送到路由器M2，路由器M2在通过广播的方式得到目标IP地址与Mac地址。</li></ul><blockquote><p>因为M2和M3是点对点通信，没有别的主机，所以它们之间的MAC地址就是FF。</p></blockquote><h4 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h4><ol><li>交换机Hub0接收bit流，能对数据进行存储转发。它根据数据帧的MAC地址，确定数据是从哪来的，要去哪。</li><li>路由器M2获取交换机的数据包，识别其中的IP地址，根据路由表选择出口，它无法识别数据段内容。</li><li>路由器M2到M3是点对点通信，遵守PPP协议。</li><li>PC3收到bit流后，数据链路层发现MAC地址是自己的，去掉MAC地址给它的网络层，网络层去掉IP地址给传输层，传输层把数据给应用层，应用层把各个数据拼接起来，进而得到文件。</li></ol><h4 id="路由器与交换机、集线器会不会中病毒？"><a href="#路由器与交换机、集线器会不会中病毒？" class="headerlink" title="路由器与交换机、集线器会不会中病毒？"></a>路由器与交换机、集线器会不会中病毒？</h4><p>不会，因为路由器不能识别数据内容，只进行数据的传递，而交换机与集线器分别工作在数据链路层与物理层，更不会中病毒。但病毒可以影响网络设备的正常工作，例如频繁广播发送数据，占用带宽影响效率，使这些设备一直处于忙碌状态。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="TCP-IP协议层次关系"><a href="#TCP-IP协议层次关系" class="headerlink" title="TCP/IP协议层次关系"></a>TCP/IP协议层次关系</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/6.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>ARP协议为IP协议提供服务，IP协议为ICMP与IGMP协议提供服务。</p></blockquote><h3 id="ARP协议功能"><a href="#ARP协议功能" class="headerlink" title="ARP协议功能"></a>ARP协议功能</h3><p>将IP地址通过广播，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址，只能在本网段使用，ARP是解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射关系。<br>如果所找的主机和原主机不在同一个局域网上，那么就要通过ARP找一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。<br>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知情的，只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址。</p><blockquote><p>arp -a可以查看本地解析过的Mac表缓存。<br>逆地址解析协议(RARP)：只知道自己MAC地址就能获得其IP地址。</p></blockquote><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>ARP欺骗的运作原理是由攻击者发送假的ARP数据包到网上，尤其是送到网关上。其目的是要让送至特定的IP地址的流量被错误送到攻击者所取代的地方。因此攻击者可将这些流量另行转送到真正的网关（被动式数据包嗅探，passive sniffing）或是篡改后再转送（中间人攻击，man-in-the-middle attack）。攻击者亦可将ARP数据包导到不存在的MAC地址以达到阻断服务攻击的效果，例如netcut软件。<br>例如：某一的IP地址是192.168.0.254，其MAC地址为00-11-22-33-44-55，网上上的计算机内ARP表会有这一笔ARP记录。攻击者发动攻击时，会大量发出已将192.168.0.254的MAC地址篡改为00-55-44-33-22-11的ARP数据包。那么网上上的计算机若将此伪造的ARP写入自身的ARP表后，计算机若要透过网上网关连到其他计算机时，数据包将被导到00-55-44-33-22-11这个MAC地址，因此攻击者可从此MAC地址截收到数据包，可篡改后再送回真正的网关，或是什么也不做，让网上无法连线。</p><h3 id="防止ARP欺骗的两种方法"><a href="#防止ARP欺骗的两种方法" class="headerlink" title="防止ARP欺骗的两种方法"></a>防止ARP欺骗的两种方法</h3><ol><li>静态绑定，使用arp -s 命令进行静态绑定，静态绑定后双方计算机通信不在使用ARP协议进行动态获取，可直接进行对目标计算机的通信。可将脚本命令编辑成.bat脚本，用gpedit.msc打开组策略，在开机登陆中添加该脚本，则脚本代码开机自动启动。</li><li>使用ARP防火墙进行防御。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac层与快速以太网</title>
    <link href="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Mac层与快速以太网"><a href="#Mac层与快速以太网" class="headerlink" title="Mac层与快速以太网"></a>Mac层与快速以太网</h1><h2 id="Mac层的硬件地址"><a href="#Mac层的硬件地址" class="headerlink" title="Mac层的硬件地址"></a>Mac层的硬件地址</h2><ul><li>在局域网中，硬件地址又称为物理地址，或Mac地址.</li><li>802标准所说的地址严格的讲应当是每一个站的名字或标识符.<br>但鉴于大家都已经习惯了将这种48位的名字称为地址，所以就采用了这种习惯用法。</li><li>IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节(即高位24位),地址字段中的后三个字节(即低位24位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址.</li><li>一个地址块可以生成2的24次方个不同的地址，这种48位地址称为Mac-48，它的通用名称是EUI-48.</li><li>Mac地址实际上就是适配器地址或适配器标识符EUI-48.</li></ul><h2 id="适配器检查Mac地址"><a href="#适配器检查Mac地址" class="headerlink" title="适配器检查Mac地址"></a>适配器检查Mac地址</h2><ol><li>适配器从网络上每收到一个Mac帧就首先用硬件检查Mac帧中的Mac地址</li><li>如果是发送本站的帧则收下，然后在进行其他的处理</li><li>否则就将此帧丢弃，不再进行其他的处理</li></ol><p>发送本站的帧，包括以下三种:</p><ul><li>单播帧 （一对一）</li><li>广播帧 （一对全体）</li><li>多播帧 （一对多）</li></ul><h2 id="Mac帧格式"><a href="#Mac帧格式" class="headerlink" title="Mac帧格式"></a>Mac帧格式</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="380px" height="220px"><br>前8个字节作用是实现比特同步，第一个字段共七个字节，称为前同步码，作用是实现快速Mac帧的比特同步。</p><h3 id="以太网V2的Mac帧格式"><a href="#以太网V2的Mac帧格式" class="headerlink" title="以太网V2的Mac帧格式"></a>以太网V2的Mac帧格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="无效的Mac帧"><a href="#无效的Mac帧" class="headerlink" title="无效的Mac帧"></a>无效的Mac帧</h3><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>数据字段的长度不在46-1500字节之间</li><li>有效的Mac帧长度为64-1518字节之间</li><li>对于检查出的无效Mac帧就简单地丢弃。以太网不负责重传丢弃地帧。</li></ul><h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为9.6us，相当于96bit地的发送时间,一个站在检测到总线开始空闲后，还要等待9.6us才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层考虑扩展"><a href="#在物理层考虑扩展" class="headerlink" title="在物理层考虑扩展"></a>在物理层考虑扩展</h3><p><strong>距离扩展</strong>：<br>主机使用光纤和一对光纤调制解调器连接到集线器<br><strong>数量扩展</strong>：<br>集线器级联：使网络中计算机增加，变成一个大的冲突域，会造成效率降低</p><h4 id="用集线器扩展局域网优点"><a href="#用集线器扩展局域网优点" class="headerlink" title="用集线器扩展局域网优点"></a>用集线器扩展局域网优点</h4><ul><li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信</li><li>扩大了局域网覆盖的地理范围</li><li>用集线器扩展局域网缺点</li><li>碰撞域增大了，但总的吞吐量并未提高</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将他们互连起来</li></ul><h3 id="在数据链路层考虑扩展"><a href="#在数据链路层考虑扩展" class="headerlink" title="在数据链路层考虑扩展"></a>在数据链路层考虑扩展</h3><p>在数据链路层扩展局域网使用网桥</p><ul><li>网桥工作在数据链路层，它根据Mac帧的目的地址对收到的帧进行转发。</li><li>网桥具有过滤帧的功能和学习功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的Mac地址，然后再确定将该帧转发到哪一个接口</li></ul><p>优点：过滤通信量，扩大物理范围，提高可靠性，可互连不同物理层，不同Mac子层和不同速率。<br>缺点：存储转发增加了时延，在Mac子层并没有流量控制功能。具有不同Mac子层的网段桥接在一起时延更大，网桥只适合用户不太多和通信量不太大的局域网，否则有时还会因传播过多的广播信息导致网络拥塞。</p><h4 id="网桥自学习算法"><a href="#网桥自学习算法" class="headerlink" title="网桥自学习算法"></a>网桥自学习算法</h4><p>按照以下子学习算法处理收到的帧和建立转发表。</p><ul><li>若从A发出的帧从接口x进入到了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。</li><li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li><li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。</li><li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的，这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li></ul><blockquote><p>ps：网桥是交换机的前身，透明网桥：指局域网上的站点不知道所发送的帧将经过几个网桥，因为网桥对于各站点是看不见的，透明网桥使用生成树算法避免产生转发的帧在网络中成环。</p></blockquote><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>互联在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集中，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。<br>为了避免产生转发的帧在网络中不停兜圈子。<br>为了得出能够反应网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>随着网桥接口的增加，后来网桥和集线器合并了，计算机可以直接和交换机连接，这就是交换机。交换机就是网桥和集线器的合并版，能全双工，安全通信。</p><ul><li>端口带宽独享</li><li>安全</li><li>基于Mac地址转发</li><li>通过学习构建Mac地址表</li></ul><h2 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h2><h3 id="100BASE-T以太网"><a href="#100BASE-T以太网" class="headerlink" title="100BASE-T以太网"></a>100BASE-T以太网</h3><p>速率达到或超过100Mb/s的以太网称为高速以太网。<br>在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议。<br>100BASE-T以太网又称为快速以太网(Fast Ethernet)。</p><h4 id="100Base-T以太网的物理层："><a href="#100Base-T以太网的物理层：" class="headerlink" title="100Base-T以太网的物理层："></a>100Base-T以太网的物理层：</h4><ul><li>100BASE-TX ： 使用2对UTP5类线或屏蔽双绞线STP</li><li>100BASE-FX : 使用2对光纤</li><li>100BASE-T4 : 使用4对UTP3类线或5类线</li></ul><h4 id="100Base-T特点"><a href="#100Base-T特点" class="headerlink" title="100Base-T特点"></a>100Base-T特点</h4><ul><li>可在全双工方式下工作而无冲突发生，因此，不使用CSMA/CD协议。Mac帧格式仍然是802.3标准规定的。</li><li>保持最短帧长不变，但将一个网段的最大电缆长度减小到100m，帧间时间间隔从原来的9.6us改为现在的0.96us。</li></ul><h3 id="G比特以太网"><a href="#G比特以太网" class="headerlink" title="G比特以太网"></a>G比特以太网</h3><ul><li>允许在1GB/s下全双工和半双工两种方式工作</li><li>使用802.3协议规定的帧格式</li><li>在半双工方式下使用CSMA/CD协议(全双工方式不需要使用CSMA/CD协议)</li><li>与10BASE-T和100BASE-T技术 向后兼容</li><li>当G比特以太网工作 在全双工方式时,不使用载波延伸和分组突发</li></ul><h3 id="G比特以太网的物理层"><a href="#G比特以太网的物理层" class="headerlink" title="G比特以太网的物理层"></a>G比特以太网的物理层</h3><h4 id="1000BASE-x-基于光纤通道的物理层："><a href="#1000BASE-x-基于光纤通道的物理层：" class="headerlink" title="1000BASE-x 基于光纤通道的物理层："></a>1000BASE-x 基于光纤通道的物理层：</h4><ul><li>1000BASE-SX SX表示短波长 传输距离275或550米</li><li>1000BASE-LX LX表示长波长 550米或5000米</li><li>1000BASE-CX CX表示铜线 传输距离25米</li></ul><h4 id="1000BASE-T："><a href="#1000BASE-T：" class="headerlink" title="1000BASE-T："></a>1000BASE-T：</h4><ul><li>使用四对5类线UTP</li></ul><h4 id="G比特以太网配置举例"><a href="#G比特以太网配置举例" class="headerlink" title="G比特以太网配置举例"></a>G比特以太网配置举例</h4><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/4.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="10G比特以太网"><a href="#10G比特以太网" class="headerlink" title="10G比特以太网"></a>10G比特以太网</h3><ul><li>同10Mb/s，100Mb/s，1Gb/s以太网的帧格式完全相同</li><li>保留了802.3标准规定的以太网最小和最大帧长，便于升级</li><li>不再使用铜线而只使用光纤作为传输媒体</li><li>只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议。</li></ul><h2 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h2><p>10G比特以太网的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输 。<br>这种工作方式的好处是：</p><ul><li>成熟的技术</li><li>互操作性很好</li><li>在广域网中使用以太网时价格便宜</li><li>统一的帧格式简化了操作和管理</li></ul><h2 id="Cisco建网3层模型"><a href="#Cisco建网3层模型" class="headerlink" title="Cisco建网3层模型"></a>Cisco建网3层模型</h2><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/5.png" srcset="/img/loading.gif" width="380px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以太网</title>
    <link href="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h2><ul><li>DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约。</li><li>IEEE 的802.3标准。</li></ul><blockquote><p>DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为以太网。<br>严格说来，以太网应当是指符合DIX Ethernet V2 标准的局域网</p></blockquote><h2 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h2><p>为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层.</p><ul><li>逻辑链路控制LLC(Logical Link Control)子层</li><li>媒体接入控制MAC(Medium Access Control)子层</li></ul><blockquote><p>与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。<br>由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路控制子层LLC(即802.2标准)的作用已经不大了.<br>很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。</p></blockquote><h2 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h2><ul><li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li><li>当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</li><li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li></ul><h2 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h2><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="375px" height="220px"><br>传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不同电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。<br>这种以太网采用星型拓扑，在星型的中心则增加了一种可靠性非常高的设备，叫集线器。</p><h2 id="集线器的一些特点"><a href="#集线器的一些特点" class="headerlink" title="集线器的一些特点"></a>集线器的一些特点</h2><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线。</p><blockquote><p>集线器很像一个多接口的转发器，工作在物理层。</p></blockquote><h2 id="集线器连以太网定义的标准"><a href="#集线器连以太网定义的标准" class="headerlink" title="集线器连以太网定义的标准"></a>集线器连以太网定义的标准</h2><p>10BASE-T的通信距离稍短，每个站到集线器的距离不超过100m。<br>这种10Mb/s速率的无屏蔽双绞线星型网的出现，既降低了成本，又提高了可靠性。<br>10BASE-T双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p><blockquote><p>其他： 100Base-FX 100Base-T 100Base-T4</p></blockquote><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><h3 id="以太网的信道被占用的情况"><a href="#以太网的信道被占用的情况" class="headerlink" title="以太网的信道被占用的情况"></a>以太网的信道被占用的情况</h3><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>争用期长度为2γ，即端到端传播时延的两倍。碰撞到碰撞后不发送干扰信号。<br>帧长为L(bit)，数据发送速率为C(b/s)，因而帧的发送时间为L/C=T0(s).<br>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间γ使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p><h3 id="提高信道利用率"><a href="#提高信道利用率" class="headerlink" title="提高信道利用率"></a>提高信道利用率</h3><p>要提高以太网信道利用率，就必须减小γ与t0之比，以太网中定义了参数a，是以太网单程端到端时延γ与帧的发送时间t0之比:<br>a = γ/t0<br>a -&gt; 0表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a越大，表明争用期所占比例增大，每发生一次碰撞就浪费许多信道资源，使信道利用率明显降低。</p><h2 id="信道利用率最大值"><a href="#信道利用率最大值" class="headerlink" title="信道利用率最大值"></a>信道利用率最大值</h2><h3 id="对以太网参数的要求"><a href="#对以太网参数的要求" class="headerlink" title="对以太网参数的要求"></a>对以太网参数的要求</h3><ul><li>当数据率一定时，以太网的连线的长度受到限制否则γ的数值会太大</li><li>以太网的帧长不能太短，否则t0的值会太小，使a值太大。</li></ul><h3 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h3><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞(这显然已经不是CSMA/CD，而是需要使用一种特殊的调度算法)，即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是t0 + γ，而帧的本身的发送时间是t0，于是我们可计算理想情况下的极限信道利用率Smax为：<br>Smax = t0/t0 + γ = 1/1+a</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用广播信道的数据链路层</title>
    <link href="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="使用广播信道的数据链路层-局域网"><a href="#使用广播信道的数据链路层-局域网" class="headerlink" title="使用广播信道的数据链路层(局域网)"></a>使用广播信道的数据链路层(局域网)</h1><h2 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点:"></a>局域网最主要的特点:</h2><p>网络为一个单位所拥有，且地理范围和站点数目均有限。<br>局域网具有如下的一些主要优点：</p><ul><li>具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性，可用性和生存性。</li></ul><h2 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h2><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul><h3 id="动态媒体接入控制-多点接入"><a href="#动态媒体接入控制-多点接入" class="headerlink" title="动态媒体接入控制(多点接入)"></a>动态媒体接入控制(多点接入)</h3><ul><li>随机接入(主要被以太网采用)</li><li>受控接入 ,如多点线路探询，或轮询。(目前已不被采用)</li></ul><h2 id="认识以太网"><a href="#认识以太网" class="headerlink" title="认识以太网"></a>认识以太网</h2><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。<br>总线上的每一个工作的计算机都能检测到b发送的数据信号.<br>由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。<br>其他计算机都检测到不是发送给他们的数据帧，因此就丢弃这个数据帧而不能接收下来。<br>具有广播特性的总线上实现了一对一的通信。</p><h3 id="带冲突检测的载波监听-碰撞检测"><a href="#带冲突检测的载波监听-碰撞检测" class="headerlink" title="带冲突检测的载波监听/碰撞检测"></a>带冲突检测的载波监听/碰撞检测</h3><p><strong>CSMA/CD</strong>: Carrier Sense Multiple Access with Collision Detection<br><strong>多点接入</strong>: 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong>: 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><blockquote><p>载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号</p><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>碰撞检测就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)<br>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。<br>所谓碰撞就是发生了冲突，因此碰撞检测也被称为冲突检测</p></blockquote><p><strong>检测到碰撞后</strong>:<br>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。<br>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送.</p><h3 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h3><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信)。</li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>最先发送数据帧的站，在发送数据帧后至多经过时间2γ(2倍的端到端往返时延)就知道发送的数据帧是否遭受了碰撞。<br>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p><strong>以太网的争用期</strong>：</p><ul><li>以太网的端到端往返时延2γ称为争用期，或碰撞窗口。通常，取51.2us为争用期的长度。</li><li>对于10mb/s以太网，在争用期内可发送512bit，即64字节。</li><li>以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突。</li></ul><p><strong>最短有效帧长</strong>：</p><ul><li>如果发生冲突，就一定是在发送的前64字节之内。</li><li>由于一检测到冲突就立即终止发送，这时已经发送出去的数据一定小于64字节。</li><li>以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。</li></ul><h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟一个随机时间才能在发送数据。<br>确定基本退避时间，一般为争用期γ。<br>定义参数k<br>k = min[重传次数，10]<br>从整数集合[0,1…(2的k次方-1)]中随机地抽取一个数，记为r。重传所需的时延就是r倍的基本退避时间。<br>当重传达16次仍不能成功时即丢弃该帧，并向高层报告。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层基本概念及简单模型</title>
    <link href="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据链路层基本概念及简单模型"><a href="#数据链路层基本概念及简单模型" class="headerlink" title="数据链路层基本概念及简单模型"></a>数据链路层基本概念及简单模型</h1><p>数据链路层的简单模型:</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>数据链路层使用的信道主要有两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂，广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3 id="链路-link"><a href="#链路-link" class="headerlink" title="链路(link)"></a>链路(link)</h3><ul><li>一条点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分</li></ul><h3 id="数据链路-data-link"><a href="#数据链路-data-link" class="headerlink" title="数据链路(data link)"></a>数据链路(data link)</h3><p>除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路，现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层这两层的功能</p><blockquote><p>帧：数据，帧头，帧尾，物理层地址 校验值<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/3.png" srcset="/img/loading.gif" width="350px" height="200px"></p></blockquote><h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限，首部和尾部的一个重要作用就是进行帧定界。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/4.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输，如果传输的数据是ascii码中95个字符集时，一切正常，若传输的数据出现了EOT，被接收端误认为EOT前是一个帧，后面的当作无效帧丢弃。</p><h4 id="字节填充发解决透明传输的问题"><a href="#字节填充发解决透明传输的问题" class="headerlink" title="字节填充发解决透明传输的问题"></a>字节填充发解决透明传输的问题</h4><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转移字符“ESC”(16进制编码是1b).<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/5.png" srcset="/img/loading.gif" width="350px" height="200px"><br>字节填充或字符填充：接收端的数据链路层在将数据送往网络层之前删除插入的转义字符,如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。<br>当接受端收到连续的两个转义字符时，就删除其中前面的一个。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>传输过程中可能会产生比特差错，在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER，误码率与信噪比 有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测错数。常用循环冗余检验，在数据后面添加冗余码称为帧检验序列FCS(Frame Check Sequence).<br>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码.<br>FCS可以用CRC方法得出，但CRC并非用来获得FCS的唯一方法.</p><h2 id="使用点对点信道的数据链路层-广域网"><a href="#使用点对点信道的数据链路层-广域网" class="headerlink" title="使用点对点信道的数据链路层(广域网)"></a>使用点对点信道的数据链路层(广域网)</h2><p>1992年制定了ppp(Point-to-Point Protocol)协议，经过1993年和1994年的修订，现在的ppp协议已经成为因特网的正是标准,ppp协议有三个组成部分:</p><ul><li>数据链路层协议可以用于异步串行或同步串行介质</li><li>它使用LCP(链路控制协议)建立并维护数据链路连接</li><li>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/6.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>现在全世界使用最多的数据链路层协议是点对点协议ppp,用户使用拨号电话线接入因特网时，一般都是使用ppp协议.如图所示</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/7.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>ppp协议应该满足的要求:</p><ul><li>简单—首要要求</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul><p>ppp协议不需要满足的要求:</p><ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul><p>ppp协议帧格式</p><ul><li>标志字段F = 0x7E</li><li>地址字段A只置为0xFF 地址字段实际并不起作用</li><li>控制字段C通常置为0x03</li><li>ppp是面向字节的，所有的ppp帧长度都是整数字节</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/8.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><ul><li>将信息字段中出现的每个0x7E字节转变称为2字节序列0x7D 0x5E</li><li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列0x7D 0x5D</li><li>若信息字段出现ascii码的控制字符，则在该字符前面加入一个0x7D，同时将该字符的编码加以改变</li></ul><h3 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h3><p>ppp协议用在SONET/SDH链路时，是使用同步传输(一连串比特连续发送)。这时ppp协议采用零比特填充方法来实现透明传输。<br>在发送端，只要发现有5个连续1，则立即填入一个0(零比特填充法).接收端对帧中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后的一个0删除。</p><h3 id="ppp协议不使用序号和确认机制的原因"><a href="#ppp协议不使用序号和确认机制的原因" class="headerlink" title="ppp协议不使用序号和确认机制的原因"></a>ppp协议不使用序号和确认机制的原因</h3><ul><li>在数据链路层出现差错的概率不大时，使用比较简单的ppp协议较为合理。</li><li>在因特网环境下，ppp的信息字段放入的数据是ip数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列FCS字段可保证无差错接受。</li></ul><h3 id="ppp协议工作状态"><a href="#ppp协议工作状态" class="headerlink" title="ppp协议工作状态"></a>ppp协议工作状态</h3><ol><li>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接</li><li>PC机向路由器发送一系列的LCP分组(封装成多个ppp帧)。<br>这些分组及其响应选择一些ppp参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。</li><li>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址，接着，LCP释放数据链路层连接，最后释放的时物理层的连接。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字传输系统与宽带接入技术</title>
    <link href="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h1><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路的电话。由于历史原因，PCM有两个互不兼容的国际标准，即<strong>北美的24路PCM(简称为T1)</strong>和<strong>欧洲的30路PCM(简称为E1)</strong>，我国采用的是欧洲的E1标准。<br>E1的速率是2.048mb/s，而T1的速率是1.544Mb/s。<br>当需要有更高的数据率时，可采用复用的方法。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>将用户的声波进行8000次采样，然后统计规整每个码元得到二进制代码。<br>E1电路(时分复用)<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>T1电路<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)<br>例如</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>标准模拟电话信号的频带被限制在300-3400hz范围内，但用户线本身实际可通过的信号频率仍然超过1Mhz。<br>xDSL技术就是把0-4Khz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h2><p>DMT调制技术采用频分复用的方法，将40kHZ以上一直到1.1MHz的高端频谱划分成许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道。<br>每个子信道占据4Khz带宽，并使用不同的载波(即不同的音调)进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p><p>频谱分布<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="光纤同轴混合网HFC-Hybrid-Fiber-Coax"><a href="#光纤同轴混合网HFC-Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网HFC(Hybrid Fiber Coax)"></a>光纤同轴混合网HFC(Hybrid Fiber Coax)</h2><p>HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除了可传送CATV外还提供电话，数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输，而HFC网则需要对CATV网进行改造。每个用户要安装一个用户接口盒。<br>优点 ： 具有很宽的频带，能够利用已有相当大的覆盖面的有线电视网</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h2><p>FTTx(光纤到…)也是一种实现宽带居民接入网的方案。<br>光纤到家FTTH(Fiber To The Home):光纤一直铺设到用户家庭可能是居民接入网最后的解决办法(155Mb/s).<br>光纤到大楼FTTB(Fiber To The Building): 光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br>光纤到路边FTTC(Fiber To The Curb): 从路边到各用户可使用星型结构双绞线作为传输媒体(155mb/s)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输媒体与信道复用技术</title>
    <link href="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><h2 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h2><ul><li>双绞线<ul><li>屏蔽双绞线STP</li><li>无屏蔽双绞线UTP</li></ul></li><li>同轴电缆<ul><li><strong>50Ω同轴电缆</strong>用于数字传输，由于多用于基带传输，也叫基带同轴电缆。</li><li><strong>75Ω同轴电缆</strong>用于模拟传输，即宽带同轴电缆。</li></ul></li><li>光缆<ul><li>光缆是一定数量的光纤按照一定方式组成缆心，外包有护套，有的还包覆外护层，用以实现光信号传输的一种通信线路。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><blockquote><p>导向传输媒体中，电磁波沿着固体媒体传播。</p><h2 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h2><p>非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。<br>无线传输使用的频段很广，例如以下两种：</p></blockquote><ul><li>短波通信主要靠电离层的反射，但短波通信的通信质量较差。</li><li>微波在空间主要是直线传播，例如地面微波接力通信，卫星通信。</li></ul><h3 id="电信领域使用的电磁波的频谱"><a href="#电信领域使用的电磁波的频谱" class="headerlink" title="电信领域使用的电磁波的频谱"></a>电信领域使用的电磁波的频谱</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><h3 id="网线"><a href="#网线" class="headerlink" title="网线"></a>网线</h3><ul><li>直通线<ul><li>主机到交换机或集线器<ul><li>路由器到交换机或集线器</li></ul></li></ul></li><li>交叉电缆<ul><li>交换机到交换机</li><li>集线器到集线器</li><li>主机到主机</li><li>集线器到交换机</li><li>路由器直连到主机</li></ul></li></ul><h4 id="线序制作方法"><a href="#线序制作方法" class="headerlink" title="线序制作方法"></a>线序制作方法</h4><ul><li>直通线：双绞线夹线顺序两边一致，1.橙白、2.橙、3.绿白、4.蓝、5.蓝白、6.绿、7.棕白、8.棕，两端都是同样的线序且一一对应，即568B标准，也就是正线或标准线、直通线。</li><li>交叉电缆: 1、2号线与3、6号线交叉传送，也就是568A标准。<blockquote><p>568A: 绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</p></blockquote></li></ul><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>单模光纤，只能传输一种电磁波模式，光纤细，传播特性好，有线电视网络中使用的都是单模光纤，带宽可达10GHZ，可以在一根光纤中传输60套PAL—D电视节目。</li><li>多模光纤，只可以传输多个电磁波模式，光纤粗。</li></ul><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>工作特点：它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。<br>最大传输距离： 100m</p><blockquote><p>集线器是一个大的冲突域。</p></blockquote><hr><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h3 id="基础模型图"><a href="#基础模型图" class="headerlink" title="基础模型图"></a>基础模型图</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>频分复用FDM(Frequency Division Multiplexing),用户分配到一定的频带后，在通信过程中始终占用这个频带。频带复用的所有用户在同样的时间占用不同的带宽资源(这里带宽指频率带宽不是数据发送速率)。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="300px" height="150px"></p><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>时分复用TDM(Time Division Multiplexing),将时间划分为一段段等长的时分复用帧(TDM)帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性出现的(周期就是TDM帧的长度对应的时间)。<br>TDM信号也称为等时信号，时分复用的所有用户是在不同的时间占用相同的频带宽度。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>统计时分复用STDM(Statistic TDM)，由于时分复用可能造成线路资源浪费，使用时分复用系统传输计算机数据时，由于计算机数据突发性，用户对分配的子信道利用率一般不高，所以用统计时分复用去解决，也就是给每一个用户的信息加标记去区分用户的信息。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用WDM(Wavalength Division Multiplexing)，波分复用也就是光的频分复用。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/10.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信道的基本概念</title>
    <link href="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="信道简介"><a href="#信道简介" class="headerlink" title="信道简介"></a>信道简介</h2><p>信道一般表示向一个方向传送信息的媒体。所以通信线路往往包含一条发送信息的信号和一条接收信息的信道</p><ul><li>单向通信(单工通信)，只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信，通信的双方都可以发送信息，但不能同时发送和接受信息</li><li>双向同时通信，通信的双方可以同时发送和接受信息</li></ul><h2 id="基带信号和带通信号"><a href="#基带信号和带通信号" class="headerlink" title="基带信号和带通信号"></a>基带信号和带通信号</h2><ul><li>基带信号(baseband，即基本频带信号)，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如说话的声波就是基带信号。</li><li>带通信号(bandpass)，把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段，以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li></ul><p>因此在传输距离较近时，计算机网络采用基带传输方式，因为近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p><h3 id="几种最基本的调制方法"><a href="#几种最基本的调制方法" class="headerlink" title="几种最基本的调制方法"></a>几种最基本的调制方法</h3><ul><li>调幅(AM): 载波的振幅随基带数字信号而变化。</li><li>调频(FM): 载波的频率随基带数字信号而变化。</li><li>调相(PM): 载波的初始相位随基带数字信号而变化。</li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>单极性不归零码<ul><li>只使用一个电压值，用高电平表示1，没电压表示0.</li></ul></li><li>双极性不归零码<ul><li>用正电平和负电平分别表示二进制数据的1和0，正负幅值相等。</li></ul></li><li>单极性归零码<ul><li>以高电平和零电平分别表示二进制码1和0，而且在发送吗1时高电平在整个码元期间T只持续一段时间γ，其余时间返回零电平</li></ul></li><li>双极性归零码<ul><li>正负零三个电平，信号本身携带同步信息。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>曼彻斯特编码<ul><li>位中间有信号时，低电位变高电位为0，高电位变低电位为1。</li><li>采用这种编码，一个时钟周期只可表示一个位，并且必须通过两次采样才能得到一个位的值，但它能携带时钟信号，且可表示没有数据传输。</li></ul></li><li>差分曼彻斯特编码<ul><li>bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0.bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1.</li><li>差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性强于曼彻斯特编码。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>发送的信号波形通过实际的信道时会受到带宽、噪音、干扰等影响而失真，如果失真较小依旧可以识别并且纠正，如果失真较大则无法识别。</p><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>1924年，Nyquist推导出著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的识别成为不可能。<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>Shannon用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。<br>信道的极限信息传输速率C可以表示为<br>C = W log2(1+S/N) b/s log以2为底</p><ul><li>W为信道的带宽(单位hz)</li><li>S为信道内所传信号的平均功率</li><li>N为信道内部的高斯噪声功率</li></ul><blockquote><ul><li>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li><li>若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率C也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香浓的极限传输速率低不少。<h3 id="奈氏准则和香农公式的应用范围"><a href="#奈氏准则和香农公式的应用范围" class="headerlink" title="奈氏准则和香农公式的应用范围"></a>奈氏准则和香农公式的应用范围</h3>奈氏准则表示没有信号干扰，码元的传输速率有上限。<br>香浓公式表示有信号干扰，无差错传输速率的理论极限。<br><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.png" srcset="/img/loading.gif" width="300px" height="150px"></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层概念与数据通信基础</title>
    <link href="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。<br>物理层的主要任务描述为： 确定传输媒体的接口的一些特性即：</p><ul><li>机械特性：例接口形状，大小，引线数目</li><li>电气特性：例规定电压范围（-5v，+5v）</li><li>功能特性：例规定-5v表示0，+5v表示1</li><li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>链接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>数据通信领域中，数字信道所能传送的最高数据率，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>即在单位时间内通过某个网络的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li>发送时延 = 数据块长度(bit)/信道带宽(bit/s) 信号波完全传播完</li><li>传播时延 传播的过程所用时间</li><li>处理时延 收到信号波后处理时间</li><li>排队时延 多个信号排队等待时间</li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 = 传播时延 * 带宽 （传播时线路上有多少bit）</p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>从发送方发送数据开始，到发送方收到接收方确认</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul><li>信道利用率 = 有数据通过时间/有无数据通过时间</li><li>网络利用率 = 信道利用率加权平均值<br>D = D0 / （1-U） D0:网络空闲时的时延，D:网络当前时延，U: 信道利用率</li></ul><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基本模型"><a href="#数据通信基本模型" class="headerlink" title="数据通信基本模型"></a>数据通信基本模型</h3><p><img src="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/1.png" srcset="/img/loading.gif" width="350px" height="150px"></p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>数据(data)— 运送消息的实体</li><li>信号(signal)—数据的电气或电磁的表现</li><li>“模拟信号”—代表消息的参数的取值是连续的。</li><li>“数字信号”—代表消息的参数的取值是离散的。</li><li>码元(code)—在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度，1码元可以携带nbit的信息量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高斯约旦消元法</title>
    <link href="/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/"/>
    <url>/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h1><p>矩阵更准确的说是对线性系统的描述，所谓的线性系统指的是例如3x + 4y + z = 8之类的线性方程组，未知数只能是一次方项。而非线性方程则例如sin(x) = Π等坐标图上呈曲线的方程组。</p><h2 id="消元法解线性方程"><a href="#消元法解线性方程" class="headerlink" title="消元法解线性方程"></a>消元法解线性方程</h2><p>在小学初中我们学过如何用消元法解线性方程组，例如x + y = 2；2x + 3y = 12；的线性方程组，我们可以用第二个方程减去二倍的第一个方程，然后便可以消去x，得到y的值，然后将y带入第一个方程，我们便可以得到x与y的值，即线性方程组的解。</p><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>学习矩阵的概念之后，我们可以将方程组的系数拿下来组成系数矩阵，然后基于矩阵的操作去得到线性方程组的解，例如x + y + z = 6；2x + y + z = 7；x + y + 2z = 9;将其系数拿下来之后，我们可以得到矩阵<br>1 1 1<br>2 1 1<br>1 1 2<br>将方程组的结果也拿下来可以得到该矩阵的增广矩阵<br>1 1 1 | 6<br>2 1 1 | 7<br>1 1 2 | 9<br>经过第二行减二倍的第一行后，我们可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>1 1 2 | 9<br>然后用第三行减去第一行，可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>0 0 1 | 3<br>将第二行乘以-1，可以得到最终的矩阵<br>1 1 1 | 6<br>0 1 1 | 5<br>0 0 1 | 3<br>此矩阵最后一行的1则代表z的值，通过回代，便可得到x与y的值。通过观察，我们可以发现结果矩阵的对角线元素都为1，而矩阵的下一行总比上一行多一个0，我们将每一行的第一个1称为此行的主元，我们把第i-1行根据第i行的主元进而不断消去一个未知数的方法称为高斯消元法。</p><h2 id="高斯约旦消元法"><a href="#高斯约旦消元法" class="headerlink" title="高斯约旦消元法"></a>高斯约旦消元法</h2><p>通过以上的消元,最终我们只能得到最后一个未知数的值，上述矩阵，可以写成以下方程组<br>x + y + z =6;<br>y + z = 5;<br>z = 3;<br>通过回代的方式，可以得到x，y，z的值，但还是有一些麻烦。针对此矩阵，我们还可以在进行变换，将第二行减去第三行可得<br>1 1 1 | 6<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第三行可得<br>1 1 0 | 3<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第二行可得<br>1 0 0 | 1<br>0 1 0 | 2<br>0 0 1 | 3<br>进行这样的变换后，便可以直观的看出x，y，z的值，而坐标的系数矩阵则化成了单位矩阵，这种向下消元然后向上消元的方法被称为高斯约旦法。主要分为两个过程：</p><h3 id="前向过程-从上到下"><a href="#前向过程-从上到下" class="headerlink" title="前向过程(从上到下)"></a>前向过程(从上到下)</h3><ol><li>选择最上的主元，化为1</li><li>主元下面的所有行减去主元所在行的某个倍数，使得主元下面所有元素都为0</li></ol><h3 id="后向过程-从下到上"><a href="#后向过程-从下到上" class="headerlink" title="后向过程(从下到上)"></a>后向过程(从下到上)</h3><ol><li>选择最下的主元</li><li>主元上面的所有行减去主元所在行的某个倍数，使得主元上面所有元素都为0</li></ol><h3 id="python代码演示"><a href="#python代码演示" class="headerlink" title="python代码演示"></a>python代码演示</h3><pre><code>from .Matrix import Matrixfrom .Vector import Vectorclass LinearSystem:    def __init__(self,A,b):        assert A.row_num() == len(b),&quot;row number of A must be equal to the length&quot;        self._m = A.row_num()        self._n = A.col_num()        assert self._m == self._n # TODO: no this restriction        self.Ab = [Vector(A.row_vector(i).underlying_list()+[b[i]])                   for i in range(self._m)]    def _max_row(self,index,n):        best,ret = self.Ab[index][index],index        for i in range(index + 1,n):            if self.Ab[i][index] &lt; best:                best,ret = self.Ab[i][index],i        return ret    def _forward(self):        n = self._m        for i in range(n):            # Ab[i][i]为主元            max_row = self._max_row(i,n)            self.Ab[i],self.Ab[max_row] = self.Ab[max_row],self.Ab[i]            # 将主元归一            self.Ab[i] = self.Ab[i] / self.Ab[i][i] #TODO: self.Ab[i][i] == 0            for j in range(i+1,n):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def _backward(self):        n = self._m        for i in range(n-1,-1,-1):            for j in range(i-1,-1,-1):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def gauss_jordan_elimination(self):        self._forward()        self._backward()    def fancy_print(self):        for i in range(self._m):            print(&quot; &quot;.join(str(self.Ab[i][j]) for j in range(self._n)),end=&quot; &quot;)            print(&quot;|&quot;,self.Ab[i][-1])</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code>from playLA.Matrix import Matrixfrom playLA.Vector import Vectorfrom playLA.LinearSystem import LinearSystemif __name__ == &quot;__main__&quot;:    A = Matrix([[1,1,1],[2,1,1],[1,1,2]])    b = Vector([6,7,9])    Ab = LinearSystem(A,b)    Ab.gauss_jordan_elimination()    Ab.fancy_print()</code></pre><h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h3><p>课程名称: 专给程序员设计的线性代数<br>作者: bobo老师 —ACM亚洲区奖牌获得者</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础与OSI参考模型</title>
    <link href="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="局域网与广域网"><a href="#局域网与广域网" class="headerlink" title="局域网与广域网"></a>局域网与广域网</h2><h3 id="局域网："><a href="#局域网：" class="headerlink" title="局域网："></a><strong>局域网</strong>：</h3><p>局域网是一种私有网络，一般在一座建筑物内或建筑物附近，比如家庭、办公室或工厂。局域网络被广泛用来连接个人计算机和消费类电子设备，使它们能够共享资源和交换信息。当局域网被用于公司时，它们就称为企业网络。</p><blockquote><p>特点：覆盖范围小，设备自己购买，带宽固定，自己维护。</p></blockquote><h3 id="广域网："><a href="#广域网：" class="headerlink" title="广域网："></a><strong>广域网</strong>：</h3><p>在一个区域范围里超过集线器所连接的距离时，必须要通过路由器来连接，这种网上类型称为广域网。如果有北、中、南等分公司，甚至海外分公司，把这些分公司以专线方式连接起来，即称为“广域网”，广域网由各大运行商进行维护和建设，覆盖范围广，给用户提供服务。</p><blockquote><p>解释：ISP(Internet Service Provider)：互联网服务提供商。每个运行商都有自家的机房，各互联网公司通过租用运行商机房里的服务器，搭建自己的公司网站，所以电信网络访问在电信机房的网站就会快很多。为了避免因服务器所属不同产生的网络访问慢的问题，也有了双线机房的诞生，即多个运行商共有一个机房。</p></blockquote><h3 id="Internet："><a href="#Internet：" class="headerlink" title="Internet："></a><strong>Internet</strong>：</h3><p>internet表示的意思是互联网，又称网际网路，根据音译也被叫做因特网(Internet)、英特网，是网络与网络之间所串连成的庞大网络。这些网络以一组通用的协议相连，形成逻辑上的单一且巨大的全球化网络，在这个网络中有交换机、路由器等网络设备、各种不同的连接链路、种类繁多的服务器和数不尽的计算机、终端。</p><blockquote><p>中国互联网由电信，移动，联通，网通等等运行商组成，用户可以通过各地运行商提供的接口进而访问到全国互联网，并且各运行商提供与国外互联网的接口，进而访问全球互联网.</p></blockquote><h2 id="互联网如何进行数据的传输？"><a href="#互联网如何进行数据的传输？" class="headerlink" title="互联网如何进行数据的传输？"></a>互联网如何进行数据的传输？</h2><h3 id="数据帧与数据包"><a href="#数据帧与数据包" class="headerlink" title="数据帧与数据包"></a>数据帧与数据包</h3><p>每个网络都有属于自己的ip地址，每台设备也有唯一的Mac地址。当用户访问网站时，需要将域名传输给DNS，然后DNS返回相应的IP地址，然后将数据和本机IP地址以及目标IP地址进行打包(数据包)，为了将数据包通过路由器进行传输，还需要将当前mac地址以及下一个路由器的mac地址同样打包进去(数据帧),通过不断改变mac地址，进而将数据传输给服务器。</p><blockquote><p>DNS:域名解析服务器</p></blockquote><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><ul><li>应用层 所有能产生网络流量的程序</li><li>表示层 在传输之前是否进行加密或压缩处理，二进制或ASCII表示</li><li>会话层 浏览器与网站服务器建立会话，确保服务器传输来的信息渲染相对的页面 可以通过对话查木马 netstat -n</li><li>传输层 可靠传输 流量控制 不可靠传输(不需要建立会话，一个数据包便可完成交流)</li><li>网络层 负责选择最佳路径，规划IP地址</li><li>数据链路层 帧的开始和结束如何定义 透明传输 差错校验</li><li>物理层 接口标准(网线) 电器标准 如何在物理链路上传输更快的速度</li></ul><h3 id="OSI参考模型对网络排错指导"><a href="#OSI参考模型对网络排错指导" class="headerlink" title="OSI参考模型对网络排错指导"></a>OSI参考模型对网络排错指导</h3><ol><li>物理层故障 查看连接状态 发送和接受数据包</li><li>数据链路层故障 MAC冲突 ADSL欠费 网速没办法协商一致 计算机连接到错误的VLAN</li><li>网络层故障 配置错误的IP地址 子网掩码 配置错误的网关 路由器没有配置到达目标网络的路由</li><li>应用层故障 应用程序配置错误</li></ol><h3 id="OSI参考模型和网络安全"><a href="#OSI参考模型和网络安全" class="headerlink" title="OSI参考模型和网络安全"></a>OSI参考模型和网络安全</h3><ol><li>物理层安全</li><li>数据链路层安全 ADSL账号密码 VLAN交换机端口绑定MAC地址</li><li>网络层安全 在路由器上使用ACL控制数据包流量</li><li>应用层安全 开发的应用程序没有漏洞</li></ol><h3 id="OSI参考模型与TCP-IP"><a href="#OSI参考模型与TCP-IP" class="headerlink" title="OSI参考模型与TCP_IP"></a>OSI参考模型与TCP_IP</h3><p><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/1.png" srcset="/img/loading.gif" width="300px" height="150px"></p><p><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubantu配置django开发环境</title>
    <link href="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><ol><li>Ubantu镜像</li><li>Python3</li><li>pip3</li><li>pymysql</li><li>Django2.2</li><li>Mysql数据库</li><li>virtualenv虚拟环境</li></ol><h3 id="在VirtualBox上安装Ubantu操作系统"><a href="#在VirtualBox上安装Ubantu操作系统" class="headerlink" title="在VirtualBox上安装Ubantu操作系统"></a>在VirtualBox上安装Ubantu操作系统</h3><p>新建虚拟机，选择类型linux,选择版本ubantu64-bit，分配内存4gb，选择创建虚拟硬盘，配置好之后，在设置里，设置显存大小128m，启动3d加速.<br><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2.png" srcset="/img/loading.gif" width="400px" height="250px"><br>应用设置，并启动系统，再开始界面选择需要导入的ios镜像，进入ubantu安装界面，并完成安装指导，建议自己分区。<br>ubantu系统内已配置python3，所以只需要安装后续软件即可。<br>进入系统后打开terminal，首先输入dpkg -l 查看已安装软件，是否有python，如果有则不需要再安装python。</p><h3 id="安装pip3"><a href="#安装pip3" class="headerlink" title="安装pip3"></a>安装pip3</h3><pre><code>sudo apt-get update        //更新软件源sudo apt-get install python3-pip  pip3 --version  //查看版本sudo pip3 list //查看已安装的lib</code></pre><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><pre><code>sudo apt-get install mysql-server mysql-clientsudo service mysql restartmysql -uroot -p        //进入mysql命令界面</code></pre><p><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/3.png" srcset="/img/loading.gif" width="400px" height="250px"></p><h3 id="安装pymysql"><a href="#安装pymysql" class="headerlink" title="安装pymysql"></a>安装pymysql</h3><pre><code>pip3 install pymysql</code></pre><h3 id="安装virtualenv与virtualenvwrapper"><a href="#安装virtualenv与virtualenvwrapper" class="headerlink" title="安装virtualenv与virtualenvwrapper"></a>安装virtualenv与virtualenvwrapper</h3><pre><code>sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper</code></pre><p>安装好virtualenvwrapper后还无法使用，创建目录存放虚拟环境</p><pre><code>mkdir $HOME/.virtualenvs</code></pre><p>在~/.bashrc中添加</p><pre><code>export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh</code></pre><p>运行</p><pre><code>source ~/.bashrc</code></pre><p>创建python3虚拟环境</p><pre><code>mkvirtualenv -p 路径 /usr/bin/pythonX删除:rmvirtualenv 虚拟环境名称进入: workon 虚拟环境名称</code></pre><p>其他命令</p><pre><code>python -v  //进度python命令终端deactivate //退出虚拟环境pip freeze 查看虚拟环境安装的包</code></pre><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><pre><code>pip install Django==1.11.7django-admin startproject xxx 创建项目python manage.py startapp xxx 创建一个应用</code></pre><p>执行 python manage.py runserver 访问localhost:8000,看到it works则项目启动成功！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>英语短语整理</title>
    <link href="/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/"/>
    <url>/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="英语短语整理"><a href="#英语短语整理" class="headerlink" title="英语短语整理"></a>英语短语整理</h2><hr><h3 id="1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan"><a href="#1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan" class="headerlink" title="1.Queen Agrees to Period of Transition for Harry and Meghan."></a>1.Queen Agrees to Period of Transition for Harry and Meghan.</h3><ul><li>forge a new life 创造新生活</li><li>period of transistion 过渡期</li><li>following a day of … 什么事情之后的一天</li><li>thrown … into turmoil 引起骚乱</li><li>Britain’s monarchy 英国君主制</li><li>dominated the headlines for days 占据头条</li><li>remote prospect 机会渺茫</li><li>carve out 创造雕刻</li><li>back away from 躲开</li><li>in the coming days 在未来几天</li><li>make clear that 明确表示</li><li>be reliant on 依赖</li><li>on the lookout 注意，留心</li><li>cash in 从中牟利，捞到好处</li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冯诺依曼体系</title>
    <link href="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/"/>
    <url>/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-SunBeGFk" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="477417503" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="冯诺依曼简介"><a href="#冯诺依曼简介" class="headerlink" title="冯诺依曼简介"></a>冯诺依曼简介</h2><p>约翰·冯·诺依曼，美籍匈牙利数学家、计算机科学家、物理学家，毕业于苏黎世联邦工业大学，他是现代电子计算机与博弈论的重要创始人，被后人称为现代计算机之父、博弈论之父，并且他还改善了著名的蒙特卡洛算法。<br>1945年6月约翰·冯·诺依曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”。在报告中冯·诺伊曼明确提出了计算机的体系架构。从1951年第一台电子计算机EDVAC开始，计算机经历了多次的更新换代，不管是最原始的、还是最先进的计算机，使用的仍然是冯·诺依曼最初设计的计算机体系结构。因此冯·诺依曼被世界公认为“计算机之父”，他设计的计算机系统结构，称为“冯诺依曼体系结构”。</p><h2 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h2><p>冯诺依曼体系结构主要由五大部分组成，分别是控制器，运算器，存储器，输入设备和输出设备。至今为止，基本上所有的计算机也是遵循冯诺依曼体系所设计的，例如我们经常使用的手机，电脑，平板等等。<br>冯诺依曼提出的两个重要的思想，一个是存储程序的思想，另一个是二进制的思想，这两个思想在如今的计算机领域影响深远。<br>世界上第一台计算机EDVAC，采用了上千个电子管所设计的，体积十分庞大，设计者采用十进制对指令和数据进行计算处理，但执行过程复杂，运行效率慢。十进制与二进制的区别在哪？冯诺依曼为何提出二进制的存储思想呢？因为在早期的计算机电子元件设计中，通常使用高低电压来表示信息，即高电压为1，低电压为0.所以如果要采用十进制进行数据的计算，将二进制信息转换成我们日常所熟悉的十进制后再去进行处理，大大增加了计算机指令的设计难度，而使用二进制则解决了这一问题，后世很多科学家也提出了二进制浮点数的计算，以及反码补码阶码的概念，使二进制成为了计算机设计的中心。所以在今后的计算机中无论是指令还是数据都采用二进制的方式进行存储和计算。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/1.jpg" srcset="/img/loading.gif" width="375px" height="220px"><br>通常我们使用的计算机主要功能是负责运算，所以在冯诺依曼体系中以运算器为中心，而存储器负责存放指令和数据，指令和数据的计算和存储以及外部设备的连接也需要通过控制器进行控制。让我们排除输入输出设备之后，其实运算器，存储器和控制器才是整个计算机的核心，我们可以将三者看作一个黑箱子。当我们输入数据时，数据通过黑箱子，然后输出我们想要的结果，这便是图灵机的简单模型。</p><h2 id="冯诺依曼体系的特点"><a href="#冯诺依曼体系的特点" class="headerlink" title="冯诺依曼体系的特点"></a>冯诺依曼体系的特点</h2><ol><li>计算机由五大部件组成，运算器，存储器，控制器，输入设备，输出设备。</li><li>指令和数据采用二进制方式进行存储。</li><li>指令由地址码和操作码组成。</li><li>运算器为中心。</li><li>存储程序为主要思想。</li><li>指令和数据都以同等地位存入存储器，并且可按地址访问。</li></ol><h2 id="冯诺依曼体系结构的改进"><a href="#冯诺依曼体系结构的改进" class="headerlink" title="冯诺依曼体系结构的改进"></a>冯诺依曼体系结构的改进</h2><p>如上图所示，输入设备如果需要从存储器中存储信息，必须经过运算器，因此运算器可能成为计算机速度的瓶颈，如果可以使输入设备不经过运算器，直接访问存储器，可以减少运算器的工作量，因此有了以下以存储器为中心的结构。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/2.png" srcset="/img/loading.gif" width="375px" height="220px"></p><p>由于现代计算机分为运算器，控制器，存储器，输入设备，输出设备。运算器(ALU)与控制器(CU)合并为CPU，存储器分为主存与辅存，CPU与存储器构成主机部分，主机与IO设备构成计算机硬件，可以根据计算机的层次进行设计。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/3.png" srcset="/img/loading.gif" width="375px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心情随笔</title>
    <link href="/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-DRWbBPhR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1352045760" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近越来越喜欢写博客了，感觉就是自己向自己倾诉一样，或许这也是一些感情的寄托吧。自从参加了两次数学建模比赛，也发现自己的写作能力开始慢慢变强了，同时也明白了为什么有一些人喜欢写日记，因为这也是记录自己点点滴滴的一种方式吧，能让自己感觉到存在的意义。<br>自从大学以后感觉更加孤独了，学技术是寂寞的，枯燥的，只有做出一些作品，才会带给自己很多真实的成就感。这种感觉很奇妙，能让自己感觉到充实，感觉自己是活着的，感觉自己的人生是有意义的。</p><h2 id="倾诉"><a href="#倾诉" class="headerlink" title="倾诉"></a>倾诉</h2><p>最近学校放寒假了，也回家了。回家后避免不了受到父母的各种唠叨，以及亲戚朋友各种“友善”的人生建议，感觉活着越来越累了，想要变的优越一些，但又克服不了那些臭毛病，想要脱单，但心里没有什么喜欢的人，也没人喜欢，自卑在心底已经生根发芽了，最终想想罢了，还是回归现实吧。<br>回家后听到亲戚朋友闲聊，听说别人家的孩子现在创办了公司，一年盈利几百万。听说别人家的孩子最近考上了研究生，毕业以后也不用担心了。听说别人家的孩子，今年高考考进了名牌大学。听说别人家的孩子最近又出国了。听说别人家的孩子……<br>而自己呢？<br>越来越焦虑了，其实我只想当一个普通人罢了，但现在普通人的标准貌似也越来越高了，学习计算机对于父母而言，只不过是整日坐在电脑旁边虚度光阴罢了。挣扎着想要反驳一些什么，想想觉得还是算了，只会让自己更累。</p><blockquote><p>二十而立，三十不惑，四十知天命，如今自己刚过二十岁年纪，却感觉心里已经更老了十岁，人生就是这样，得过且过，顺其自然吧</p></blockquote><hr><p>抱怨就到这里，谈谈未来的人生规划和目标。</p><hr><ol><li>努力学习，考研计算机方向</li><li>毕业后好好工作，乐观生活</li><li>有一套属于自己的小房子</li><li>养一只猫</li><li>吃好喝好</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研的想法</title>
    <link href="/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇博客只是阐述以下我最近的想法，估计大部分人也不会看我的博客。如果有人不幸看到了的话，可以给我一些建议，谢谢。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>由于高考失利，加上地区政策高考改革等，高考失败后没有复读，而是去选择上三本学校（虽然现在已经没三本了），然后选择了计算机科学专业，因为我本身也是比较喜欢编程的，开学后就开始自学编程语言，做一些小程序。</p><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>刚开始我并没有考研的想法，只想着努力学技术，毕业后靠技术吃饭，我一直认为IT这个行业跟学历的关系并不大，只要你的技术强硬，一些大厂总有机会进去，工资也会很高。于是我就去学安卓，学网站等等，自学了不少东西，也做过一些demo。但由于只学专业课，我数学英语都不怎么好，四级也没过，只有专业课还凑合。</p><h2 id="考研想法的由来"><a href="#考研想法的由来" class="headerlink" title="考研想法的由来"></a>考研想法的由来</h2><p>目前大二上学期已经结束了，前一段时间跟我的专业课老师交流，他跟我聊他以前做的很多项目，那些项目都需要用一些复杂的算法去实现，还需要对计算机的深入理解，都是一些偏底层的东西，比如有关卫星，燃气，有色金属等等的项目。<br>然后我问他关于毕业工作的问题，需要学习多少技术，毕业后需不需要再去培训。<br>他给我分析了目前社会上的一些培训班，他们培训的东西都是一些java的电商项目，web前端等等，连微服务都涉及不到，至于培训python与人工智能的，大部分也是涉及较浅，用处不大。而且这些新技术、新框架过时的也很快。这些东西完全可以自学没必要报培训班。<br>建议我如果深入学计算机，想未来爬的高一点，还是需要考研的。</p><h2 id="如何考研？"><a href="#如何考研？" class="headerlink" title="如何考研？"></a>如何考研？</h2><p>在此之后我考研的念头就萌发了，这些天我一直在想一个问题，作为一个好歹算是科班出身的毕业生，我并不想学了四年结果毕业后和培训班一年出来的人一样的水准，甚至还不如。所以我毅然决定考研，如今遇到以下问题。</p><ul><li>1.三本学生如何选择考研学校？</li><li>2.基础薄弱怎么规划自己的学习?</li><li>3.现阶段应该怎么准备？</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>由于我也是比较现实的人，对自己的能力有所认知，所以我并不打算去考一些985，211名校，但也希望尽量上一个cs专业强一点的普通一本并争一争211学校的名额。<br>希望学长学姐以及有过考研经验的人可以给我一些帮助和建议，谢谢！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵转换</title>
    <link href="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵转换"><a href="#矩阵转换" class="headerlink" title="矩阵转换"></a>矩阵转换</h2><p>矩阵可以看作是一个向量的函数，则矩阵可以表示变换。<br>假设有以下向量(x,y),如何让该向量每个点横坐标扩大a倍，纵坐标扩大b倍，根据矩阵的点乘性质，则可以推出<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz1.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>假设矩阵还可以表示一个图形，那么如何将图形关于x轴翻转，也可以通过点乘另一个矩阵进行转换。例如<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz2.png" srcset="/img/loading.gif" width="400px" height="100px"><br>由此也可以推广出更多的转换。</p><hr><p>关于y轴的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz3.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>关于原点的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz4.png" srcset="/img/loading.gif" width="400px" height="100px"><br>沿x方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz5.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>沿y方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz6.png" srcset="/img/loading.gif" width="400px" height="100px"><br>关于原点进行旋转sitar角度<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz7.png" srcset="/img/loading.gif" width="400px" height="100px"></p><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>如果一个矩阵点乘另一个矩阵，矩阵的每一个元素没有发生任何变化，则称这种矩阵为单位矩阵。<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz8.png" srcset="/img/loading.gif" width="250px" height="130px"></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>单位矩阵的主对角线全为1.</li><li>单位矩阵一定是方阵.</li><li>假设单位矩阵为I，另一个矩阵为A，则I · A = A，A · I = A</li></ul><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在数字系统中，除了0之外，X * 1/X = 1.<br>那么在矩阵中，设矩阵A，B。如果A · B = B · A = I，则称B为A的逆矩阵，记作B = 1/A.</p><h3 id="性质与推广"><a href="#性质与推广" class="headerlink" title="性质与推广"></a>性质与推广</h3><ul><li>在矩阵系统中，有一些矩阵并没有逆矩阵。如果矩阵A存在逆矩阵，则称A为可逆矩阵，或者叫非奇异矩阵(non-singular)，相反如果矩阵不可逆，则称为不可逆矩阵，或者奇异矩阵(singular)。</li><li>如果存在矩阵A，B，C，B·A = I，则称B是A的左逆矩阵。如果A·C = I，则称C是A的右逆矩阵。</li><li>如果一个矩阵A既存在左逆矩阵B，又存在右逆矩阵C，则B=C。</li><li>对于矩阵A,如果存在逆矩阵B，则B唯一。</li><li>可逆矩阵一定为方阵，非方阵一定不可逆。</li><li>A的0次方 = I，A的-1次方为A的逆。</li><li>矩阵的逆的转置等于矩阵的转置的逆。</li><li><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz9.png" srcset="/img/loading.gif" width="250px" height="130px"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于javaSwing数据绑定及刷新</title>
    <link href="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/"/>
    <url>/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近学校期末了，正在进行java实训，实训要做一个图书管理系统。对于实现mysql数据库数据在JTable上的绑定，以及数据更新后界面的刷新时，遇到了问题。由于我对于JavaSwing完全不了解 ，实训时也是现学现卖，所以不清楚如何将数据绑定到JTable上。看了很多CSDN的博客，最后采用了以下方法。</p><h3 id="关于数据绑定的实现"><a href="#关于数据绑定的实现" class="headerlink" title="关于数据绑定的实现"></a>关于数据绑定的实现</h3><p>首先创建针对数据的模型类,以下的模型类是基于自定义Book表的简单示范</p><pre><code>/*book_list*/public class book_list extends javax.swing.table.DefaultTableModel{Class[] types = new Class[] { java.lang.Object.class, java.lang.String.class,            java.lang.String.class}; public book_list() {        super(new Object[][] {}, new String[] { &quot;bookname&quot;, &quot;booktype&quot;});}}</code></pre><p>然后对数据表进行填充，创建book对象，读取数据库中的数据后进行对象的赋值。利用循环将所有数据存入List中，而后利用循环从List中依次取得对象，并将各属性存入boo_list创建的对象中。然后创建JTable实体用model进行填充。这样可以将数据库的信息转换成可以填充JTable的对象。从而完成数据绑定的操作。</p><pre><code>    //图书表的创建    public static book_list model2 = new book_list();    public static JTable table2 = new JTable(model2);    ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;();    try {        sqlBookcod sql = new sqlBookcod();        ResultSet rs = sql.searchBook();        while (rs.next()) {            Book book = new Book();            book.setName(rs.getString(&quot;bookname&quot;));            book.setBookType(rs.getString(&quot;booktype&quot;));            list.add(book);        }    }catch(SQLException e) {        e.printStackTrace();    }    for (int i = 0; i &lt; list.size(); i++) {        Book b = (Book) list.get(i);        model2.addRow(new Object[] {b.getName(),b.getBookType()});    }}</code></pre><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>当时进行数据绑定后，直接将table添加到panel中，当数据更新后，table中的数据已经被定死了。所以我采用了简单粗暴的方法，通过监听菜单栏的点击事件，直接删除table中的所有数据，然后重新进行填充，并删除panel中的table控件，重新添加table，从而实现数据表的更新。</p><pre><code>//图书表清空数据public static void delmodel2() {    model2 = new book_list();    table2 = new JTable(model2);}public void stateChanged(ChangeEvent e) {                    if(tabbedPane.getSelectedIndex() == 0) {        panel1.remove(p1);                    //删除panel1中原有的组件            tablepan.delmodel1();                //删除数据表内容                            p1 = tablepan.createTextPanel1();    //重新填充数据表        panel1.add(p1);        panel1.repaint();                     //对panel1本身进行重绘    }}</code></pre><hr><h3 id="界面如下"><a href="#界面如下" class="headerlink" title="界面如下"></a>界面如下</h3><p><img src="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/wz1.png" srcset="/img/loading.gif" width="400px" height="250px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019个人总结</title>
    <link href="/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2019总结与反省"><a href="#2019总结与反省" class="headerlink" title="2019总结与反省"></a>2019总结与反省</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>当初带着坚定学习的决心，来到了大学校园，或许很多人并不清楚自己的目标是什么，我也一样。 我曾经不止一次问过自己，我为什么要学习计算机。 到最后也没有一个合适的理由说服自己，大概因为我什么也不会，除了带着点对计算机的兴趣与热爱之外，我不清楚自己还爱好着什么，也不知道自己将来要面对什么，也正如大多数人一样，只是为了生活去奋斗罢了。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>当初想着靠学技术到毕业工作，也努力学习了很多新技术，不再只会用c/c++敲黑窗口程序。图形界面程序从windowSdk到mfc又到winform，从winform到pythonGUI再到javaSwing。期间接触了很多编程语言，数据库技术，还有web前端技术以及一些网络的知识，服务器知识等。也了解过几种框架，入门过游戏引擎，做出了一些努力，但也曾有一段时间沉迷游戏，荒废时间。</p><h2 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h2><p>数学英语等课程依旧是这么差，技术水平增长缓慢也令我焦虑。当初只想搞技术的我，为其花费了大量的时间，导致我英语跟数学等科目没有跟上进度，现在悔悟基础课是多么重要。<br>当初坚定不打算考研的我，也在今年慢慢动摇，并决定考研一战。<br>感觉2019有收获也有后悔，自己所做出的努力在别人眼中或许根本不算努力，但总之没有自甘堕落，还有着目标和执行力。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="经历"><a href="#经历" class="headerlink" title="经历:"></a>经历:</h3><ul><li>年初参加蓝桥杯编程比赛拿到省三等奖。</li><li>肝封印者达到450w战力后弃坑。</li><li>假期学习unity做过几个小demo。</li><li>参加数学建模校赛，拿到三等奖，并得到333元奖金。</li><li>在学校创办兼职，写过python脚本程序处理excel。</li><li>担任学校计算机协会团支书并且给大一学生讲课。</li><li>买了服务器，但只玩了聊天室。</li><li>举办社团活动给学校师生修电脑。</li><li>学习Linux。</li><li>入坑古剑奇谭并且版本毕业。</li><li>看完了几本小说。</li><li>思考人生ing。</li><li>参加全国大学生数学建模比赛，拿到省一等奖。</li><li>入坑Django，重新复习前端。</li><li>莫名其妙进了学校实验班。</li><li>个人博客坏了一次，所有的文章丢失，又重新搭了博客网站并用了现在的主题。</li></ul><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><ul><li>依旧单身，没什么想法！</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是普普通通的一年，回想起来也没发生什么大事。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>学习英语数学以及计算机基础课，决定考研。</li><li>撰写博客同步发布到个人网站方便总结和复习。</li><li>勤写博客，勤刷题，每天坚持记英语单词。</li><li>继续进行基础知识的学习和练习。</li><li>深入学习框架并尝试进行项目实战。</li><li>稳住急躁的情绪，稳扎稳打。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵学习1</title>
    <link href="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/"/>
    <url>/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>向量是对数的拓展，一个向量表示一组数。<br>而矩阵是对向量的拓展，一个矩阵表示一组向量。<br>行数与列数相等的矩阵称为方阵。<br>一个矩阵可以拆分为n个行向量或者n个列向量，称矩阵为N x N矩阵。<br>矩阵可以表示成一个系统，例如在经济系统中，对于IT，电子，矿产，房产的投入，<br>可以表示成多个方程组，而方程组的系数则可用矩阵表示。</p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>行变成列，列变成行。</p><h3 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h3><p><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x1.png" srcset="/img/loading.gif" width="200px" height="80px"></p><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>每一个对应元素相加得到新矩阵</p><h3 id="矩阵的数量乘法"><a href="#矩阵的数量乘法" class="headerlink" title="矩阵的数量乘法"></a>矩阵的数量乘法</h3><p>标量去乘矩阵的每一个元素得到新矩阵</p><h3 id="矩阵的基本运算性质"><a href="#矩阵的基本运算性质" class="headerlink" title="矩阵的基本运算性质"></a>矩阵的基本运算性质</h3><p>A + B = B + A<br>(A + B) + C = A + (B + C)<br>存在矩阵O，满足：A + O = A<br>存在矩阵-A,满足：A + (-A) = O<br>-A 唯一, -A = -1 * A<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x2.png" srcset="/img/loading.gif" width="250px" height="70px"></p><h3 id="矩阵和向量的乘法"><a href="#矩阵和向量的乘法" class="headerlink" title="矩阵和向量的乘法"></a>矩阵和向量的乘法</h3><p>矩阵的列数必须和向量的元素个数一致。<br>矩阵与向量点乘，实际上将向量a转换成了向量b，所以矩阵可以理解为向量的函数。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x4.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵和矩阵的乘法"><a href="#矩阵和矩阵的乘法" class="headerlink" title="矩阵和矩阵的乘法"></a>矩阵和矩阵的乘法</h3><p>矩阵A和矩阵B的每一个列向量相乘，要求矩阵A的列数必须和矩阵B的行数一致。<br>矩阵的乘法不遵守交换律。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x5.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x6.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p>只有方阵才有矩阵的幂。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x7.png" srcset="/img/loading.gif" width="350px" height="100px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线代个人理解</title>
    <link href="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线性代数是从从研究一个数，到研究一组数的数学。<br>一组数的基本表示方法为向量，而向量也是线性代数研究的基本元素。<br>向量可以在多个维度表示一个Object的基本属性，方便我们数学的研究。<br>向量一般分为行向量与列向量，但在通常的教材和论文中，向量一般默认指列向量。<br>ps ： 由于印刷问题，列向量可以表示为(num1,num2)T。</p><h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><h3 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h3><p>如果两个向量(num1,num2) + (num3,num4),那么得到的结果为(num1+num3,num2+num4)。<br>向量的加法可以表示为在n维坐标中，继续增加n维度的单位。<br>例如(5,2)T + (2,5)T.<br>表示先在x维度上增加5个单位，在y维度上增加2个单位。再在x维度上增加2个单位，再在y维度上增加5个单位。那么在x维度总共有7个单位，在y维度总共也有7个单位，进而得到的向量的结果为(7,7).<br>它可以表示object在两个维度上的信息。</p><h3 id="向量的数量乘法"><a href="#向量的数量乘法" class="headerlink" title="向量的数量乘法"></a>向量的数量乘法</h3><p>简单来说乘法只是加法的推广和延申，那么向量的乘法同样也表示在n维度的坐标中，重复增加n维度个单位。</p><h3 id="向量运算的基本性质"><a href="#向量运算的基本性质" class="headerlink" title="向量运算的基本性质"></a>向量运算的基本性质</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/xl.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h3><p>二范数的概念：表示向量每个维度的平方相加再开二次方。例如勾股定理<br>那么向量的长度实际上就是求向量的二范数,也可以叫做求向量的模</p><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><p>单位向量是指这个向量去乘这个向量的模分之一，也就是保持向量的长度为1.所以单位向量的模永远为1，它只表示方向。<br>根据向量u求出单位向量u1的过程，也被称为是归一化，规范化(normalize)。<br>二维空间中，有两个特殊的单位向量 e1 = (1,0),e2 = (0,1)。<br>只由0，1组成的单位向量叫做，标准为单位向量(Standard Unit Vector)。<br>n维空间有n个标准为单位向量。</p><h3 id="两个向量相乘"><a href="#两个向量相乘" class="headerlink" title="两个向量相乘"></a>两个向量相乘</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/x2.png" srcset="/img/loading.gif" width="700px" height="150px"><br>两个向量相乘，结果为一个标量，这个标量代表两个向量的模相乘，再乘向量夹角的Cos值。这种乘法更严格的来说是两个向量的点乘，或者两个向量的内积。<br>向量的点乘也可以看作只有一行元素的矩阵与向量相乘。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
