<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h1><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构研究数据之间的内在关系，合理组织数据，设计高效的算法，用于解决数学问题。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p><h2 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h2><ul><li>数据，如数学计算中用到的整数和实数，文本编辑中用到的字符串，以及经过特殊编码定义后的数据</li><li>数据元素，是数据的基本单位，数据元素用于完整的描述一个对象</li><li>数据项，是组成数据元素的、有独立含义的、不可分割的最小单位。</li><li>数据对象，是性质相同的数据元素的集合，是数据的子集。</li></ul><h2 id="数据的逻辑结构和存储结构"><a href="#数据的逻辑结构和存储结构" class="headerlink" title="数据的逻辑结构和存储结构"></a>数据的逻辑结构和存储结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>集合结构，数据元素之间除了”属于同一集合”的关系外，别无其他关系。</li><li>线性结构，数据元素之间存在一对一的关系。</li><li>树结构，数据元素之间存在一对多的关系。</li><li>图结构或网状结构，数据元素之间存在多对多的关系。</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储结构，特点是数据存放在连续的内存空间内，可以直接对某个元素进行访问。</li><li>链式存储结构，特点是数据存放在不连续的内存空间，无需占用一整块存储空间，但需要对每一个结点附加指针用于存放后继结点的地址，无法直接对某一个元素进行访问。</li></ul><h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是高级程序设计语言中的一个基本概念，编程语言中规定好的，例如int,float,double,boolean,long,char等。<br>数据类型是一个值得集合和定义在这个值集上得一组操作的总称。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象就是抽取出实际问题的本质，抽象数据类型(Abstract Data Type,ADT)一般指由用户定于的、表示应用问题的数学模型，以及这个模型的操作总称。<br>抽象数据类型的概念与面向对象方法的思想是一致的。</p><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><h3 id="算法的定义及特性"><a href="#算法的定义及特性" class="headerlink" title="算法的定义及特性"></a>算法的定义及特性</h3><ul><li>有穷性，算法必须在一定时间内能执行完。</li><li>确定性，算法应不会产生二义性，对于每种情况，应该有确切的操作。</li><li>可行性，算法的所有操作应该可以基于基本操作并且在有限时间内完成。</li><li>输入，算法有零个或多个输入。</li><li>输出，算法有零个或多个输出。</li></ul><h3 id="评价算法优劣的基本标准"><a href="#评价算法优劣的基本标准" class="headerlink" title="评价算法优劣的基本标准"></a>评价算法优劣的基本标准</h3><ul><li>正确性，在合理的数据输入下，当数据规模足够大时，都能在有限的时间内得到正确的结果。</li><li>可读性，好的算法，应该便于人们理解和相互交流。</li><li>健壮性，当输入的数据非法时，好的算法能适当地做出正确反应或者相应地处理。</li><li>高效性，高效性包括时间和空间两个方面，时间复杂度与空间复杂度。</li></ul><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>衡量算法效率的方法主要分为：</p><ul><li>事后统计法，先将算法实现，然后测算其时间和空间开销。</li><li>事前分析法，通常采用事前分析估算法，计算复杂度衡量算法的效率。</li></ul><p>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。<br>一条语句的重复执行次数称为<strong>语句频度</strong>。</p><h3 id="时间复杂度的定义"><a href="#时间复杂度的定义" class="headerlink" title="时间复杂度的定义"></a>时间复杂度的定义</h3><p>算法代码举例</p><pre><code>for(i=1;i&lt;=n;i++)                            //频度为n+1    for(j=1;j&lt;=n;j++){                        //频度为n*(n+1)            c[i][j]=0;                            //频度为n^2        for(k=1;k&lt;=n;k++)                    //频度为n^2 * (n+1)        c[i][j]= c[i][j]+a[i][j]*b[i][j];    //频度为n^3    }</code></pre><p>该算法中所有语句频度之和，是矩阵阶数n的函数，用f(n)表示。</p><script type="math/tex;mode=display">f(n)=2n^3+3n^2+2n+1</script><p>对于相对简单的算法，可以直接计算算法所有语句的频度。当问题规模变大时，我们只需要考虑问题规模充分大时，算法中基本语句执行次数在渐近意义下的阶。</p><script type="math/tex;mode=display">\lim\limits_{x\rightarrow\infty}f(n)/n^3=\lim\limits_{x\rightarrow\infty}(2n^3+3n^2+2n+1)/n^3=2</script><p>当n充分大时，$f(n)$和$n^3$是同阶的，即数量级相同，用”O”表示数量级，记作$T(n)=O(f(n))=O(n^3)$。<br>一般来说，算法中基本语句重复执行的次数是问题规模n的某个函数$f(n)$,算法的时间量度记作$T(n)=O(f(n))$,它表示随问题规模n的增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的渐近时间复杂度。</p><blockquote><p>数学符号”O”的严格定义为：<br>若$T(n)$和$f(n)$是定义在正整数集合上的两个函数，则$T(n)=O(f(n))$表示存在正的常数C和$n_0$,使得当$n\geq n_0$时都满足$0\leq T(n)\leq C_f(n)$.</p></blockquote><h3 id="算法时间复杂度分析举例"><a href="#算法时间复杂度分析举例" class="headerlink" title="算法时间复杂度分析举例"></a>算法时间复杂度分析举例</h3><p>基本方法: 找出所有语句中语句频度最大的语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数$f(n)$,取其数量级用符号”O”表示。<br>定理：<script type="math/tex">f(n)=a_mn^m+a_{m-1}n^{m-1}+\ldots+a_1n+a_0</script>是一个m次多项式，则$T(n)=O(n^m)$.</p><h4 id="常量阶示例"><a href="#常量阶示例" class="headerlink" title="常量阶示例"></a>常量阶示例</h4><pre><code>{x++;s=0;}</code></pre><p>两条语句频度都为1，算法时间复杂度为$T(n)=O(1)$.</p><h4 id="线性阶示例"><a href="#线性阶示例" class="headerlink" title="线性阶示例"></a>线性阶示例</h4><pre><code>for(i=0;i&lt;n;i++){x++;s=0}</code></pre><p>循环体内两条基本语句频度均为$f(n)=n$,所以算法时间复杂度为$T(n)=O(n)$</p><h4 id="平方阶示例"><a href="#平方阶示例" class="headerlink" title="平方阶示例"></a>平方阶示例</h4><pre><code>x=0;y=0;for(k=1;k&lt;=n;k++)    x++;for(i=1;i&lt;=n;i++)    for(j=1;j&lt;=n;j++)        y++;</code></pre><p>循环语句只需考虑循环体中语句的执行次数，其频度为$f(n)=n^2$,所以该算法的时间复杂度为$T(n)=O(n^2)$,称为平方阶。<br>多数条件下，若干个循环语句时，算法的时间复杂度由最深层循环内基本语句频度决定。</p><h4 id="立方阶示例"><a href="#立方阶示例" class="headerlink" title="立方阶示例"></a>立方阶示例</h4><pre><code>x=1;for(x=1;i&lt;=n;i++)    for(j=1;j&lt;=i;j++)        for(k=1;k&lt;=k;k++)            x++;</code></pre><script type="math/tex;mode=display">\displaystyle \sum^{n}_{i=1} \displaystyle \sum^{i}_{i=1} \displaystyle \sum^{j}_{i=1}1=\displaystyle \sum^{n}_{i=1} \displaystyle \sum^{i}_{i=1}j=\displaystyle \sum^{n}_{i=1}i(i+1)/2=[n(n+1)(2n+1)/6+n(n+1)/2]/2</script><p>该算法时间复杂度为$T(n)=O(n^3)$,称为立方阶。</p><h4 id="对数阶示例"><a href="#对数阶示例" class="headerlink" title="对数阶示例"></a>对数阶示例</h4><pre><code>for(i=1;i&lt;=n;i=i*2){x++;s=0;}</code></pre><p>设循环体内两条基本语句的频度为$f(n)$,则有$2^{f(n)}\leq n$,$f(n)\geq \log_2 n$,算法时间复杂度为$T(n)=O(log_2 n)$.</p><h3 id="时间复杂度性能"><a href="#时间复杂度性能" class="headerlink" title="时间复杂度性能"></a>时间复杂度性能</h3><p>最好时间复杂度： 算法计算量可能达到的最小值<br>最坏时间复杂度： 算法计算量可能达到的最大值<br>平均时间复杂度： 算法计算量的加权平均值</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>输入数据所占的具体存储量取决于问题本身，与算法无关。空间复杂度只需要分析该算法在实现时所需的辅助空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache与辅助存储器</title>
    <link href="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Cache与辅助存储器"><a href="#Cache与辅助存储器" class="headerlink" title="Cache与辅助存储器"></a>Cache与辅助存储器</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><h3 id="为什么使用Cache？"><a href="#为什么使用Cache？" class="headerlink" title="为什么使用Cache？"></a>为什么使用Cache？</h3><ul><li>避免CPU”空等”现象</li><li>CPU和主存(DRAM)的速度差异<br><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/1.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>程序访问的局部性原理</li></ul><h2 id="Cache的工作原理"><a href="#Cache的工作原理" class="headerlink" title="Cache的工作原理"></a>Cache的工作原理</h2><h3 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/2.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存和缓存按块存储，块的大小相同，B为块长。缓存的块远远小于主存的块，如果主存要和Cache映射，那么至少要保证主存中每块大小应与Cache中每块大小相同。<br>每个字块包含N个字，主存的地址应该分成两部分，一部分用来寻找某个字块，另一部分用来寻找该字块中的字或字节。</p><h3 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h3><p>缓存共有C块，主存共有M块，M&gt;&gt;C.</p><ul><li>命中: 主存块调入缓存，主存块与缓存块 建立了对应关系。</li><li>未命中: 主存块未调入缓存，主存块与缓存块未建立对应关系。</li></ul><blockquote><p>用标记记录与某缓存块建立了对应关系的主存块号。</p></blockquote><h4 id="Cache的命中率"><a href="#Cache的命中率" class="headerlink" title="Cache的命中率"></a>Cache的命中率</h4><p>CPU欲访问的信息在Cache中的比率，命中率与Cache的容量与块长有关，一般每块可取4-8个字。<br>块长取一个存取周期内从主存调出的信息长度。</p><blockquote><ul><li>CRAY_1,16体交叉，块长取16个存储字。</li><li>IBM370/168，4体交叉，块长取4个存储字，一个存储字64位，一次取256位。</li></ul></blockquote><h3 id="Cache-主存系统的效率"><a href="#Cache-主存系统的效率" class="headerlink" title="Cache-主存系统的效率"></a>Cache-主存系统的效率</h3><p>效率e与命中率有关，e=访问Cache的时间/平均访问时间 <em>100%。<br>设Cache命中率为h，访问Cache的时间为tc，访问主存的时间为tm，则e=tc/h</em>tc+(1-h)<em>tm</em>100%.</p><h3 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ul><li>写直达法(Write-through)<br>写操作时数据既写入Cache，又写入主存。<br>写操作时间就是访问主存的时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现。</li><li>写回法(Write-back)<br>写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存。<br>写操作时间就是访问Cache的时间，Cache块退出时，被替换的块需写回主存 ，增加了Cache的复杂性。</li></ul><h3 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h3><ol><li>增加Cache的级数，如片载(片内)Cache,片外Cache。</li><li>统一缓存和分立缓存，冯诺依曼结构将指令Cache和数据Cache统一整合，现在计算机可以将指令Cache与数据Cache分开，这个方式与指令执行的控制方式有关。</li><li>Pentium，8K指令Cache，8K数据Cache。</li><li>PowerPC620，32K指令Cache，32K数据Cache。</li></ol><h2 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h2><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/5.png" srcset="/img/loading.gif" width="350px" height="230px"><br>每个缓存块i可以和若干个主存块对应<br>每个主存块i只能和一个缓存块对应</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/6.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存中的任一块可以映射到缓存中的任一块</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>某一主存块j按模Q映射到缓存的第i组中的任一块，当组相联只有一组时，此时组相联映射等同于全相联映射，当每组只有一块时，此时组相联映射等同于直接映射。</p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><ol><li>先进先出(FIFO)算法</li><li>近期最少使用(LRU)算法</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>直接，某一主存块只能固定映射到某一缓存块</li><li>全相联，某一主存块能映射到任一缓存块</li><li>组相联，某一主存块只能映射到某一缓存组中的任一块</li></ul><h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>特点，不直接与CPU交换信息</li><li>磁表面存储器的技术指标<ul><li>记录密度，道密度Dt，位密度Db</li><li>存储容量，C=n<em>k</em>s</li><li>平均寻址时间，寻道时间+等待时间<ul><li>辅存的速度<ul><li>寻址时间</li><li>磁头读写时间</li></ul></li></ul></li><li>数据传输率，Dr=Db*V</li><li>误码率，出错信息位数与读出信息的总位数之比。</li></ul></li></ol><h3 id="磁记录原理和记录方式"><a href="#磁记录原理和记录方式" class="headerlink" title="磁记录原理和记录方式"></a>磁记录原理和记录方式</h3><h4 id="磁记录写原理"><a href="#磁记录写原理" class="headerlink" title="磁记录写原理"></a>磁记录写原理</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="磁记录读原理"><a href="#磁记录读原理" class="headerlink" title="磁记录读原理"></a>磁记录读原理</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h3><h4 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h4><ol><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ol><h4 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ol><li>磁盘驱动器<br><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/11.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>磁盘控制器<ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令</li><li>实现主机和驱动器之间的数据格式转换</li><li>控制磁盘驱动器读写</li><li>磁盘控制器是主机和磁盘驱动器之间的接口<ul><li>对主机，通过总线</li><li>对硬盘(设备)</li></ul></li></ul></li><li>盘片<br>由硬质铝合金材料制成</li></ol><h3 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="软盘片"><a href="#软盘片" class="headerlink" title="软盘片"></a>软盘片</h4><p><img src="/2020/05/10/Cache%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>采用光存储技术，利用激光写入和读出</p><ul><li>第一代光存储技术，采用非磁性介质，不可擦写</li><li>第二代光存储技术，采用磁性介质，可擦写</li></ul><h4 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h4><p>只读型和只写一次型—热作用(物理或化学变化)<br>可擦写光盘—热磁效应</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主存储器之ROM</title>
    <link href="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/"/>
    <url>/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="主存储器之ROM"><a href="#主存储器之ROM" class="headerlink" title="主存储器之ROM"></a>主存储器之ROM</h1><h2 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h2><ul><li>早期的只读存储器—在厂家就写好了内容</li><li>改进1—用户可以自己写—一次性</li><li>改进2—可以多次写—要能对信息进行擦除</li><li>改进3—电可擦写—特定设备</li><li>改进4—电可擦写—直接连接到计算机上</li></ul><h3 id="掩膜ROM-MROM"><a href="#掩膜ROM-MROM" class="headerlink" title="掩膜ROM(MROM)"></a>掩膜ROM(MROM)</h3><p>MROM有芯片制造商在制造时写入内容，之后只能读不能写入，其基本存储原理是以元件的”有/无”来表示该存储单元的信息(“1”或”0”)。</p><ul><li>行列选择线交叉处有MOS管为”1”</li><li>行列选择线交叉处无MOS管为”0”<h3 id="PROM-一次性编程"><a href="#PROM-一次性编程" class="headerlink" title="PROM(一次性编程)"></a>PROM(一次性编程)</h3>使用熔丝存储数据，用户可根据自己的需要来对其填入内容，属于一次性写入的存储器。部分PROM在出厂时数据全为0，用户可以将其中的部分单元写入1，以实现对其”编程”的目的。</li></ul><p><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="EPROM-多次编程"><a href="#EPROM-多次编程" class="headerlink" title="EPROM(多次编程)"></a>EPROM(多次编程)</h3><p>使用悬浮栅存储数据，为了能多次修改ROM的内容，产生了EPROM，EPRM使用高压写入数据，当需要修改时，可使用紫外线将其全部内容擦除(不能局部擦除)。但是使用紫外线并不方便，因此产生了EEPROM.<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>D端加正电压，形成浮动栅，S与D不导通为”0”</li><li>D端不加正电压，不形成浮动栅，S与D导通为”1”</li></ul><h3 id="EEPROM-多次性编程"><a href="#EEPROM-多次性编程" class="headerlink" title="EEPROM(多次性编程)"></a>EEPROM(多次性编程)</h3><p>EEPROM与EPROM运作原理一样，不但写入数据使用高压，擦除数据也是用了高压。</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul><h3 id="Flash-Memory-闪速型存储器"><a href="#Flash-Memory-闪速型存储器" class="headerlink" title="Flash Memory(闪速型存储器)"></a>Flash Memory(闪速型存储器)</h3><p>闪存虽然属于内存的一种，但不同于内存。众所周知，如果没有电流供应，内存中的内容会消失，闪存在没有电流供应的情况下仍能长久的保持数据，其存储特性相当于硬盘，集合了ROM与RAM的长处。一般闪存按块读取数据。</p><h2 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h2><ol><li>位扩展(增加存储子长)<br>用2片1K<em>4位的存储芯片组成1K</em>8位的存储器，需要10根地址线，8根数据线。(2^10=1K)<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/3.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>字扩展(增加存储字的数量)<br>用2片1K<em>8位存储芯片组成2K</em>8位的存储器，需要11根地址线，8根数据线。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/4.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>字、位扩展<br>用8片1K<em>4位存储芯片组成4K</em>8位的存储器，需要12根地址线，8根数据线。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/5.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><ol><li>地址线的连接</li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li><li>其他(时序、负载)</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>假设同前，要求最小4K为系统程序区，相邻8K为用户程序区。</p><ol><li>写出对应二进制地址码</li><li>确定芯片的数量及类型<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/6.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>分配地址线<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/7.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>确定片选信号</li></ol><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><ul><li>合法代码集合</li></ul><ol><li>{000,001,010,011,100,101,110,111} 检0位错，纠0位错</li><li>{000,011,101,110}合法编码的特点，1的个数为偶数个，或0个，检1位，纠0位。</li><li>{000,111}合法编码为1的个数是3，检1位，纠1位。</li><li>{0000,1111}检2位，纠1位</li><li>{00000,11111}检2位，纠2位。</li></ol><blockquote><p>检测能力与任意两组合法代码之间二进制位的最少差异数有关。</p></blockquote><h3 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h3><p>任意两组合法代码之间二进制位数的最少差异、编码的纠错、检错能力与编码的最小距离有关。<br>L-1=D+C（D&gt;=C）<br>L: 编码的最小距离 L=3<br>D: 检测错误的位数，例：具有一位纠错能力<br>C: 纠正错误的位数</p><h3 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h3><ul><li>汉明码采用奇偶校验</li><li>汉明码采用分组校验</li><li>汉明码的分组是一种非划分方式<br>一组数据为1234567，分成3组，每组有一位校验位，共包括4位数据位，而汉明码的分组如下：<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/8.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><p>若第一组出错，其他两组没错，则出错位为1.若第三组与第一组出错，第二组没错，则出错位置为第三组与第一组公共位置为5，如果第三组与第二组出错，第一组没错，则出错位为6，将三组P3p2p1倒序排列出错的位置恰好为其二进制对应十进制的数据。</p><blockquote><p>奇偶校验：添加一位校验位，判断1的个数是奇数还是偶数，无法纠错。<br>如果将上述数据分组，然后分别添加校验码，可以得到两个校验码，因此可以纠2位。</p></blockquote><h4 id="汉明码分组"><a href="#汉明码分组" class="headerlink" title="汉明码分组"></a>汉明码分组</h4><p>第一组 XXXX1<br>第二组 XXX1X<br>第三组 XX1XX<br>第四组 X1XXX<br>第五组 1XXXX<br>相应1，2，4，8…位置放校验码。1，2，4，8是每一个部分独有的，如果数据的第1位与第3位为1，就是第一组与第三组所共有的数据，以此类推。</p><h4 id="组成汉明码的三要素"><a href="#组成汉明码的三要素" class="headerlink" title="组成汉明码的三要素"></a>组成汉明码的三要素</h4><ol><li>汉明码的组成需要增添？位检测位<br>2^K&gt;=n+k+1</li><li>检测位的位置？<br>2^i(i=0,1,2,3,…)</li><li>检测位的取值？<br>检测位的取值与该位所在的检测”小组”中承担的奇偶教研任务有关。</li></ol><h4 id="各检测位Ci所承担的检测小组为"><a href="#各检测位Ci所承担的检测小组为" class="headerlink" title="各检测位Ci所承担的检测小组为"></a>各检测位Ci所承担的检测小组为</h4><p><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>求0101按”偶校验”配置的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/10.png" srcset="/img/loading.gif" width="350px" height="230px">&lt;/img&gt;<br>按配偶原则配置0011的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="汉明码的纠错过程"><a href="#汉明码的纠错过程" class="headerlink" title="汉明码的纠错过程"></a>汉明码的纠错过程</h4><p>每一组形成新的检测位Pi，其位数与增添的检测位有关。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/12.png" srcset="/img/loading.gif" width="350px" height="230px">&lt;/img&gt;<br>已知接收到的汉明码为0100111(按配偶原则配置)试问要求传送的信息是什么？<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/13.png" srcset="/img/loading.gif" width="350px" height="230px"><br>写出按偶校验配置的汉明码<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h2 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h2><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构</li></ul><ol><li>单体多字系统，增加存储器的带宽<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/15.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>多体并行系统<ul><li>高位交叉，顺序编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/16.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>高位交叉，各个体并行工作<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/17.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>低位交叉，各个体轮流编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/18.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>低位交叉，各个体轮流编址<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/19.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul></li></ol><h3 id="低位交叉的特点"><a href="#低位交叉的特点" class="headerlink" title="低位交叉的特点"></a>低位交叉的特点</h3><p>在不改变存取周期的前提下，增加存储器的带宽<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/20.png" srcset="/img/loading.gif" width="350px" height="230px">&lt;/img&gt;<br>设四体低位交叉存储器，存取周期为T，总线传输周期为τ，为实现流水线方式存取，应满足T=4τ。<br><img src="/2020/05/09/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8BROM/21.png" srcset="/img/loading.gif" width="350px" height="230px"><br>连续读取4个字所需的时间为T+(4-1)τ.</p><h3 id="高性能存储芯片"><a href="#高性能存储芯片" class="headerlink" title="高性能存储芯片"></a>高性能存储芯片</h3><ol><li>SDRAM(同步DRAM)</li><li>RDRAM</li><li>带Cache的DRAM<br>在DRAM的芯片内集成了一个由SRAM组成的Cache，有利于猝发式读取。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器概述与RAM</title>
    <link href="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/"/>
    <url>/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><h3 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h3><ol><li>半导体存储器 TTL(集成度低，功耗高，速度快)、MOS(集成度高，功耗低)—易失</li><li>磁表面存储器 （磁头、磁载体）</li><li>磁芯存储器 硬磁材料、环状元件</li><li>光盘存储器 激光、磁光材料</li></ol><h3 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h3><ol><li>存取时间与物理地址无关(随机访问)<ul><li>随机存储器 在程序的执行过程中可读可写</li><li>只读存储器 在程序的执行过程中只读</li></ul></li><li>存取时间与物理地址有关(串行访问)<ul><li>顺序存取存储器 磁带</li><li>直接存取存储器 磁盘</li></ul></li></ol><h3 id="按在计算机中的作用分类"><a href="#按在计算机中的作用分类" class="headerlink" title="按在计算机中的作用分类"></a>按在计算机中的作用分类</h3><ul><li>主存储器<ul><li>RAM<ul><li>静态RAM</li><li>动态RAM</li></ul></li><li>ROM<ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>Flash Memory</li><li>高速缓冲存储器(Cache)</li><li>辅助存储器 磁盘、磁带、光盘</li></ul><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器三个主要特性的关系"><a href="#存储器三个主要特性的关系" class="headerlink" title="存储器三个主要特性的关系"></a>存储器三个主要特性的关系</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="缓存-主存层次和主存-辅存层次"><a href="#缓存-主存层次和主存-辅存层次" class="headerlink" title="缓存-主存层次和主存-辅存层次"></a>缓存-主存层次和主存-辅存层次</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/2.png" srcset="/img/loading.gif" width="350px" height="230px"><br>主存与辅存构成的空间，叫做虚拟存储器。我们定义了一个空间存储程序叫做虚地址也就是逻辑地址。</p><blockquote><p>程序的局部性原理：指程序在执行时，呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p></blockquote><h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/3.png" srcset="/img/loading.gif" width="350px" height="230px"><br>MAR保存了需要访问的存储单元的地址，经过译码器选择实际内存中相应的地址，由读写控制电路控制MDR内的内容写入和读出。</p><h3 id="主存和CPU的联系"><a href="#主存和CPU的联系" class="headerlink" title="主存和CPU的联系"></a>主存和CPU的联系</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>MAR是单向的，MDR是双向的</p><h3 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h3><p>12345678H这个数据如何在主存储器中进行存储？<br>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。<br>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p></blockquote><ul><li>设地址线24根 按字节寻址 2^24=16MB</li><li>若字长为16位 按字寻址 8MW (W是16位)</li><li>若字长为32位 按字寻址 4MW</li></ul><blockquote><p>存储子长：一次能读出或者写入的字长，若字长为16位，则一个字有两个字节，所以要留一根地址线指出该字中的哪个字节，即寻址范围是2^(24-1)=8M.</p></blockquote><h4 id="判断编译器的大小端模式"><a href="#判断编译器的大小端模式" class="headerlink" title="判断编译器的大小端模式"></a>判断编译器的大小端模式</h4><pre><code>short int x;char x0,x1;x=0x1122;x0=((char*)&amp;x)[0];    //低地质单元x1=((char*)&amp;x)[1];    //高地址单元</code></pre><p>若x0=0下1，则是大端，反之是小端。</p><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><ol><li>存储容量 主存存放二进制代码的总位数</li><li>存储速度<ul><li>存取时间 存储器的访问时间，读出时间和写入时间</li><li>存取周期 连续两次独立的存储器操作，读或写所需的最小间隔时间，读周期和写周期</li></ul></li><li>存储器的带宽 位/秒</li></ol><h2 id="半导体芯片简介"><a href="#半导体芯片简介" class="headerlink" title="半导体芯片简介"></a>半导体芯片简介</h2><h3 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>地址线(单向)，10|，14|，13</li><li>数据线(双向)，4|，1|，8</li><li><p>芯片容量，1K<em>4位|，16K</em>1位|，8K*8位</p></li><li><p>片选线 CS(低电平有效) CE(使能信号) (片选线是芯片选择信号，它指出了这次操作给出的地址是不是针对这个存储芯片的地址，被选择的存储单元和字节是不是在这个芯片当中)</p></li><li>读/写控制线 WE(低电平写，高电平读)</li><li>OE(允许读)，WE(允许写)</li></ul><h4 id="存储芯片片选线的作用"><a href="#存储芯片片选线的作用" class="headerlink" title="存储芯片片选线的作用"></a>存储芯片片选线的作用</h4><p>用(32片)16K<em>1位的存储芯片组成64K</em>8位的存储器<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>8个芯片一组构成8位输出，这样的芯片布置4组。0-16k-1为第一组</p><h3 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/8.png" srcset="/img/loading.gif" width="350px" height="230px"><br>可以看出这个芯片是16K*8位，线选法像个数列，重合法像二维数组。</p><h4 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h2 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h2><h3 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h3><h4 id="SRAM的基本电路"><a href="#SRAM的基本电路" class="headerlink" title="SRAM的基本电路"></a>SRAM的基本电路</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SRAM基本电路的读操作"><a href="#SRAM基本电路的读操作" class="headerlink" title="SRAM基本电路的读操作"></a>SRAM基本电路的读操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SRAM基本电路的写操作"><a href="#SRAM基本电路的写操作" class="headerlink" title="SRAM基本电路的写操作"></a>SRAM基本电路的写操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="静态RAM芯片举例"><a href="#静态RAM芯片举例" class="headerlink" title="静态RAM芯片举例"></a>静态RAM芯片举例</h3><p>Intel 2114外特性<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/13.png" srcset="/img/loading.gif" width="350px" height="230px"><br>A0-A9代表数据线，说明此芯片有1k存储容量，I/O1-4说明此芯片一次能读出或写入4位数据，CS代表片选信号，低电平选中此芯片，WE是读写信号。</p><h4 id="2114读操作"><a href="#2114读操作" class="headerlink" title="2114读操作"></a>2114读操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="2114写操作"><a href="#2114写操作" class="headerlink" title="2114写操作"></a>2114写操作</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h3><h4 id="动态RAM基本单元电路"><a href="#动态RAM基本单元电路" class="headerlink" title="动态RAM基本单元电路"></a>动态RAM基本单元电路</h4><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>读出与原存信息相反 读出时数据线有电流为“1”</li><li>写入与输入信息相同 写入时Cs充电为“1”放电为“0”</li></ul><h4 id="动态RAM芯片举例"><a href="#动态RAM芯片举例" class="headerlink" title="动态RAM芯片举例"></a>动态RAM芯片举例</h4><ol><li>三管动态RAM芯片(Intel 1103)读<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/17.png" srcset="/img/loading.gif" width="350px" height="230px"><br>假设给出的行地址为0，则第0行读选择线有效，第0行的所有单元被选中，列地址是5个0，第0列被选中，第0行与第0列交叉的单元电路被选中，这个单元通过读数据线将数据送到读写电路上，实现了读操作。</li><li>三管动态RAM芯片(Intel 1103)写<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/18.png" srcset="/img/loading.gif" width="350px" height="230px"><br>假设行地址译码器给的地址为5个1，则第31行被选中，第31行所有的单元电路准备写操作，假设给出的列地址为00001，第31行第一列的单元电路被选中。</li><li>单管动态RAM4116(16K*1位)外特性<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/19.png" srcset="/img/loading.gif" width="350px" height="230px"><br>这种动态RAM只有7根地址线，分两次传送。第一次将A0-A0传入行地址缓存器，第二次传入列地址缓存器，经过译码器负责选择单元电路。</li><li>4116读原理<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>若给出的行地址为0111111，则第63行有效，63行所有的晶体管都打开，电容当中保存的信息会送出到读放大器的左侧，以第一个晶体管为例，如果晶体管有电，则第一个读放大器的左侧就为1，右侧就为0，假设列地址为7个0，第0列被选中，第0列的列选信号有效，对应的晶体管打开，数据会从第0列的读放大器的右侧送入I/O缓冲。</li><li>4116写原理<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/21.png" srcset="/img/loading.gif" width="350px" height="230px"><br>行地址0111111，63行被选中，所有晶体管打开，数据被送到读写线上，第0列有效，第0列晶体管打开，通过第0列读放大器右端，通过左端写入电容。</li></ol><h4 id="动态RAM刷新"><a href="#动态RAM刷新" class="headerlink" title="动态RAM刷新"></a>动态RAM刷新</h4><p>电容容易漏电，所以必须需要对动态RAM进行刷新。</p><ol><li>集中刷新(存取周期为0.5us)以128<em>128矩阵为例，刷新与行地址有关<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/22.png" srcset="/img/loading.gif" width="350px" height="230px"><br>“死区”为 0.5us</em>128=64us<br>“死时间率”为 128/4000*100%=3.2%</li><li>分散刷新(存取周期为1us)以128*128矩阵为例<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/23.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>分散刷新与集中刷新结合(异步刷新)<br><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/24.png" srcset="/img/loading.gif" width="350px" height="230px"><br>对于128*128的存储芯片(存取周期为0.5us)，若每隔15.6us刷新一行<br>每行每隔2ms刷新一次，”死区”为0.5us<br>将刷新安排在指令译码阶段，不会出现”死区”</li></ol><h3 id="动态RAM与静态RAM的比较"><a href="#动态RAM与静态RAM的比较" class="headerlink" title="动态RAM与静态RAM的比较"></a>动态RAM与静态RAM的比较</h3><p><img src="/2020/04/30/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8ERAM/25.png" srcset="/img/loading.gif" width="350px" height="230px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定点运算</title>
    <link href="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/"/>
    <url>/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h3><p>在日常计算中将15.0小数点右移2位为1500.0，计算机中小数点位置固定不变。所以需要将数据相对小数点进行移位。<br>在计算机中，移位与加减配合，能够实现乘除运算。</p><ul><li>左移，绝对值扩大</li><li>右移，绝对值缩小<h3 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h3></li><li>正数：原码、补码、反码添补代码都为0</li><li>负数：<ul><li>原码，添补代码为0</li><li>补码，左移添0，右移添1</li><li>反码，添补代码为1</li></ul></li></ul><blockquote><p>符号位不变</p></blockquote><h3 id="算术移位举例"><a href="#算术移位举例" class="headerlink" title="算术移位举例"></a>算术移位举例</h3><ol><li><p>设机器数字长为8位(含1位符号位)，写出A=+26时，三种机器数左、右移移位和两位后的表示形式及对应的真值，并分析结果的正确性。<br>解： A=+26=+11010，则A的原码、补码、反码=0，0011010.<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/1.png" srcset="/img/loading.gif" width="350px" height="150px"></p></li><li><p>设机器数字长为8位(含1位符号位)，写出A=-26时，三种机器数左右移一位和两位后的表示形式及对应的真值，并分析结果的正确性。<br>解： A=-26=-11010<br>原码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/2.png" srcset="/img/loading.gif" width="350px" height="150px">&lt;/img&gt;<br>补码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/3.png" srcset="/img/loading.gif" width="350px" height="150px"><br>反码表示：<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/4.png" srcset="/img/loading.gif" width="350px" height="150px"></p></li></ol><h3 id="算数移位的硬件实现"><a href="#算数移位的硬件实现" class="headerlink" title="算数移位的硬件实现"></a>算数移位的硬件实现</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/5.png" srcset="/img/loading.gif" width="380px" height="230px"></p><h3 id="算术移位和逻辑移位的区别"><a href="#算术移位和逻辑移位的区别" class="headerlink" title="算术移位和逻辑移位的区别"></a>算术移位和逻辑移位的区别</h3><ul><li>算术移位 有符号数的移位</li><li>逻辑移位 无符号数的移位</li><li>逻辑左移 低位添0，高位移丢</li><li>逻辑右移 高位添0，低位移丢</li></ul><p>例： 01010011<br>逻辑左移： 10100110<br>算术左移： 00100110<br>例： 10110010<br>逻辑右移： 01011001<br>算术右移： 11011001 (补码)</p><blockquote><p>算术移位不会更改符号位，逻辑移位包括符号位全部移位。</p></blockquote><h2 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h2><h3 id="补码加减法运算公式"><a href="#补码加减法运算公式" class="headerlink" title="补码加减法运算公式"></a>补码加减法运算公式</h3><ul><li>加法<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/6.png" srcset="/img/loading.gif" width="300px" height="100px"></li><li>减法<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/7.png" srcset="/img/loading.gif" width="300px" height="100px"></li></ul><blockquote><p>连同符号位一起相加，符号位产生的进位自然丢掉。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>设A=0.1011，B=-0.0101，求[A + B]补<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/8.png" srcset="/img/loading.gif" width="300px" height="150px"></li><li>设A=-9，B=-5，求[A + B]补<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/9.png" srcset="/img/loading.gif" width="330px" height="150px"></li><li>设机器数字长为8位(含1位符号位)，且A=15，B=24，用补码求A-B<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/10.png" srcset="/img/loading.gif" width="330px" height="150px"></li><li>设x=9/16，y=11/16，用补码求x+y。<br>x+y=-0.1100=-12/16 （错）</li><li>设机器数字长为8位(含一位符号位)且A=-97，B=+41，用补码求A-B<br>A-B=+1110110=+118 （错）</li></ol><h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><h4 id="一位符号位判断溢出"><a href="#一位符号位判断溢出" class="headerlink" title="一位符号位判断溢出"></a>一位符号位判断溢出</h4><p>参加操作的两个数(减法时即为被减数和”求补”以后的减数)符号相同，其结果的符号与原操作数的符号不同，即为溢出。<br>硬件实现：<br>最高有效位的进位 ⊕ 符号位的进位=1，即为溢出<br>有溢出：</p><ul><li>1⊕0=1，0⊕1=1</li></ul><p>无溢出：</p><ul><li>0⊕0=0，1⊕1=0</li></ul><h4 id="两位符号位判断溢出"><a href="#两位符号位判断溢出" class="headerlink" title="两位符号位判断溢出"></a>两位符号位判断溢出</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>小数的补码可以以2^k为模，k代表符号位的位数。</p></blockquote><h4 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>A代表ACC，Ga与Gs是两个标记，如果是加法Ga置1，如果是减法Gs置1，求补控制逻辑判断X中如果是减法运算，则对X求补。</p></blockquote><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><h3 id="分析笔算乘法"><a href="#分析笔算乘法" class="headerlink" title="分析笔算乘法"></a>分析笔算乘法</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="笔算乘法改进"><a href="#笔算乘法改进" class="headerlink" title="笔算乘法改进"></a>笔算乘法改进</h3><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/14.png" srcset="/img/loading.gif" width="350px" height="230px"><br>初态部分积为0，然后需要分析乘数的数值部分1011，最后一位为1，则加0.1101，相加后将部分积与乘数右移一位，部分积结果是0.1101，分析乘数数值部分的末位，还是1，再将整体右移一位，部分积为0.0110，乘数为1101，然后相加0.1101，之后得到的结果1.0011，将乘数右移一位，分析数值的末位是0，则相加0.0000，然后得到的结果分析数值末位是1，将得到的结果右移一位，再相加0.1101，结果为1.0001，最后重复上述操作，结果为部分积与乘数之和，0.10001111.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>乘法运算可用加和移位实现，n=4，加4次，移4次</li><li>由乘数的末位决定被乘数是否与原部分积相加，然后-&gt;1位形成新的部分积，同时乘数-&gt;1位(末位移丢)，空出高位存放部分积的低位。</li><li>被乘数只与部分积的高位相加</li><li>硬件，3个寄存器，其中2个具有移位功能，1个全加器。</li></ul><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="原码一位乘运算规则"><a href="#原码一位乘运算规则" class="headerlink" title="原码一位乘运算规则"></a>原码一位乘运算规则</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="原码一位乘递推公式"><a href="#原码一位乘递推公式" class="headerlink" title="原码一位乘递推公式"></a>原码一位乘递推公式</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>已知x=-0.1110，y=0.1101，求[x.y]原。<br><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/17.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>乘积的符号位x0⊕y0=1⊕0=1</li><li>数值部分按绝对值相乘,x<em>.y</em>=0.10110110,则[x.y]原=1.10110110.</li><li>特点：绝对值运算，用移位的次数判断乘法是否结束，逻辑移位</li></ul><h4 id="原码一位乘的硬件配置"><a href="#原码一位乘的硬件配置" class="headerlink" title="原码一位乘的硬件配置"></a>原码一位乘的硬件配置</h4><p><img src="/2020/04/28/%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97/18.png" srcset="/img/loading.gif" width="350px" height="230px"><br>A、X、Q均n+1位，移位和加受末位乘数控制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的定点与浮点表示</title>
    <link href="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数的定点表示与浮点表示"><a href="#数的定点表示与浮点表示" class="headerlink" title="数的定点表示与浮点表示"></a>数的定点表示与浮点表示</h1><h2 id="为什么要引入浮点表示"><a href="#为什么要引入浮点表示" class="headerlink" title="为什么要引入浮点表示"></a>为什么要引入浮点表示</h2><ul><li>编程困难，程序员要调节小数点的位置</li><li>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长。<ul><li>例如：太阳的质量为0.2<em>10^34克，一个电子的质量大约为0.9</em>10^-27克，两者差距为10^61以上，若用定点数据表示：2^x&gt;10^61，解得x&gt;203位。</li></ul></li><li>数据存储单元的利用率往往很低。</li></ul><h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="浮点数的表示形式"><a href="#浮点数的表示形式" class="headerlink" title="浮点数的表示形式"></a>浮点数的表示形式</h3><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>Sf 代表浮点数的符号</li><li>n 其位数反映浮点数的精度</li><li>m 其位数反映浮点数的表示范围</li><li>jf和m 共同表示小数点的实际位置</li></ul><h3 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h3><p>上溢： 阶码&gt;最大阶码<br>下溢： 阶码&lt;最小解码，按机器零处理<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>设机器数字长为24位，欲表示±3万的十进制数，试问在保证数的最大精度的前提下，除阶符、数符各取1位以外，阶码、尾数各取几位？<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/4.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="浮点数的规格化形式"><a href="#浮点数的规格化形式" class="headerlink" title="浮点数的规格化形式"></a>浮点数的规格化形式</h3><ul><li>r=2，尾数最高位为1</li><li>r=4，尾数最高2位不全为0</li><li>r=8，尾数最高3位不全为0</li></ul><blockquote><p>基数不同，浮点数的规格化形式不同。</p></blockquote><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><ul><li>r=2<ul><li>左规，尾数左移一位，阶码减1</li><li>右规，尾数右移一位，阶码加1</li></ul></li><li>r=4<ul><li>左规，尾数左移两位，阶码减1</li><li>右规，尾数右移两位，阶码加1</li></ul></li><li>r=8<ul><li>左规，尾数左移三位，阶码减1</li><li>右规，尾数右移三位，阶码加1</li></ul></li></ul><blockquote><p>基础r越大，可表示的浮点数的范围越大<br>基数r越大，浮点数的精度降低</p></blockquote><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>设m=4，n=10，r=2，尾数规格化后的浮点数表示范围<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>将+19/128写成二进制定点数、浮点数及在定点机和浮点机中的机器数形式。其中数值部分均取10位，数符取1位，浮点数阶码取5位(含一位阶符)，尾数规格化。<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>19/128用二进制表示形式，19每次除2，小数点向左移动一位。</p></blockquote><p>将-58表示成二进制定点数和浮点数，并写出它在定点机和浮点机中的三种机器数及阶码为移码、尾数为补码的形式。<br><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/7.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="机器零"><a href="#机器零" class="headerlink" title="机器零"></a>机器零</h3><ul><li>当浮点数尾数为0时，不论其阶码为何值按机器零处理。</li><li>当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理，如m=4，n=10。</li><li>当阶码和尾数都用补码表示时，机器零为x,xxxx;0.00…0, 阶码=-16: 1,0000;x.xx…x.</li><li>当阶码用移码，尾数用补码表示时，机器零为0,0000;0.00…0,有利于机器中”判0”电路的实现。</li></ul><h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><p><img src="/2020/04/27/%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机运算方法</title>
    <link href="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机的运算方法"><a href="#计算机的运算方法" class="headerlink" title="计算机的运算方法"></a>计算机的运算方法</h1><h2 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>寄存器的位数反映无符号数的表示范围。</p><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><h4 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h4><ul><li>整数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/3.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>小数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/4.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/5.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><h4 id="补的概念"><a href="#补的概念" class="headerlink" title="补的概念"></a>补的概念</h4><p>原码的特点是简单，直观，但是如果用原码做加法，一个正数和一个负数相加，结果的符号可正可负，需要找到一个与负数等价的正数来代替这个负数，假设一个时钟的时针指向六点，要想将时针指向三点方向，有两个办法，其一是将时针-3，其二是将时针+9.可见-3可用+9代替，这样将减法变为加法，称+9是-3以12为模的补数。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/6.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li>一个负数加上“模”即得该负数的补数</li><li>一个整数和一个负数互为补数时，他们绝对值之和即为模数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/7.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h4 id="正数的补数即为其本身"><a href="#正数的补数即为其本身" class="headerlink" title="正数的补数即为其本身"></a>正数的补数即为其本身</h4><p>两个互为补数的数分别加上模，结果仍互为补数。假设寄存器只能存4位数值，则需要将溢出位丢弃，可见正数的补数和负数的补数相同。为了区分正数与负数的符号，需要再加符号位，为了添加符号问还需要+2^4,则两次一共+2^(4+1)。这样无论正数还是负数的补码，都添加了符号位用于区分。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/8.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="补码定义"><a href="#补码定义" class="headerlink" title="补码定义"></a>补码定义</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>n不包括符号位</p></blockquote><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>正数用逗号隔开符号位，小数使用点号隔开符号位</p><h4 id="求补码的快捷方式"><a href="#求补码的快捷方式" class="headerlink" title="求补码的快捷方式"></a>求补码的快捷方式</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/11.png" srcset="/img/loading.gif" width="350px" height="230px"><br>计算100000-1010时可以用11111-1010+1代替.<br>当真值为负时，补码可用原码除符号位外每位取反，末位加1求得。<br>+0与-0补码相同</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p></blockquote><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>正数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/13.png" srcset="/img/loading.gif" width="350px" height="230px"></li><li>小数<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/14.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="三种机器数的小结"><a href="#三种机器数的小结" class="headerlink" title="三种机器数的小结"></a>三种机器数的小结</h4><ul><li>最高位位符号位，书写上用“，”(正数)或“.”（小数）将数值部分和符号位隔开</li><li>对于正数，原码=补码=反码</li><li>对于负数，符号位为1，其数值部分原码除符号位外每位取反末位加1等于补码，原码除符号位外每位取反等于反码。<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/16.png" srcset="/img/loading.gif" width="350px" height="230px">&lt;/img&gt;<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/17.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ul><h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><p>因为补码表示很难直接判断其真值的大小，所以使用移码进行比较。<br><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><blockquote><p>移码实际是将真值向上移了2^n.</p><h4 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="移码和补码的比较"><a href="#移码和补码的比较" class="headerlink" title="移码和补码的比较"></a>移码和补码的比较</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="移码的特点"><a href="#移码的特点" class="headerlink" title="移码的特点"></a>移码的特点</h4><p><img src="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>用移码表示浮点数的阶码，能方便的判断浮点数的阶码大小。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线</title>
    <link href="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <url>/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="总线的作用"><a href="#总线的作用" class="headerlink" title="总线的作用"></a>总线的作用</h2><p>总线是连接各个部件的信息传输线,是各个部件共享的传输介质.</p><h3 id="总线上的信息传送"><a href="#总线上的信息传送" class="headerlink" title="总线上的信息传送"></a>总线上的信息传送</h3><ul><li>串行传输,每次只传送一个字节,也只接收一个字节.</li><li>并行传输,每次传输多个字节,接收多个字节,但也要使用更多传输线.</li></ul><h2 id="总线结构的计算机举例"><a href="#总线结构的计算机举例" class="headerlink" title="总线结构的计算机举例"></a>总线结构的计算机举例</h2><h3 id="单总线结构框图"><a href="#单总线结构框图" class="headerlink" title="单总线结构框图"></a>单总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>将所有的设备全部连接到一条总线上,缺点是当某一个设备占用总线时,其他设备不能占用总线,导致整体运行效率降低.</p><h3 id="面向CPU的双总线结构框图"><a href="#面向CPU的双总线结构框图" class="headerlink" title="面向CPU的双总线结构框图"></a>面向CPU的双总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>以CPU为中心,双总线结构在CPU与内存之间使用了一根专用的总线,由于CPU运算时的指令与数据全部来自主存,所以在CPU与主存间使用总线可以保证CPU的运行效率,并且不会影响I/O设备的使用,但如果I/O设备要和主存之间进行信息传输必须经过CPU,导致CPU工作繁忙.</p><h3 id="以存储器为中心的双总线结构框图"><a href="#以存储器为中心的双总线结构框图" class="headerlink" title="以存储器为中心的双总线结构框图"></a>以存储器为中心的双总线结构框图</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/3.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>以主存为中心,这种结构不仅让CPU可以直接访问主存,也让I/O设备可以直接对主存进行存储操作.</p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><ul><li>片内总线,芯片内部的总线</li><li>系统总线,计算机各部件之间的信息传输线<ul><li>数据总线,双向,与机器字长,存储子长有关</li><li>地址总线,单向,与存储地址,IO地址有关</li><li>控制总线,有出有入.</li></ul></li><li>通信总线,用于计算机系统之间或计算机系统与其它系统之间的通信.<ul><li>串行通信总线</li><li>并行通信总线</li></ul></li></ul><h2 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h2><h3 id="总线的物理实现"><a href="#总线的物理实现" class="headerlink" title="总线的物理实现"></a>总线的物理实现</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/4.png" srcset="/img/loading.gif" width="350px" height="230px"><br>微型计算机中一般有一个大型印刷电路板,称之为主板,主板上分布总线,总线提供接口可以与其他设备相连接.</p><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><ol><li>机械特性: 尺寸,形状,管脚数及排列顺序.</li><li>电气特性: 传输方向和有效的电平范围.</li><li>功能特性: 每根传输线的功能,传输信号.</li><li>时间特性: 信号的时序关系.</li></ol><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><ol><li>总线宽度: 数据线的根数</li><li>标准传输率: 每秒传输的最大字节数(MBps)</li><li>时钟同步/异步: 同步、不同步</li><li>总线复用: 地址线与数据线复用(8086)</li><li>信号线数: 地址线、数据线和控制线的总和</li><li>总线控制方式: 突发、自动、仲裁、逻辑、计数</li><li>其他指标: 负载能力(能挂多少I/O设备)</li></ol><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/5.png" srcset="/img/loading.gif" width="350px" height="230px"><br>例如ISA总线,时钟为8MHz,每秒可以传送8M次,每次传送16bits信息也就是两个字节,可以很容易计算出带宽为16MBps.</p><blockquote><p>带宽=总线宽度x总线频率.</p></blockquote><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/6.png" srcset="/img/loading.gif" width="350px" height="230px"><br>将总线分为存储总线和I/O总线,存储总线用于连接CPU和主存,I/O总线负责连接I/O设备,然后用通道将I/O总线与主存总线连接.</p><blockquote><p>通道: 具有特殊功能的处理器,由通道对IO统一管理,一般来说通道有自己的控制器与指令系统,并且可以执行一些简单的指令与通道程序.</p><h3 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/7.png" srcset="/img/loading.gif" width="350px" height="230px"><br>三总线结构将总线分为I/O总线,储存总线与DMA总线(直接存储器访问,外部设备直接访问内存),DMA总线与I/O接口相连,如果有高速设备需要与主存进行连接,可以通过DMA总线而不需要通过I/O总线.</p><h3 id="三总线结构的又一形式"><a href="#三总线结构的又一形式" class="headerlink" title="三总线结构的又一形式"></a>三总线结构的又一形式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/8.png" srcset="/img/loading.gif" width="350px" height="230px"><br>由于CPU的速度提高的非常快,所以现代计算机在主存与CPU之间增加了小容量高速度的Cache用于缓存主存的一些数据,CPU运行时需要的指令和数据主要从Cache中获取,局部总线连接了CPU和Cache,局部I/O控制器可以连接高速的I/O设备,系统总线通过扩展总线接口,连接了扩展总线,可以将各种外部设备连接到扩展总线,这样解决了I/O设备的扩展问题,外部设备通过扩展总线接口将数据传送进系统总线进而传送给主存和CPU.<br>这种结构的缺点是多种速度的设备都连接到了扩展总线,会影响I/O设备的运行效率.</p><h3 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/9.png" srcset="/img/loading.gif" width="350px" height="230px"><br>四总线结构包括,局部总线、系统总线、高速总线和扩展总线,局部总线连接CPU和Cache/桥,系统总线连接主存和Cache,桥电路连接 高速总线,高速总线连接各种高速设备,高速总线连接扩展总线接口,扩展总线接口连接扩展总线,扩展总线用于连接低速设备.这样避免了外部设备速度不同的问题,分离了高速设备与低速设备.</p><h2 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h2><h3 id="传统微型机总线结构"><a href="#传统微型机总线结构" class="headerlink" title="传统微型机总线结构"></a>传统微型机总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="VL-BUS局部总线结构"><a href="#VL-BUS局部总线结构" class="headerlink" title="VL-BUS局部总线结构"></a>VL-BUS局部总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="多层PCI总线结构"><a href="#多层PCI总线结构" class="headerlink" title="多层PCI总线结构"></a>多层PCI总线结构</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p></blockquote><h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>主设备(模块), 对总线有控制权</li><li>从设备(模块),响应从主设备发来的总线命令</li><li>总线判优控制<ul><li>集中式<ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li><li>分布式</li></ul></li></ul><h3 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>总线控制部件集中在了一起,数据线用于信息交换过程中数据的传输,主设备占用总线后要跟从设备进行数据传输要通过地址总线找到对应的从设备.所有的设备都通过BR线发出总线占用或使用的请求.如果某个设备占用了总线控制权,则该设备通过BS告知总线控制部件或其他部件总线忙.BG为总线授权线,通过BG线逐个查询是哪一个设备提出的总线占用请求,该设备通过BS线设置总线忙,它就获得了总线的使用权.这种方式提前设置了设备的优先权,靠后的设备可能不会获得总线占用权.对电路故障敏感,如果向下传送过程中某一个电路出现故障,后面的设备就无法获得总线使用权.</p><h3 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>地址线用于查找从设备,设备地址上传输的地址是计数器给出的,通过这个地址去查找某个设备是否发出了总线占用请求.总线控制部件中有一个计数器,如果某主设备发出总线控制请求,控制部件收到请求后,可以让出总线使用权的情况下,会启动计数器.这个计数器的值通过设备地址这条线向外输出.计数器的值为0,就对I/O接口0进行查询,判断是否提出了响应请求,找到提出请求的设备后通过BS线应答.这种查询方式更加灵活,你可以设置计数器的启动,更改优先级.设备地址线数量与设备数有关.</p><h3 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/16.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>每一个I/O接口都连接BG与BR两条线,总线控制部件中有一个排队器.n个设备需要2n条线,多个I/O设备同时发起总线请求,排队器负责选择优先级高的设备控制总线.</p><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><ul><li>目的: 解决通信双方协调配合问题</li><li>总线传输周期(主设备和从设备之间完成一次完整并可靠的通讯需要的时间)<ul><li>申请分配阶段: 主模块申请,总裁仲裁决定</li><li>寻址阶段: 主模块向从模块给出地址和命令</li><li>传输阶段: 主模块和从模块交换数据</li><li>结束阶段: 主模块撤销有关消息</li></ul></li><li>总线通信的四种方式<ul><li>同步通信: 由<strong>统一的时标</strong>控制数据传送</li><li>异步通信: 采用应答方式,没有公共时钟标准</li><li>半同步通信: 同步、异步结合</li><li>分离式通信: 充分挖掘系统总线每个瞬间的潜力</li></ul></li></ul><h3 id="同步式数据输入"><a href="#同步式数据输入" class="headerlink" title="同步式数据输入"></a>同步式数据输入</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/17.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="同步式数据输出"><a href="#同步式数据输出" class="headerlink" title="同步式数据输出"></a>同步式数据输出</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h3><p><img src="/2020/04/25/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/20.png" srcset="/img/loading.gif" width="350px" height="230px"><br>同步: 发送方用系统时钟前言发信号,接收方用系统时钟后沿判断、识别.<br>异步: 允许不同速度的模块和谐工作,增加一条等待响应信号WAIT.</p><h4 id="以输入数据为例的半同步通信时序"><a href="#以输入数据为例的半同步通信时序" class="headerlink" title="以输入数据为例的半同步通信时序"></a>以输入数据为例的半同步通信时序</h4><ul><li>T1: 主模块发地址</li><li>T2: 主模块发命令</li><li>Tw: 当WAIT为低电平时,等待一个T</li><li>Tw: 当WAIT为低电平时,等待一个T…</li><li>T3: 从模块提供数据</li><li>T4: 从模块撤销数据,主模块撤销命令</li></ul><h3 id="上述三种通信的共同点"><a href="#上述三种通信的共同点" class="headerlink" title="上述三种通信的共同点"></a>上述三种通信的共同点</h3><p>一个总线传输周期(以输入数据为例)</p><ul><li>主模块发地址、命令 (占用总线)</li><li>从模块准备数据 (不占用总线,总线空闲)</li><li>从模块向主模块发数据 (占用总线)</li></ul><h3 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h3><p>一个总线传输周期</p><ul><li>子周期1: 主模块申请占用总线,使用完后即放弃总线的使用权.</li><li>子周期2: 从模块申请占用总线,将各种信息传送至总线上.</li></ul><h4 id="分离式通信特点"><a href="#分离式通信特点" class="headerlink" title="分离式通信特点"></a>分离式通信特点</h4><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信,不等对方回答</li><li>各模块准备数据时,不占用总线</li><li>总线被占用时,无空闲.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机性能与发展</title>
    <link href="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/"/>
    <url>/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机性能与发展"><a href="#计算机性能与发展" class="headerlink" title="计算机性能与发展"></a>计算机性能与发展</h1><h2 id="计算机硬件性能指标"><a href="#计算机硬件性能指标" class="headerlink" title="计算机硬件性能指标"></a>计算机硬件性能指标</h2><ul><li>机器字长，CPU一次能处理数据的位数与CPU中寄存器位数有关。</li><li>运算速度<ul><li>主频</li><li>核数，每个核支持的线程数</li><li>吉普森法</li><li>CPI 执行一条指令所需时钟周期数</li><li>MIPS 每秒执行百万条指令</li><li>FLOPS 每秒浮点运算次数</li></ul></li><li>存储容量<ul><li>主存容量<ul><li>存储单元个数 X 存储字长，如MAR与MDR容量，1Kx8位.</li><li>字节数，如2^13b = 1KB.</li></ul></li><li>辅存容量<ul><li>字节数 80GB.</li></ul></li></ul></li></ul><h2 id="计算机发展及应用"><a href="#计算机发展及应用" class="headerlink" title="计算机发展及应用"></a>计算机发展及应用</h2><p>1946年，美国ENIAC生产了世界第一台10进制运算的计算机，一共18000多个电子管，1500多个继电器 ，150千瓦的功耗，30吨重量，占地1500平方英尺，每秒钟可以进行5000次加法运算，需要手工搬动开关和拔插电缆来进行编程。</p><h3 id="硬件技术对计算机更新换代的影响"><a href="#硬件技术对计算机更新换代的影响" class="headerlink" title="硬件技术对计算机更新换代的影响"></a>硬件技术对计算机更新换代的影响</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/1.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="INtel公司的典型微处理器产品"><a href="#INtel公司的典型微处理器产品" class="headerlink" title="INtel公司的典型微处理器产品"></a>INtel公司的典型微处理器产品</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95/2.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Moore定律"><a href="#Moore定律" class="headerlink" title="Moore定律"></a>Moore定律</h3><p>Intel公司的缔造者之一Gordon Moore提出，微芯片上集成的晶体管数目每三年翻两番。</p><h3 id="编程语言的兴起"><a href="#编程语言的兴起" class="headerlink" title="编程语言的兴起"></a>编程语言的兴起</h3><ul><li>机器语言-面向机器</li><li>汇编语言-面向机器</li><li>高级语言-面向问题</li><li>FORTRAN 科学计算和工程计算</li><li>PASCAL 结构化程序设计</li><li>C++ 面向对象</li><li>Java 适应网络环境</li></ul><h3 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h3><ul><li>语言处理程序: 汇编程序，编译程序，解释程序</li><li>操作系统: DOS，UNIX，Windows，Linux，KylinLinux</li><li>服务性程序: 装备 调试 诊断 排错</li><li>数据库管理系统: 数据库和数据库管理软件</li><li>网络软件<h3 id="软件发展的特点"><a href="#软件发展的特点" class="headerlink" title="软件发展的特点"></a>软件发展的特点</h3></li></ul><ol><li>开发周期长</li><li>制作成本昂贵</li><li>检测软件产品质量的特殊性</li><li>软件是程序以及开发和使用维护程序所需要的所有文档</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组原理概述</title>
    <link href="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计组原理概述"><a href="#计组原理概述" class="headerlink" title="计组原理概述"></a>计组原理概述</h1><h2 id="如何使用计算机解决数学问题"><a href="#如何使用计算机解决数学问题" class="headerlink" title="如何使用计算机解决数学问题"></a>如何使用计算机解决数学问题</h2><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h3 id="编程举例"><a href="#编程举例" class="headerlink" title="编程举例"></a>编程举例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/1.png" srcset="/img/loading.gif" width="350px" height="350px"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="350px"></p><h2 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" width="100px" height="200px"></p><ul><li>存储体 - 存储单元 - 存储元件（1/0）</li><li>大楼 - 房间 - 床位 （无人/有人）</li><li>存储单元：存放一串二进制代码，每一个存储单元赋予一个地址</li><li>存储子： 存储单元中二进制代码的组合</li><li>存储字长： 存储单元中二进制代码的位数</li><li>MAR ： 存储器地址寄存器，反应存储单元的个数</li><li>MDR ： 存储器数据寄存器，反应存储字长</li></ul><blockquote><p>假设存储体为一个长方体，长方体的底面积为容纳的存储器地址，长方体的高为每一个存储器地址内的数据位，设MAR=4bit，MDR=8bit，存储单元个数为16，存储字长为8.</p></blockquote><h2 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="加法操作过程"><a href="#加法操作过程" class="headerlink" title="加法操作过程"></a>加法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" width="350px" height="160px"><br>初态ACC已经保存了被加数，指令M给出加数在内存单元的地址，将加数从内存单元中取出，然后保存进寄存器X中，ALU将寄存器ACC与X中的数据进行运算，并将结果保存进ACC当中。</p><h3 id="减法操作过程"><a href="#减法操作过程" class="headerlink" title="减法操作过程"></a>减法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" width="350px" height="160px"><br>同样ACC保存了被减数，指令中给出了减数的内存地址，将减数从M中取出，并且存入寄存器X中，通过ALU的运算，将结果保存进ACC中。</p><h3 id="乘法操作过程"><a href="#乘法操作过程" class="headerlink" title="乘法操作过程"></a>乘法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/7.png" srcset="/img/loading.gif" width="350px" height="160px"><br>ACC中预先保存了被乘数，将指令中M地址中的乘数保存进MQ寄存器中，然后将ACC中的数据存入X寄存器中，由于乘法是利用累加和移位的操作实现的，所以要将ACC寄存器的数据清零，将X与MQ的数据进行乘法操作，并将结果的高位保存进ACC中，低位保存进MQ中。</p><h3 id="除法操作过程"><a href="#除法操作过程" class="headerlink" title="除法操作过程"></a>除法操作过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/8.png" srcset="/img/loading.gif" width="350px" height="160px"><br>ACC中保存了被除数，将M地址中的除数保存进X寄存器中，ALU实现ACC与X相除，结果保存进MQ中，余数保存进ACC中。</p><h2 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h2><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/9.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="主机完成一条指令以取数指令为例"><a href="#主机完成一条指令以取数指令为例" class="headerlink" title="主机完成一条指令以取数指令为例"></a>主机完成一条指令以取数指令为例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"><br>PC将当前预执行指令的地址送入MAR，由MAR送入存储体，在控制器的控制下，存储体将存储单元中保存的取数指令送入MDR，将取出来的指令从MDR送入IR，经过以上操作，取指令完成。将IR中指令的操作码部分送入CU控制单元，由CU控制单元去控制并完成操作的部分。IR中保存取数指令，将IR中取数指令的地址送入MAR，再由MAR送入存储体，将取数指令所指地址中的数据取出，存入MDR，从MDR中将数据存入ACC，这样就完成了取数操作。</p><h3 id="主机完成一条指令以取数指令为例-1"><a href="#主机完成一条指令以取数指令为例-1" class="headerlink" title="主机完成一条指令以取数指令为例"></a>主机完成一条指令以取数指令为例</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"><br>PC将当前预执行的指令地址送入MAR，再由MAR送入存储体，将该指令取出，存入MDR，从MDR送入IR中，将IR中指令的操作码送入CU，由CU完成操作。由CU控制IR将指令送入MAR，由MAR送入存储体，告知将有一个数据存入存储体，地址是多少。下一步将ACC中的数据送入MDR，由控制器的控制下将MDR中的数据保存进相应的地址中。</p><h3 id="ax-2-bx-c程序运行过程"><a href="#ax-2-bx-c程序运行过程" class="headerlink" title="ax^2+bx+c程序运行过程"></a>ax^2+bx+c程序运行过程</h3><p><img src="/2020/04/24/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/11.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频传输与无线网络</title>
    <link href="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="因特网如何传输音视频"><a href="#因特网如何传输音视频" class="headerlink" title="因特网如何传输音视频"></a>因特网如何传输音视频</h2><h3 id="Internet上传输音频视频面临的问题"><a href="#Internet上传输音频视频面临的问题" class="headerlink" title="Internet上传输音频视频面临的问题"></a>Internet上传输音频视频面临的问题</h3><ol><li>音频视频 占用的带宽高 网速恒定 延迟低</li><li>数据信息 对带宽要求低 对于网速是否恒定或延迟要求不高</li></ol><h3 id="因特网提供的音视频服务种类"><a href="#因特网提供的音视频服务种类" class="headerlink" title="因特网提供的音视频服务种类"></a>因特网提供的音视频服务种类</h3><ol><li>流式(streaming)存储音频/视频—边下载 边播放</li><li>流式实况音频/视频—边录制边发送，通过网络，现场直播<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/2.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>交互式音频/视频—实时交互式通信</li></ol><h2 id="IP电话概述"><a href="#IP电话概述" class="headerlink" title="IP电话概述"></a>IP电话概述</h2><p>狭义的IP电话就是指在IP网络上打电话。所谓IP网络就是使用IP协议的分组交换网的简称<br>广义的IP电话则不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信(包括话音，视像等)，甚至还包括即时传信IM(Instant Messaging)。</p><h3 id="IP电话的连接方法"><a href="#IP电话的连接方法" class="headerlink" title="IP电话的连接方法"></a>IP电话的连接方法</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="IP电话通话质量"><a href="#IP电话通话质量" class="headerlink" title="IP电话通话质量"></a>IP电话通话质量</h3><p>IP电话的通话质量主要由两个因素决定，一个是通话双方端到端的时延和时延抖动，另一个是话音分组的丢失率。但这两个因素是不确定的，是取决于当时网络上的通信量。<br>经验证明，在电话交谈中，端到端的时延不应超过250ms，否则交谈者就能感到不自然。</p><h2 id="改进“最大努力交付”服务"><a href="#改进“最大努力交付”服务" class="headerlink" title="改进“最大努力交付”服务"></a>改进“最大努力交付”服务</h2><p>网络层的主要目的就是“尽最大努力交付”，对于信息的优先级不考虑，为了优先传播音视频，应用层需要对其进行改善。服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此在最简单的意义上，有服务质量的服务就是能够满足用户的应用需求的服务。<br>服务质量可用若干基本的性能指标来描述，包括可用性，差错率，响应时间，吞吐量，分组丢失率，连接建立时间，故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。</p><h3 id="服务器如何实现优先传输音频或视频"><a href="#服务器如何实现优先传输音频或视频" class="headerlink" title="服务器如何实现优先传输音频或视频"></a>服务器如何实现优先传输音频或视频</h3><ol><li>基于标记的优先级确认<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/4.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>基于分类的优先级确认<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/5.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>流量管制机制<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/6.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>调度机制<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/7.png" srcset="/img/loading.gif" width="350px" height="160px"></li><li>呼叫接纳<br><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/8.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><h3 id="几种无线网络的比较"><a href="#几种无线网络的比较" class="headerlink" title="几种无线网络的比较"></a>几种无线网络的比较</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/9.png" srcset="/img/loading.gif" width="350px" height="160px"></p><blockquote><p>PAN：个人局域网，LAN：无线局域网，MAN：无线城域网，WAN：无线广域网</p><h3 id="无线局域网的组成"><a href="#无线局域网的组成" class="headerlink" title="无线局域网的组成"></a>无线局域网的组成</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/10.png" srcset="/img/loading.gif" width="350px" height="160px"></p></blockquote><p>一个基本服务集BBS包括一个基站和若干个移动站，所有的站在本BBS以内都可以直接通信，但在和本BBS以外的站通信时，都要通过本BBS的基站。基本服务集内的基站叫做接入点AP(Access Point).当网络管理员安装AP时，必须为该AP分配一个不超过32字节的服务集标识符SSID和一个信道。一个基本服务集可以是孤立的，也可通过接入点AP连接到一个主干分配系统DS(Distribution System),然后再接入到另一个基本服务集，构成扩展的服务集ESS(Extended Service Set)。</p><h3 id="移动自组网络"><a href="#移动自组网络" class="headerlink" title="移动自组网络"></a>移动自组网络</h3><p><img src="/2020/03/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/11.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全概述</title>
    <link href="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="安全分类"><a href="#安全分类" class="headerlink" title="安全分类"></a>安全分类</h2><ol><li>数据存储安全</li><li>应用程序安全</li><li>操作系统安全</li><li>网络安全</li><li>物理安全</li></ol><h2 id="计算机网络上的通信面临以下四种威胁："><a href="#计算机网络上的通信面临以下四种威胁：" class="headerlink" title="计算机网络上的通信面临以下四种威胁："></a>计算机网络上的通信面临以下四种威胁：</h2><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>截获——从网络上窃听他人通信内容</li><li>中断——有意中断他人在网络上的通信</li><li>篡改——故意篡改网络上传送的报文</li><li>伪造——伪造信息在网络上传送</li></ul><p>接获信息的攻击称为被动攻击，而更改信息和拒绝用户使用资源的攻击称为主动攻击。<br>例：ARP欺骗，CAIN通过ARP欺骗，伪装成网关地址，可以篡改DNS解析结果，也能获取密码。</p><h2 id="被动攻击与主动攻击"><a href="#被动攻击与主动攻击" class="headerlink" title="被动攻击与主动攻击"></a>被动攻击与主动攻击</h2><ul><li>中断——拒绝服务式攻击<br>例：Dos拒绝服务式攻击，通过发送没用数据包阻断网络，占用大量下载带宽；DDos分布式攻击，通过在网络中寻找并控制有漏洞的服务器，给指定的服务器发数据包使该服务器瘫痪。</li><li>篡改——修改域名解析结果<br>例：用ARP欺骗将用户想访问的网站指向钓鱼网站，骗取账号密码等。</li><li>伪造——伪装网关<br>例：ARP欺骗，将寻找网关的主机发送的报文截取，然后将自身主机伪装成网关。<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3></li><li>计算机病毒——会传染其他程序，通过修改其他程序来把自身或其变种复制进去完成的</li><li>计算机蠕虫——通过网络的通信功能将自身从一个节点发送到另一个节点并启动运行的程序</li><li>特洛伊木马——某种程序，它执行的功能超出所声称的功能</li><li>逻辑炸弹——一种当运行环境满足某种特定条件时执行其他特殊功能的程序</li></ul><h2 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p><h4 id="原理举例："><a href="#原理举例：" class="headerlink" title="原理举例："></a>原理举例：</h4><p>甲和乙是一对生意搭档，他们住在不同的城市。由于生意上的需要，他们经常会相互之间邮寄重要的货物。为了保证货物的安全，他们商定制作一个保险盒，将物品放入其中。他们打造了两把相同的钥匙分别保管，以便在收到包裹时用这个钥匙打开保险盒，以及在邮寄货物前用这把钥匙锁上保险盒。<br>上面是一个将重要资源安全传递到目的地的传统方式，只要甲乙小心保管好钥匙，那么就算有人得到保险盒，也无法打开。这个思想被用到了现代计算机通信的信息加密中。在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。</p><blockquote><p>优点：效率高<br>缺点：密匙不适合在网上传输，密匙维护麻烦</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。</li><li>A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。</li><li>A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。</li><li>A将这个消息发给B（已经用B的公钥加密消息）。</li><li>B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。</li></ol></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>加密秘钥和解密秘钥是不同的一对秘钥<br>公钥加密私钥解密，私钥加密公钥解密<br>使用数字签名，防止抵赖，能够检查签名之后内容是否被更改</p><h3 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h3><p>DES属于常规密钥密码体制，是一种分组密码。在加密前，先对整个明文进行分组，每一个组长为64位，然后对每一个位二进制数据进行加密处理，产生一组64位密文数据，最后将各组密文串联起来，即得出整个的密文。</p><blockquote><p>使用的密钥位64位，实际密钥长度为56位，还有8位用于奇偶效验。</p><h4 id="DES的保密性"><a href="#DES的保密性" class="headerlink" title="DES的保密性"></a>DES的保密性</h4><p>DES的保密性仅取决于对密钥的保密，而算法时公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。<br>DES是世界上第一个公认的使用密码算法标准，他曾对密码学的发展做出了重大贡献。<br>目前较为严重的问题是DES的密钥长度，现在已经设计出来搜索DES密钥的专用芯片.<br>DES算法公开取决于密钥长度，56位密钥破解需要3.5或21分钟，128位密钥破解需要5.4*10^18次方年。</p></blockquote><h2 id="安全套接字SSL"><a href="#安全套接字SSL" class="headerlink" title="安全套接字SSL"></a>安全套接字SSL</h2><p>SSL的位置在应用层和传输层之间，优点是应用层和传输层都不需要来加密。不需要应用层的支持，但是需要在服务器配置证书。</p><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><p>在发送方，SSL接收应用层的数据(如HTTP或IMAP报文)，对数据进行加密，然后把加密的数据送往TCP套接字，在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</p><h3 id="SSL提供的功能"><a href="#SSL提供的功能" class="headerlink" title="SSL提供的功能"></a>SSL提供的功能</h3><ul><li>SSL服务器鉴别<br>允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA(Certificae Authority)和它们的公钥。</li><li>加密的SSL会话<br>客户和服务器交互的所有数据都在发送方加密，在接收方解密。</li><li>SSL客户鉴别<br>允许服务器证实客户的身份。<blockquote><p>CA，证书颁发机构，为企业和用户颁发数字证书，确保这些企业与用户的身份是否可靠，如果证书丢失需要发布吊销列表，企业和个人需要信任证书颁发机构。</p></blockquote></li></ul><h3 id="SSL加密步骤"><a href="#SSL加密步骤" class="headerlink" title="SSL加密步骤"></a>SSL加密步骤</h3><p>用户使用浏览器去访问某服务器端的网站，此时网站会把他的公钥给用户浏览器，浏览器通过校验CA证书确保该网站的公钥是可靠的，浏览器会产生一个对称密钥，浏览器使用网站的公钥对它的对称密钥进行加密，发给该网站，网站用它的私钥进行解密，就得到了用户浏览器的对称密钥。</p><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><ul><li>Https = TCP + 443</li><li>IMAPS = TCP + 993</li><li>POPS = TCP + 995</li><li>SMTPS = TCP + 465</li></ul><h2 id="网络层安全IPSec"><a href="#网络层安全IPSec" class="headerlink" title="网络层安全IPSec"></a>网络层安全IPSec</h2><h3 id="安全关联SA-Security-Association"><a href="#安全关联SA-Security-Association" class="headerlink" title="安全关联SA(Security Association)"></a>安全关联SA(Security Association)</h3><p>在使用AH或ESP之前，先要从源主机到目的主机建立一条网络层的逻辑链接，此逻辑连接叫做安全关联SA。<br>IPsec就把传统的因特网无连接的网络层转换为具有逻辑链接的层。<br>SA(安全关联)是构成IPSec的基础，是两个通信实体经协商(利用IKE协议)建立起来的一种协定，它决定了用来保护数据分组安全的安全协议(AH协议或者ESP协议)，转码方式，密钥即密钥的有效存在时间等。</p><h3 id="IPSec中最主要的协议"><a href="#IPSec中最主要的协议" class="headerlink" title="IPSec中最主要的协议"></a>IPSec中最主要的协议</h3><p>鉴别首部AH(Authentication Header)：AH鉴别源点和检查数据完整性，但不能保密。<br>封装安全有效载荷ESP(Encapsulation Security Payload):ESP比AH复杂得多，它鉴别源点，检查数据完整性和提供保密。</p><ol><li>鉴别首部协议AH<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><p>在使用鉴别首部协议AH时，把AH首部插在原数据报数据部分前，同时把IP首部中的协议字段置为51.<br>在传输过程中，中间的路由器都不查看AH首部。当数据包到达终点时，目的主机才处理AH字段，以鉴别源点和检查数据报的完整性。</p><ol><li>封装安全有效载荷ESP<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" width="350px" height="160px"></li></ol><p>使用ESP时，IP数据报首部的协议字段置为50，当IP首部检查到协议字段是50时，就知道在IP首部后面紧接着的是ESP首部，同时在原IP数据报后面增加了两个字段，即ESP尾部和ESP数据。</p><h2 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙(firewall)"></a>防火墙(firewall)</h2><p>防火墙是由软件，硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略，接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。<br>防火墙内的网络称为“可信赖网络”(trusted network),而将外部的因特网称为“不可信赖的网络”(untrusted network)。<br>防火墙可用来解决内联网和外联网的安全问题。</p><h3 id="防火墙在互联网中的位置"><a href="#防火墙在互联网中的位置" class="headerlink" title="防火墙在互联网中的位置"></a>防火墙在互联网中的位置</h3><p><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="防火墙技术一般分为两类"><a href="#防火墙技术一般分为两类" class="headerlink" title="防火墙技术一般分为两类"></a>防火墙技术一般分为两类</h3><ol><li>网络级防火墙<br>用来防止整个网络出现外来非法入侵，属于这类的有分组过滤和授权服务器。前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准测的数据，而后者则是检查用户的登陆是否合法。</li><li>应用级防火墙<br>从应用程序来进行接入控制，通常使用应用网关或代理服务器来区分各种应用。例如，可以只允许通过访问万维网的应用，而阻止FTP应用的通过。</li></ol><h3 id="防火墙的结构"><a href="#防火墙的结构" class="headerlink" title="防火墙的结构"></a>防火墙的结构</h3><p>边缘防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/7.png" srcset="/img/loading.gif" width="350px" height="160px">&lt;/img&gt;<br>三向外围网<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/8.png" srcset="/img/loading.gif" width="350px" height="160px"><br>背靠背防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/9.png" srcset="/img/loading.gif" width="350px" height="160px">&lt;/img&gt;<br>单一网卡防火墙<br><img src="/2020/03/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/10.png" srcset="/img/loading.gif" width="350px" height="160px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层概述</title>
    <link href="/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络应用层概述"><a href="#网络应用层概述" class="headerlink" title="网络应用层概述"></a>网络应用层概述</h1><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><ul><li>域名解析系统DNS(Domain Name System)</li><li>动态主机配置协议DHCP</li><li>文件传送协议FTP(File Transfer Protocol)</li><li>远程终端协议TELNET</li><li>远程桌面RDP</li><li>万维网www(World Wide Web)</li><li>电子邮件(SMTP POP IMAP)</li></ul><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>作用：负责解析域名 将域名解析成IP<br>域名分类： 根域名<br>顶级域名 com，edu，net，cn，org，gov<br>二级域名 baidu，souhu，bilibili<br>三级域名 dba，例如dba.souhu.com</p><blockquote><p>命令：ns lookup得到IP地址</p></blockquote><h3 id="配置内网DNS服务器的作用："><a href="#配置内网DNS服务器的作用：" class="headerlink" title="配置内网DNS服务器的作用："></a>配置内网DNS服务器的作用：</h3><p>可以避免网络阻塞，让其他计算机通过内网DNS服务器解析IP地址，内网DNS服务器向外请求，将常用IP地址缓存到本地，减少内网访问Interne的流量。</p><h2 id="动态主机配置系统DHCP"><a href="#动态主机配置系统DHCP" class="headerlink" title="动态主机配置系统DHCP"></a>动态主机配置系统DHCP</h2><p>客户机在网中发广播请求地址，目标IP是4个255，目标MAC地址是全FF。DHCP收到后，会从地址池里选一个给客户机。如果网络中有2个DHCP服务端且都给了反馈，此时计算机还需要返回一个数据通知他选择了谁提供的地址。<br>另一个DHCP客户端发现没要他的，于是收回他提供的。从这个角度看，网络中不能有太多的DHCP服务端,DHCP服务器必须是固定IP地址，DHCP跨网段配置IP地址需要DHCP配IP地址的计算机，需要在他所在的网络的路由器的网关上配置IPhelper address，再访问到DHCP.</p><h2 id="文本传输协议FTP"><a href="#文本传输协议FTP" class="headerlink" title="文本传输协议FTP"></a>文本传输协议FTP</h2><p><img src="/2020/03/16/%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" width="350px" height="160px"><br>FTP使用两个TCP连接<br>FTP的连接方式包括控制连接和数据连接，每上传或下载一个文件就会建立一个会话。<br>控制连接：标准端口为21，用于发送FTP命令信息<br>数据连接：标准端口为20，用于上传或下载数据</p><h3 id="FTP数据连接"><a href="#FTP数据连接" class="headerlink" title="FTP数据连接"></a>FTP数据连接</h3><p>涉及主动模式和被动模式<br>主动模式：FTP客户端告诉FTP服务器的21端口，它在使用什么端口监听，然后FTP服务器的20端口主动和FTP客户端端口建立连接。</p><blockquote><p>主动模式防火墙需要打开21和20端口</p></blockquote><p>被动模式：FTP服务器打开在指定范围内的某个新端口并且进行监听，被动等待客户端发起连接。</p><blockquote><p>防火墙只能打开21和20端口，被动模式FTP不能下载数据。</p></blockquote><h3 id="FTP传输模式"><a href="#FTP传输模式" class="headerlink" title="FTP传输模式"></a>FTP传输模式</h3><p>文本模式：ASCII模式，以文本序列传输数据。<br>二进制模式：Binary模式，以二进制序列传输数据。</p><h2 id="telnet和RDP协议"><a href="#telnet和RDP协议" class="headerlink" title="telnet和RDP协议"></a>telnet和RDP协议</h2><p>远程终端协议telnet和远程桌面协议RDP都用来进行远程控制，RDP协议有图形界面，而telnet没有，Server多用户操作系统可以多用户同时使用服务器。</p><h2 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h2><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。<br>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h2 id="使用Web代理服务器访问网站"><a href="#使用Web代理服务器访问网站" class="headerlink" title="使用Web代理服务器访问网站"></a>使用Web代理服务器访问网站</h2><p>内网其它主机不能通过路由访问Internet，只能由web代理访问外网，然后内网其它主机访问这个web代理来实现上网功能，如果web代理在外网，反而速度更慢。</p><ol><li>节省内网访问Internet的带宽，便于访问内容变化不大的网站。</li><li>绕过防火墙访问外网，例如访问某个禁止的网站A，但是假如通过在与A同一个网络中的web代理，就可以访问该网站。</li><li>通过web代理避免被跟踪。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议详解</title>
    <link href="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h1><h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/11.png" srcset="/img/loading.gif" width="400px" height="250px"></p><ul><li>TCP是面向连接的传输层协议</li><li>每一条TCP连接只能有两个端点(endpoing)，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>面向字节流</li></ul><p>传输文件时，首先将文件进行分组然后放入缓存中，分组有大有小，将缓存中的数据再随机分组进行传输，接收端接收到分组的数据后放入接收缓存中，如果有丢包现象，要求发送端重新发送该丢包处后的数据 ，接收完成后，将数据存入计算机，最后拼接成完整的文件。</p><h2 id="TCP协议需要解决的问题"><a href="#TCP协议需要解决的问题" class="headerlink" title="TCP协议需要解决的问题"></a>TCP协议需要解决的问题</h2><ul><li>TCP如何实现可靠传输</li><li>TCP协议如何实现流量控制</li><li>TCP协议如何避免网络拥塞</li></ul><h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><ul><li>TCP把连接作为最基本的抽象。</li><li>每一条TCP连接有两个端点。</li><li>TCP连接的端口不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口，TCP连接的端点叫做套接字(socket)，端口号拼接到IP地址即构成了套接字。</li></ul><h2 id="可靠传输原理-停止等待协议"><a href="#可靠传输原理-停止等待协议" class="headerlink" title="可靠传输原理-停止等待协议"></a>可靠传输原理-停止等待协议</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.png" srcset="/img/loading.gif" width="360px" height="180px"><br>实现可靠传输要求发送端每发送一个数据包之后，接收端需要给发送端一个确认，并要求发送下一个数据包。如果发送方发送的数据包丢失，等待一段时间后发送方没有收到接收端的确认收到，则发送方会重新发送数据包。</p><ul><li>再发送完一个分组后，必须暂时保留已发送的分组副本。</li><li>分组和确认分组都必须进行编号</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ul><h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.png" srcset="/img/loading.gif" width="360px" height="180px"><br>接收端收到数据包后向发送端发送确认消息，如果确认消息丢失，发送端没有收到确认将会重新发送数据包，此时接收端会丢弃原有数据包，接收新的数据包。</p><p>如果发送端发送数据包后，接收端回复消息延迟，发送端会以为接收端没有收到数据包，重新发送，然后接收端丢弃原有数据包，接收新的数据包，过一段时间后发送端收到之前的确认消息会忽视。</p><h2 id="可靠通信的实现"><a href="#可靠通信的实现" class="headerlink" title="可靠通信的实现"></a>可靠通信的实现</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.png" srcset="/img/loading.gif" width="380px" height="160px"></p><ul><li>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</li><li>这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest).</li><li>ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</li></ul><p>停止等待协议优点是简单，缺点是信道利用率太低。<br>信道利用率: U = T<sub>D</sub> / T<sub>D</sub> + RTT + T<sub>A</sub></p><h2 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.png" srcset="/img/loading.gif" width="380px" height="160px"></p><p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方确认。<br>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。</p><h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/6.png" srcset="/img/loading.gif" width="380px" height="160px">&lt;/img&gt;<br>发送端口假设为5，发送端需要发送5个数据包。<br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/8.png" srcset="/img/loading.gif" width="380px" height="160px"><br>接收端收到前四个数据包后，向发送端进行确认，然后发送端会将发送窗口进行右移，如果12收到了，3没有收到，则滑动窗口会会回溯到3位置，重新发送。</p><h2 id="TCP报文首部格式"><a href="#TCP报文首部格式" class="headerlink" title="TCP报文首部格式"></a>TCP报文首部格式</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/9.png" srcset="/img/loading.gif" width="400px" height="250px"></p><ol><li>源端口： 2个字节</li><li>目的端口： 2个字节</li><li>序号： 当前数据的第一个字节在整个文件中的序号</li><li>确认号(ACK)： 接收端发送，提示发送端下一次该发送的数据在整个文件中的序号。接收端收到后，将这个序号之前的数据从缓存中删除。</li><li>数据偏移： 表示当前TCP报文段后多少个字节是TCP的数据部分。数据偏移最多表示二进制1111，即10进制的15，每个1表示4个字节，所以数据偏移最大表示报文首部为60个字节。</li><li>保留： 6位，无作用</li><li>URG： urgent，代表优先级，发送端优先发送而不是在缓存中排队。</li><li>ACK： acknowledge，设置1代表确认建立会话。</li><li>PSH： 设置1代表接收端优先读取，不需要再接收端的缓存中排队</li><li>RST： reset，设置为1代表TCP会话出现严重错误，必须释放和重连。</li><li>SYN： 同步，设置为1代表需要发起会话。</li><li>FIN： finish，设置为1代表释放连接</li><li>窗口： 接收端先发送，发送端根据接收端的窗口大小确定发送端窗口大小。</li><li>检验和： 校验范围，TCP首部和数据</li><li>紧急指针： 只有URG设置为1可用，表示优先级数据的尾部</li></ol><blockquote><p>WindowXP可以利用TCP协议漏洞进行Land与SYN攻击</p></blockquote><h2 id="TCP抓包分析"><a href="#TCP抓包分析" class="headerlink" title="TCP抓包分析"></a>TCP抓包分析</h2><p>访问网站进行抓包，数据包主要分为TCP、UDP和ARP。</p><ul><li>首先ARP协议发送广播询问目标网站IP地址</li><li>DNS进行域名解析</li><li>TCP建立会话，进行三次握手然后发送数据</li></ul><blockquote><p>MSS：能传输的最大数据包，Win： 窗口大小</p></blockquote><h3 id="传输数据流程"><a href="#传输数据流程" class="headerlink" title="传输数据流程"></a>传输数据流程</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/10.png" srcset="/img/loading.gif" width="360px" height="180px"></p><h2 id="以字节为单位的滑动窗口技术实现可靠传输"><a href="#以字节为单位的滑动窗口技术实现可靠传输" class="headerlink" title="以字节为单位的滑动窗口技术实现可靠传输"></a>以字节为单位的滑动窗口技术实现可靠传输</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/12.png" srcset="/img/loading.gif" width="400px" height="250px"><br>A的发送窗口由B的接收窗口大小决定，TCP协议会协商窗口大小参数。<br>在没有收到B确认收到之前，A不能删掉滑动窗口内的内容，A可以持续给B发送，直到A的滑动窗口内数据都发了。<br>B收到后给A的确认消息后反馈ACK，序号是下一个应该发送的字节的序号，A收到后，就可以滑动窗口到对应的位置。例如B反馈ACK是7，那么A的滑窗可以移动到7位置，1-6删除。21-26可以发送。<br>以上是正常状态下的情况。如果出现丢失情况，例如7-9丢失，此时B反馈的ACK=7.因为10-12收到了，因此B发送SACK(选择性确认)，A只发送7-9。</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>TCP每发送一个报文段，就对这个报文段设置一次计时器，只要计时器设置的重传时间到但还没收到确认，就要重传这一段报文。<br>新的RTT<sub>s</sub> = (1 - a)<em>(旧的RTT<sub>s</sub>) +a </em>新的RTT样本<br>超时重传时间应略大于上面的出的加权平均往返时间RTT<sub>s</sub><br>RFC2988推荐的a值为1/8</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>解决通信两端处理时间不一样的问题。通过实时调整滑窗尺寸的大小(尺寸可以是0)来实现流量控制。接收端主动调整滑窗大小，发送端根据接收端发送的报文调整相应的滑窗。发送端也会定时发送报文向接收端确认滑窗信息，避免接收端发送的相关调整滑窗大小的报文丢失带来的影响。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/20.png" srcset="/img/loading.gif" width="400px" height="250px"><br>出现资源拥塞的条件：对资源需求的总和&gt;可用资源<br>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制，它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方维持拥塞窗口,发送方控制拥塞窗口的原则：<br>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。<br>只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><blockquote><p>拥塞窗口cwnd(congestion window)</p></blockquote><h3 id="慢开始算法的原理"><a href="#慢开始算法的原理" class="headerlink" title="慢开始算法的原理"></a>慢开始算法的原理</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/21.png" srcset="/img/loading.gif" width="360px" height="180px"></p><h3 id="设置慢开始门限状态变量ssthresh"><a href="#设置慢开始门限状态变量ssthresh" class="headerlink" title="设置慢开始门限状态变量ssthresh"></a>设置慢开始门限状态变量ssthresh</h3><p>慢开始门限ssthresh的用法如下：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，停止使用满开始算法而改用拥塞避免算法。</li><li>当cwnd=ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法。</li></ul><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。</p><h3 id="慢开始和拥塞避免算法举例"><a href="#慢开始和拥塞避免算法举例" class="headerlink" title="慢开始和拥塞避免算法举例"></a>慢开始和拥塞避免算法举例</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/22.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>拥塞避免并非指完全能够避免拥塞，是在拥塞避免阶段把拥塞窗口控制为按线性规律增长，是网络比较不容易出现拥塞。</p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/23.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>快重传算法首先要求接收方每收到一个失序的报文后就立即发出重复确定。这样做可以让发送方及早知道有报文没有到达接收方。<br>当发送端收到连续三个重复的确定时，就执行”乘法减小”算法，把慢开始门限ssthresh减半，但拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大。</p><h3 id="发送窗口的实际上限值"><a href="#发送窗口的实际上限值" class="headerlink" title="发送窗口的实际上限值"></a>发送窗口的实际上限值</h3><p>发送方的发送窗口的上限值应当取为接收方窗口和拥塞窗口这两个变量中较小的一个，即：发送窗口上限值=Min[rwnd,cwnd]</p><h2 id="TCP的传输连接管理"><a href="#TCP的传输连接管理" class="headerlink" title="TCP的传输连接管理"></a>TCP的传输连接管理</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/14.png" srcset="/img/loading.gif" width="360px" height="180px"></p><p>传输连接有三个阶段： 连接建立，数据传送，连接释放</p><ul><li>TCP连接的建立都是采用客户服务器方式</li><li>主动发起连接建立的应用进程叫做客户(client)</li><li>被动等待连接建立的应用进程叫做服务器(server)</li></ul><h2 id="第三次握手的原因"><a href="#第三次握手的原因" class="headerlink" title="第三次握手的原因"></a>第三次握手的原因</h2><p>假如把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A和B之间的通信，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数据分组。可是，B的应答分组在传输中被丢失的情况下，A将不知道B是否已准备好，A认为连接还未建立成功，将忽略B发来的任何数据分组，这样就形成了死锁。</p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/15.png" srcset="/img/loading.gif" width="450px" height="260px">&lt;/img&gt;<br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/16.png" srcset="/img/loading.gif" width="450px" height="260px"><br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/17.png" srcset="/img/loading.gif" width="450px" height="260px">&lt;/img&gt;<br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/18.png" srcset="/img/loading.gif" width="450px" height="260px"><br><img src="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/19.png" srcset="/img/loading.gif" width="450px" height="260px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层与UDP协议简述</title>
    <link href="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <url>/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输层概述与UDP协议简述"><a href="#传输层概述与UDP协议简述" class="headerlink" title="传输层概述与UDP协议简述"></a>传输层概述与UDP协议简述</h1><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><ul><li>传输层协议UDP和TCP</li><li>网络安全</li><li>TCP可靠传输的实现</li><li>TCP的流量控制</li><li>TCP的拥塞控制</li><li>TCP的运输连接管理</li></ul><h2 id="OSI和DOD模型"><a href="#OSI和DOD模型" class="headerlink" title="OSI和DOD模型"></a>OSI和DOD模型</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/2.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="传输层两个协议"><a href="#传输层两个协议" class="headerlink" title="传输层两个协议"></a>传输层两个协议</h2><p>在TCP/IP协议栈，传输层有两个协议TCP和UDP。</p><ul><li>TCP(Transmission Control Protocol)传输控制协议</li><li>UDP(User Data Protocol)用户数据报协议</li></ul><p>TCP 需要将要传输的文件分段 传输 建立会话 可靠传输 流量控制<br>UDP 一个数据包就能够完成数据通信 不分段 不需要建立会话 不需要流量控制 不可靠传输 (屏幕广播 多播 广播)</p><h2 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/3.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="常见的应用层协议使用端口"><a href="#常见的应用层协议使用端口" class="headerlink" title="常见的应用层协议使用端口"></a>常见的应用层协议使用端口</h2><ul><li>http = TCP + 80</li><li>https = TCP + 443</li><li>RDP = TCP + 3389</li><li>ftp = TCP + 21</li><li>共享文件夹 = TCP + 445</li><li>SMTP = TCP + 25</li><li>POP3 = TCP + 110</li><li>telnet = TCP + 23</li><li>SQL = TCP + 1433</li><li>DNS = UDP + 53</li></ul><h2 id="服务和应用层协议之间的关系"><a href="#服务和应用层协议之间的关系" class="headerlink" title="服务和应用层协议之间的关系"></a>服务和应用层协议之间的关系</h2><ul><li>服务使用TCP或UDP的端口侦听客户端请求</li><li>客户端使用IP地址定位服务器 使用目标端口定位服务</li><li>可以在服务器网卡上设置只开放必要的端口 实现服务器网络安全</li><li>可以更改服务使用的默认端口，迷惑病毒，让系统更安全</li></ul><h2 id="如何查看服务侦听的端口"><a href="#如何查看服务侦听的端口" class="headerlink" title="如何查看服务侦听的端口"></a>如何查看服务侦听的端口</h2><pre><code>netstat -anetstat -an 以数字的形式查看端口netstat -n 查看建立的会话netstat -nb 查看建立会话的进程telnet 192.168.80.100 3389 测试到远程计算机某个端口是否打开</code></pre><h2 id="传输层的功能-1"><a href="#传输层的功能-1" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>为相互通信的应用进程提供了端到端的逻辑通信</li><li>传输层还要对收到的报文进行差错检测</li><li>传输层提供面向连接和无连接的服务</li></ul><h2 id="传输层协议和网络层协议的主要区别"><a href="#传输层协议和网络层协议的主要区别" class="headerlink" title="传输层协议和网络层协议的主要区别"></a>传输层协议和网络层协议的主要区别</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/5.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h2 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h2><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/6.png" srcset="/img/loading.gif" width="375px" height="220px"></p><ul><li>端口用一个16位端口号进行标志</li><li>端口号只具有本地意义，即端口号只为了标志本计算机应用层中的各进程。在因特网中不同的计算机的相同端口号是没有联系的。</li><li>熟知端口，数值一般为0-1023.</li><li>登记端口号，数值为1024-49151.</li><li>客户端口号，数值为49152-65535.</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>UDP是无连接的，即发送数据之前不需要建立连接</li><li>UDP使用最最大努力交付，及不保证可靠交付，同时也不使用拥塞控制。</li><li>UDP是面向报文的，UDP没有拥塞控制，适合多媒体通信的要求。</li><li>UDP支持一对一，一对多，多对多的交互通信。</li><li>UDP的首部开销小，只有8字节。</li></ul><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/7.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/8.png" srcset="/img/loading.gif" width="375px" height="220px"><br>首部中的长度指的是UDP用户数据报的长度(首部+数据)，伪首部用于检验和。</p><h3 id="计算UDP检验和的例子"><a href="#计算UDP检验和的例子" class="headerlink" title="计算UDP检验和的例子"></a>计算UDP检验和的例子</h3><p><img src="/2020/03/03/%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/9.png" srcset="/img/loading.gif" width="375px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP数据包与路由</title>
    <link href="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h2><p>一个IP数据包由首部和数据两部分组成。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/2.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部的前一部分是固定长度，共字节，是所有IP数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><h3 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h3><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/3.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>版本：用来表示TCP/IP协议的版本 v4,v6</li><li>首部长度：确定数据包首部有多长，因为包含可变部分。</li><li>区分服务：确定更高的传输优先级。(QoS机制)</li><li>总长度：确定数据部分长度，一共16位，最多有2^16-1=65535字节。</li></ul><blockquote><p>传输限制：数据包最大65535字节，而数据链路层最大传输1500字节，所以对于大于1500字节的数据包，将会进行分片传输。（最大传输单元MTU）<br>分片传输：将数据进行分割，分别添加IP地址，通过网络发给接收端。接收端在通过网络层进行拼接，传送过程中可能存在丢包现象，或者后发的先到，所以需要对分片的数据包进行编号。<br>泪滴攻击：指的是向目标机器发送损坏的IP包，诸如重叠的包或者过大的包载荷。借由这些手段，该攻击可以通过TCP/IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p></blockquote><p>以太网V2数据帧模式：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/4.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>标识：如果出现数据包分片，那么标识用来确定哪些数据包需要组合，进行相同标记。</li><li>标志：占位，目前只有前两位有意义。标志字段的最低位是MF(More Fragment)，MF=1表示后面还有分片，MF=0表示最后一个分片，标志字段中间的一位是DF(Don`t Fragment)，只有当DF=0时才允许分片。</li></ul><p>数据包分片举例：<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/5.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>片偏移：偏移等于当前字节在数据部分的第几个再除以8.</li><li>生存时间：就是TTL(Time To Live)，每经过一个路由器就减1，8位二进制，作用是防止数据包在网络中循环。</li><li>协议号：用协议号标识数据部分是什么数据。<blockquote><p>ICMP：1, IGMP：2, TCP：6, UDP：17, IPv6：41, OSPF：89</p></blockquote></li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/6.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>首部检验和：16位，只检验数据报的首部，不检验数据部分，这里不是采用CRC而是简单的计算方法，每经过一个路由器就会检验一次。</li></ul><p><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/7.png" srcset="/img/loading.gif" width="350px" height="160px"></p><ul><li>源地址和目的地址：都是IP地址，32位，只符合IPv4.IPv6是128位。</li><li>可变部分：一般没用，IPv6已取消。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="网络畅通的条件"><a href="#网络畅通的条件" class="headerlink" title="网络畅通的条件"></a>网络畅通的条件</h3><p>沿途路由器必须知道下一跳给谁，数据包有去有回。<br><img src="/2020/02/25/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E8%B7%AF%E7%94%B1/8.png" srcset="/img/loading.gif" width="350px" height="160px"></p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>需要管理员手动设置路由表，适用于小规模网络，不能自动调整路由。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol><li>RIP协议<br>作用是周期性广播路由表，选择最佳路径，能够自动学习路由，最大15跳，不适合大规模网络。</li><li>OSPF协议<br>根据带宽选择路径</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICMP与IGMP协议</title>
    <link href="/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/23/ICMP%E4%B8%8EIGMP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ICMP与IGMP协议"><a href="#ICMP与IGMP协议" class="headerlink" title="ICMP与IGMP协议"></a>ICMP与IGMP协议</h1><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol).</p><ul><li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</li><li>ICMP 不是高层协议，而是IP层的协议。</li><li>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据包发送出去。</li></ul><h2 id="ping命令诊断网络故障"><a href="#ping命令诊断网络故障" class="headerlink" title="ping命令诊断网络故障"></a>ping命令诊断网络故障</h2><ul><li>PING(Packet Internet Grope),因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</li><li>ping指的是端对端连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数 防火墙的一个基本功能提供给用户进行选择。</li><li>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</li></ul><h3 id="使用ICMP协议的命令"><a href="#使用ICMP协议的命令" class="headerlink" title="使用ICMP协议的命令"></a>使用ICMP协议的命令</h3><p>TTL是数据报的生存时间，每过一个路由器就会减1，作用是防止数据报在网络中循环。<br>TTL默认初始值如下：</p><ul><li>Linux 64</li><li>Windows 128</li><li>Unix 255</li></ul><h3 id="ping与pathping命令"><a href="#ping与pathping命令" class="headerlink" title="ping与pathping命令"></a>ping与pathping命令</h3><p>pathing能跟踪数据包路径，发现问题位置。<br>Windows上跟踪数据包路径的命令：tracerert ip地址<br>路由器上跟踪数据包路径的命令： traceroute ip地址</p><h2 id="IGMP协议与多播"><a href="#IGMP协议与多播" class="headerlink" title="IGMP协议与多播"></a>IGMP协议与多播</h2><p>数据通信分为点到点通信，广播通信，还有组播通信。组播也称为多播通信。<br>多播通信可以跨网段，将数据同时传递给多个计算机，避免了占用大量带宽。<br>使用多播一般用于直播，网络会议等。<br>IGMP协议的作用就是周期性扫描本网段内有没有主机在访问多播数据包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层概述与ARP协议</title>
    <link href="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IOS网络层概述"><a href="#IOS网络层概述" class="headerlink" title="IOS网络层概述"></a>IOS网络层概述</h1><h2 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h2><p>负责在不同网络之间尽力转发数据包</p><blockquote><ul><li>基于数据包的IP地址转发</li><li>不负责丢失重传</li><li>不负责顺序</li></ul></blockquote><h2 id="数据包在Internet中传输"><a href="#数据包在Internet中传输" class="headerlink" title="数据包在Internet中传输"></a>数据包在Internet中传输</h2><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/2.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>路由器是三层设备：能看到网络层的IP地址来选择路径</p></blockquote><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/3.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h2 id="互联网与虚拟互联网"><a href="#互联网与虚拟互联网" class="headerlink" title="互联网与虚拟互联网"></a>互联网与虚拟互联网</h2><h3 id="互联网互联的设备"><a href="#互联网互联的设备" class="headerlink" title="互联网互联的设备"></a>互联网互联的设备</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/4.png" srcset="/img/loading.gif" width="420px" height="250px"></p><ol><li>物理层中继系统：转发器(repeater)，类似集线器</li><li>数据链路层中继系统：网桥或桥接器(bridge)</li><li>网络层中继系统：路由器(router)</li><li>传输层/应用层中继系统：网关(gateway)</li></ol><blockquote><p>中间设备又称为中间系统或中继系统(relay).<br>网关就是路由器接口的地址。一般是本网段第一个地址。</p></blockquote><h3 id="网络需要解决的问题"><a href="#网络需要解决的问题" class="headerlink" title="网络需要解决的问题"></a>网络需要解决的问题</h3><ol><li>不同寻址方案</li><li>不同最大分组长度</li><li>不同网络接入机制</li><li>不同超时控制</li><li>不同差错恢复方法</li><li>不同状态报告方法</li><li>不同路由选择技术</li><li>不同用户接入控制</li><li>不同服务</li><li>不同管理与控制方式</li></ol><blockquote><p>虚拟互联网将复杂的互联网抽象成一个网络，这样用户只需要关心如何接入互联网而不需要关心互联网的复杂性，简化了问题模型。</p></blockquote><h2 id="网络设备和OSI参考模型的关系"><a href="#网络设备和OSI参考模型的关系" class="headerlink" title="网络设备和OSI参考模型的关系"></a>网络设备和OSI参考模型的关系</h2><h3 id="PC4向PC3传输数据"><a href="#PC4向PC3传输数据" class="headerlink" title="PC4向PC3传输数据"></a>PC4向PC3传输数据</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/5.png" srcset="/img/loading.gif" width="420px" height="250px"></p><h4 id="发送端："><a href="#发送端：" class="headerlink" title="发送端："></a>发送端：</h4><ol><li>应用层准备要传输的数据文件；</li><li>传输层把数据进行分段并编号；(数据段)</li><li>网络层把传输层的每一个数据包增加原IP地址和目标IP地址；(数据包)</li><li>数据链路层把每个数据加上MAC地址；(数据帧)</li><li>物理层把数据帧变成数字信号(bit流)</li></ol><p>如何通过Mac地址进行转发数据:</p><ul><li>使用本计算机地址的子网掩码，判断本地址和目标地址分别在哪个网段，若在同一个网段(不过路由器)，通过ARP协议广播的方式得到目标IP地址的MAC地址，然后就能封装出一个数据帧；</li><li>如果子网掩码不是一个网段(与运算)，通过ARP协议广播的方式得到路由器(网关)的MAC地址，然后把数据通过交换机发送到路由器M2，路由器M2在通过广播的方式得到目标IP地址与Mac地址。</li></ul><blockquote><p>因为M2和M3是点对点通信，没有别的主机，所以它们之间的MAC地址就是FF。</p></blockquote><h4 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h4><ol><li>交换机Hub0接收bit流，能对数据进行存储转发。它根据数据帧的MAC地址，确定数据是从哪来的，要去哪。</li><li>路由器M2获取交换机的数据包，识别其中的IP地址，根据路由表选择出口，它无法识别数据段内容。</li><li>路由器M2到M3是点对点通信，遵守PPP协议。</li><li>PC3收到bit流后，数据链路层发现MAC地址是自己的，去掉MAC地址给它的网络层，网络层去掉IP地址给传输层，传输层把数据给应用层，应用层把各个数据拼接起来，进而得到文件。</li></ol><h4 id="路由器与交换机、集线器会不会中病毒？"><a href="#路由器与交换机、集线器会不会中病毒？" class="headerlink" title="路由器与交换机、集线器会不会中病毒？"></a>路由器与交换机、集线器会不会中病毒？</h4><p>不会，因为路由器不能识别数据内容，只进行数据的传递，而交换机与集线器分别工作在数据链路层与物理层，更不会中病毒。但病毒可以影响网络设备的正常工作，例如频繁广播发送数据，占用带宽影响效率，使这些设备一直处于忙碌状态。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="TCP-IP协议层次关系"><a href="#TCP-IP协议层次关系" class="headerlink" title="TCP/IP协议层次关系"></a>TCP/IP协议层次关系</h3><p><img src="/2020/02/21/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0%E4%B8%8EARP%E5%8D%8F%E8%AE%AE/6.png" srcset="/img/loading.gif" width="420px" height="250px"></p><blockquote><p>ARP协议为IP协议提供服务，IP协议为ICMP与IGMP协议提供服务。</p><h3 id="ARP协议功能"><a href="#ARP协议功能" class="headerlink" title="ARP协议功能"></a>ARP协议功能</h3><p>将IP地址通过广播，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址，只能在本网段使用，ARP是解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射关系。<br>如果所找的主机和原主机不在同一个局域网上，那么就要通过ARP找一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。<br>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知情的，只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址。</p><p>arp -a可以查看本地解析过的Mac表缓存。<br>逆地址解析协议(RARP)：只知道自己MAC地址就能获得其IP地址。</p></blockquote><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>ARP欺骗的运作原理是由攻击者发送假的ARP数据包到网上，尤其是送到网关上。其目的是要让送至特定的IP地址的流量被错误送到攻击者所取代的地方。因此攻击者可将这些流量另行转送到真正的网关（被动式数据包嗅探，passive sniffing）或是篡改后再转送（中间人攻击，man-in-the-middle attack）。攻击者亦可将ARP数据包导到不存在的MAC地址以达到阻断服务攻击的效果，例如netcut软件。<br>例如：某一的IP地址是192.168.0.254，其MAC地址为00-11-22-33-44-55，网上上的计算机内ARP表会有这一笔ARP记录。攻击者发动攻击时，会大量发出已将192.168.0.254的MAC地址篡改为00-55-44-33-22-11的ARP数据包。那么网上上的计算机若将此伪造的ARP写入自身的ARP表后，计算机若要透过网上网关连到其他计算机时，数据包将被导到00-55-44-33-22-11这个MAC地址，因此攻击者可从此MAC地址截收到数据包，可篡改后再送回真正的网关，或是什么也不做，让网上无法连线。</p><h3 id="防止ARP欺骗的两种方法"><a href="#防止ARP欺骗的两种方法" class="headerlink" title="防止ARP欺骗的两种方法"></a>防止ARP欺骗的两种方法</h3><ol><li>静态绑定，使用arp -s 命令进行静态绑定，静态绑定后双方计算机通信不在使用ARP协议进行动态获取，可直接进行对目标计算机的通信。可将脚本命令编辑成.bat脚本，用gpedit.msc打开组策略，在开机登陆中添加该脚本，则脚本代码开机自动启动。</li><li>使用ARP防火墙进行防御。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac层与快速以太网</title>
    <link href="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Mac层与快速以太网"><a href="#Mac层与快速以太网" class="headerlink" title="Mac层与快速以太网"></a>Mac层与快速以太网</h1><h2 id="Mac层的硬件地址"><a href="#Mac层的硬件地址" class="headerlink" title="Mac层的硬件地址"></a>Mac层的硬件地址</h2><ul><li>在局域网中，硬件地址又称为物理地址，或Mac地址.</li><li>802标准所说的地址严格的讲应当是每一个站的名字或标识符.<br>但鉴于大家都已经习惯了将这种48位的名字称为地址，所以就采用了这种习惯用法。</li><li>IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节(即高位24位),地址字段中的后三个字节(即低位24位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址.</li><li>一个地址块可以生成2的24次方个不同的地址，这种48位地址称为Mac-48，它的通用名称是EUI-48.</li><li>Mac地址实际上就是适配器地址或适配器标识符EUI-48.</li></ul><h2 id="适配器检查Mac地址"><a href="#适配器检查Mac地址" class="headerlink" title="适配器检查Mac地址"></a>适配器检查Mac地址</h2><ol><li>适配器从网络上每收到一个Mac帧就首先用硬件检查Mac帧中的Mac地址</li><li>如果是发送本站的帧则收下，然后在进行其他的处理</li><li>否则就将此帧丢弃，不再进行其他的处理</li></ol><p>发送本站的帧，包括以下三种:</p><ul><li>单播帧 （一对一）</li><li>广播帧 （一对全体）</li><li>多播帧 （一对多）</li></ul><h2 id="Mac帧格式"><a href="#Mac帧格式" class="headerlink" title="Mac帧格式"></a>Mac帧格式</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="380px" height="220px"><br>前8个字节作用是实现比特同步，第一个字段共七个字节，称为前同步码，作用是实现快速Mac帧的比特同步。</p><h3 id="以太网V2的Mac帧格式"><a href="#以太网V2的Mac帧格式" class="headerlink" title="以太网V2的Mac帧格式"></a>以太网V2的Mac帧格式</h3><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="无效的Mac帧"><a href="#无效的Mac帧" class="headerlink" title="无效的Mac帧"></a>无效的Mac帧</h3><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>数据字段的长度不在46-1500字节之间</li><li>有效的Mac帧长度为64-1518字节之间</li><li>对于检查出的无效Mac帧就简单地丢弃。以太网不负责重传丢弃地帧。</li></ul><h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为9.6us，相当于96bit地的发送时间,一个站在检测到总线开始空闲后，还要等待9.6us才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层考虑扩展"><a href="#在物理层考虑扩展" class="headerlink" title="在物理层考虑扩展"></a>在物理层考虑扩展</h3><p><strong>距离扩展</strong>：<br>主机使用光纤和一对光纤调制解调器连接到集线器<br><strong>数量扩展</strong>：<br>集线器级联：使网络中计算机增加，变成一个大的冲突域，会造成效率降低</p><h4 id="用集线器扩展局域网优点"><a href="#用集线器扩展局域网优点" class="headerlink" title="用集线器扩展局域网优点"></a>用集线器扩展局域网优点</h4><ul><li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信</li><li>扩大了局域网覆盖的地理范围</li><li>用集线器扩展局域网缺点</li><li>碰撞域增大了，但总的吞吐量并未提高</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将他们互连起来</li></ul><h3 id="在数据链路层考虑扩展"><a href="#在数据链路层考虑扩展" class="headerlink" title="在数据链路层考虑扩展"></a>在数据链路层考虑扩展</h3><p>在数据链路层扩展局域网使用网桥</p><ul><li>网桥工作在数据链路层，它根据Mac帧的目的地址对收到的帧进行转发。</li><li>网桥具有过滤帧的功能和学习功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的Mac地址，然后再确定将该帧转发到哪一个接口</li></ul><p>优点：过滤通信量，扩大物理范围，提高可靠性，可互连不同物理层，不同Mac子层和不同速率。<br>缺点：存储转发增加了时延，在Mac子层并没有流量控制功能。具有不同Mac子层的网段桥接在一起时延更大，网桥只适合用户不太多和通信量不太大的局域网，否则有时还会因传播过多的广播信息导致网络拥塞。</p><h4 id="网桥自学习算法"><a href="#网桥自学习算法" class="headerlink" title="网桥自学习算法"></a>网桥自学习算法</h4><p>按照以下子学习算法处理收到的帧和建立转发表。</p><ul><li>若从A发出的帧从接口x进入到了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。</li><li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li><li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。</li><li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的，这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li></ul><blockquote><p>ps：网桥是交换机的前身，透明网桥：指局域网上的站点不知道所发送的帧将经过几个网桥，因为网桥对于各站点是看不见的，透明网桥使用生成树算法避免产生转发的帧在网络中成环。</p></blockquote><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>互联在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集中，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。<br>为了避免产生转发的帧在网络中不停兜圈子。<br>为了得出能够反应网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>随着网桥接口的增加，后来网桥和集线器合并了，计算机可以直接和交换机连接，这就是交换机。交换机就是网桥和集线器的合并版，能全双工，安全通信。</p><ul><li>端口带宽独享</li><li>安全</li><li>基于Mac地址转发</li><li>通过学习构建Mac地址表</li></ul><h2 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h2><h3 id="100BASE-T以太网"><a href="#100BASE-T以太网" class="headerlink" title="100BASE-T以太网"></a>100BASE-T以太网</h3><p>速率达到或超过100Mb/s的以太网称为高速以太网。<br>在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议。<br>100BASE-T以太网又称为快速以太网(Fast Ethernet)。</p><h4 id="100Base-T以太网的物理层："><a href="#100Base-T以太网的物理层：" class="headerlink" title="100Base-T以太网的物理层："></a>100Base-T以太网的物理层：</h4><ul><li>100BASE-TX ： 使用2对UTP5类线或屏蔽双绞线STP</li><li>100BASE-FX : 使用2对光纤</li><li>100BASE-T4 : 使用4对UTP3类线或5类线</li></ul><h4 id="100Base-T特点"><a href="#100Base-T特点" class="headerlink" title="100Base-T特点"></a>100Base-T特点</h4><ul><li>可在全双工方式下工作而无冲突发生，因此，不使用CSMA/CD协议。Mac帧格式仍然是802.3标准规定的。</li><li>保持最短帧长不变，但将一个网段的最大电缆长度减小到100m，帧间时间间隔从原来的9.6us改为现在的0.96us。</li></ul><h3 id="G比特以太网"><a href="#G比特以太网" class="headerlink" title="G比特以太网"></a>G比特以太网</h3><ul><li>允许在1GB/s下全双工和半双工两种方式工作</li><li>使用802.3协议规定的帧格式</li><li>在半双工方式下使用CSMA/CD协议(全双工方式不需要使用CSMA/CD协议)</li><li>与10BASE-T和100BASE-T技术 向后兼容</li><li>当G比特以太网工作 在全双工方式时,不使用载波延伸和分组突发</li></ul><h3 id="G比特以太网的物理层"><a href="#G比特以太网的物理层" class="headerlink" title="G比特以太网的物理层"></a>G比特以太网的物理层</h3><h4 id="1000BASE-x-基于光纤通道的物理层："><a href="#1000BASE-x-基于光纤通道的物理层：" class="headerlink" title="1000BASE-x 基于光纤通道的物理层："></a>1000BASE-x 基于光纤通道的物理层：</h4><ul><li>1000BASE-SX SX表示短波长 传输距离275或550米</li><li>1000BASE-LX LX表示长波长 550米或5000米</li><li>1000BASE-CX CX表示铜线 传输距离25米</li></ul><h4 id="1000BASE-T："><a href="#1000BASE-T：" class="headerlink" title="1000BASE-T："></a>1000BASE-T：</h4><ul><li>使用四对5类线UTP</li></ul><h4 id="G比特以太网配置举例"><a href="#G比特以太网配置举例" class="headerlink" title="G比特以太网配置举例"></a>G比特以太网配置举例</h4><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/4.png" srcset="/img/loading.gif" width="380px" height="220px"></p><h3 id="10G比特以太网"><a href="#10G比特以太网" class="headerlink" title="10G比特以太网"></a>10G比特以太网</h3><ul><li>同10Mb/s，100Mb/s，1Gb/s以太网的帧格式完全相同</li><li>保留了802.3标准规定的以太网最小和最大帧长，便于升级</li><li>不再使用铜线而只使用光纤作为传输媒体</li><li>只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议。</li></ul><h2 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h2><p>10G比特以太网的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输 。<br>这种工作方式的好处是：</p><ul><li>成熟的技术</li><li>互操作性很好</li><li>在广域网中使用以太网时价格便宜</li><li>统一的帧格式简化了操作和管理</li></ul><h2 id="Cisco建网3层模型"><a href="#Cisco建网3层模型" class="headerlink" title="Cisco建网3层模型"></a>Cisco建网3层模型</h2><p><img src="/2020/02/18/Mac%E5%B1%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91/5.png" srcset="/img/loading.gif" width="380px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以太网</title>
    <link href="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h2><ul><li>DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约。</li><li>IEEE 的802.3标准。</li></ul><blockquote><p>DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为以太网。<br>严格说来，以太网应当是指符合DIX Ethernet V2 标准的局域网</p></blockquote><h2 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h2><p>为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层.</p><ul><li>逻辑链路控制LLC(Logical Link Control)子层</li><li>媒体接入控制MAC(Medium Access Control)子层</li></ul><blockquote><p>与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。<br>由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路控制子层LLC(即802.2标准)的作用已经不大了.<br>很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。</p></blockquote><h2 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h2><ul><li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li><li>当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</li><li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li></ul><h2 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h2><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" srcset="/img/loading.gif" width="375px" height="220px"><br>传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不同电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。<br>这种以太网采用星型拓扑，在星型的中心则增加了一种可靠性非常高的设备，叫集线器。</p><h2 id="集线器的一些特点"><a href="#集线器的一些特点" class="headerlink" title="集线器的一些特点"></a>集线器的一些特点</h2><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线。</p><blockquote><p>集线器很像一个多接口的转发器，工作在物理层。</p></blockquote><h2 id="集线器连以太网定义的标准"><a href="#集线器连以太网定义的标准" class="headerlink" title="集线器连以太网定义的标准"></a>集线器连以太网定义的标准</h2><p>10BASE-T的通信距离稍短，每个站到集线器的距离不超过100m。<br>这种10Mb/s速率的无屏蔽双绞线星型网的出现，既降低了成本，又提高了可靠性。<br>10BASE-T双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p><blockquote><p>其他： 100Base-FX 100Base-T 100Base-T4</p></blockquote><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><h3 id="以太网的信道被占用的情况"><a href="#以太网的信道被占用的情况" class="headerlink" title="以太网的信道被占用的情况"></a>以太网的信道被占用的情况</h3><p><img src="/2020/02/15/%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>争用期长度为2γ，即端到端传播时延的两倍。碰撞到碰撞后不发送干扰信号。<br>帧长为L(bit)，数据发送速率为C(b/s)，因而帧的发送时间为L/C=T0(s).<br>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间γ使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p><h3 id="提高信道利用率"><a href="#提高信道利用率" class="headerlink" title="提高信道利用率"></a>提高信道利用率</h3><p>要提高以太网信道利用率，就必须减小γ与t0之比，以太网中定义了参数a，是以太网单程端到端时延γ与帧的发送时间t0之比:<br>a = γ/t0<br>a -&gt; 0表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a越大，表明争用期所占比例增大，每发生一次碰撞就浪费许多信道资源，使信道利用率明显降低。</p><h2 id="信道利用率最大值"><a href="#信道利用率最大值" class="headerlink" title="信道利用率最大值"></a>信道利用率最大值</h2><h3 id="对以太网参数的要求"><a href="#对以太网参数的要求" class="headerlink" title="对以太网参数的要求"></a>对以太网参数的要求</h3><ul><li>当数据率一定时，以太网的连线的长度受到限制否则γ的数值会太大</li><li>以太网的帧长不能太短，否则t0的值会太小，使a值太大。</li></ul><h3 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h3><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞(这显然已经不是CSMA/CD，而是需要使用一种特殊的调度算法)，即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是t0 + γ，而帧的本身的发送时间是t0，于是我们可计算理想情况下的极限信道利用率Smax为：<br>Smax = t0/t0 + γ = 1/1+a</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用广播信道的数据链路层</title>
    <link href="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="使用广播信道的数据链路层-局域网"><a href="#使用广播信道的数据链路层-局域网" class="headerlink" title="使用广播信道的数据链路层(局域网)"></a>使用广播信道的数据链路层(局域网)</h1><h2 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点:"></a>局域网最主要的特点:</h2><p>网络为一个单位所拥有，且地理范围和站点数目均有限。<br>局域网具有如下的一些主要优点：</p><ul><li>具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性，可用性和生存性。</li></ul><h2 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h2><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul><h3 id="动态媒体接入控制-多点接入"><a href="#动态媒体接入控制-多点接入" class="headerlink" title="动态媒体接入控制(多点接入)"></a>动态媒体接入控制(多点接入)</h3><ul><li>随机接入(主要被以太网采用)</li><li>受控接入 ,如多点线路探询，或轮询。(目前已不被采用)</li></ul><h2 id="认识以太网"><a href="#认识以太网" class="headerlink" title="认识以太网"></a>认识以太网</h2><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.png" srcset="/img/loading.gif" width="375px" height="220px"><br>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。<br>总线上的每一个工作的计算机都能检测到b发送的数据信号.<br>由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。<br>其他计算机都检测到不是发送给他们的数据帧，因此就丢弃这个数据帧而不能接收下来。<br>具有广播特性的总线上实现了一对一的通信。</p><h3 id="带冲突检测的载波监听-碰撞检测"><a href="#带冲突检测的载波监听-碰撞检测" class="headerlink" title="带冲突检测的载波监听/碰撞检测"></a>带冲突检测的载波监听/碰撞检测</h3><p><strong>CSMA/CD</strong>: Carrier Sense Multiple Access with Collision Detection<br><strong>多点接入</strong>: 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong>: 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><blockquote><p>载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号</p><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>碰撞检测就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)<br>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。<br>所谓碰撞就是发生了冲突，因此碰撞检测也被称为冲突检测</p></blockquote><p><strong>检测到碰撞后</strong>:<br>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。<br>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送.</p><h3 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h3><p><img src="/2020/02/15/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.png" srcset="/img/loading.gif" width="375px" height="220px"></p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信)。</li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>最先发送数据帧的站，在发送数据帧后至多经过时间2γ(2倍的端到端往返时延)就知道发送的数据帧是否遭受了碰撞。<br>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p><strong>以太网的争用期</strong>：</p><ul><li>以太网的端到端往返时延2γ称为争用期，或碰撞窗口。通常，取51.2us为争用期的长度。</li><li>对于10mb/s以太网，在争用期内可发送512bit，即64字节。</li><li>以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突。</li></ul><p><strong>最短有效帧长</strong>：</p><ul><li>如果发生冲突，就一定是在发送的前64字节之内。</li><li>由于一检测到冲突就立即终止发送，这时已经发送出去的数据一定小于64字节。</li><li>以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。</li></ul><h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟一个随机时间才能在发送数据。<br>确定基本退避时间，一般为争用期γ。<br>定义参数k<br>k = min[重传次数，10]<br>从整数集合[0,1…(2的k次方-1)]中随机地抽取一个数，记为r。重传所需的时延就是r倍的基本退避时间。<br>当重传达16次仍不能成功时即丢弃该帧，并向高层报告。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层基本概念及简单模型</title>
    <link href="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据链路层基本概念及简单模型"><a href="#数据链路层基本概念及简单模型" class="headerlink" title="数据链路层基本概念及简单模型"></a>数据链路层基本概念及简单模型</h1><p>数据链路层的简单模型:</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>数据链路层使用的信道主要有两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂，广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3 id="链路-link"><a href="#链路-link" class="headerlink" title="链路(link)"></a>链路(link)</h3><ul><li>一条点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分</li></ul><h3 id="数据链路-data-link"><a href="#数据链路-data-link" class="headerlink" title="数据链路(data link)"></a>数据链路(data link)</h3><p>除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路，现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层这两层的功能</p><blockquote><p>帧：数据，帧头，帧尾，物理层地址 校验值<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/3.png" srcset="/img/loading.gif" width="350px" height="200px"></p></blockquote><h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限，首部和尾部的一个重要作用就是进行帧定界。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/4.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输，如果传输的数据是ascii码中95个字符集时，一切正常，若传输的数据出现了EOT，被接收端误认为EOT前是一个帧，后面的当作无效帧丢弃。</p><h4 id="字节填充发解决透明传输的问题"><a href="#字节填充发解决透明传输的问题" class="headerlink" title="字节填充发解决透明传输的问题"></a>字节填充发解决透明传输的问题</h4><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转移字符“ESC”(16进制编码是1b).<br><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/5.png" srcset="/img/loading.gif" width="350px" height="200px"><br>字节填充或字符填充：接收端的数据链路层在将数据送往网络层之前删除插入的转义字符,如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。<br>当接受端收到连续的两个转义字符时，就删除其中前面的一个。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>传输过程中可能会产生比特差错，在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER，误码率与信噪比 有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测错数。常用循环冗余检验，在数据后面添加冗余码称为帧检验序列FCS(Frame Check Sequence).<br>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码.<br>FCS可以用CRC方法得出，但CRC并非用来获得FCS的唯一方法.</p><h2 id="使用点对点信道的数据链路层-广域网"><a href="#使用点对点信道的数据链路层-广域网" class="headerlink" title="使用点对点信道的数据链路层(广域网)"></a>使用点对点信道的数据链路层(广域网)</h2><p>1992年制定了ppp(Point-to-Point Protocol)协议，经过1993年和1994年的修订，现在的ppp协议已经成为因特网的正是标准,ppp协议有三个组成部分:</p><ul><li>数据链路层协议可以用于异步串行或同步串行介质</li><li>它使用LCP(链路控制协议)建立并维护数据链路连接</li><li>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/6.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>现在全世界使用最多的数据链路层协议是点对点协议ppp,用户使用拨号电话线接入因特网时，一般都是使用ppp协议.如图所示</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/7.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>ppp协议应该满足的要求:</p><ul><li>简单—首要要求</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul><p>ppp协议不需要满足的要求:</p><ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul><p>ppp协议帧格式</p><ul><li>标志字段F = 0x7E</li><li>地址字段A只置为0xFF 地址字段实际并不起作用</li><li>控制字段C通常置为0x03</li><li>ppp是面向字节的，所有的ppp帧长度都是整数字节</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B/8.png" srcset="/img/loading.gif" width="350px" height="200px"></p><h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><ul><li>将信息字段中出现的每个0x7E字节转变称为2字节序列0x7D 0x5E</li><li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列0x7D 0x5D</li><li>若信息字段出现ascii码的控制字符，则在该字符前面加入一个0x7D，同时将该字符的编码加以改变</li></ul><h3 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h3><p>ppp协议用在SONET/SDH链路时，是使用同步传输(一连串比特连续发送)。这时ppp协议采用零比特填充方法来实现透明传输。<br>在发送端，只要发现有5个连续1，则立即填入一个0(零比特填充法).接收端对帧中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后的一个0删除。</p><h3 id="ppp协议不使用序号和确认机制的原因"><a href="#ppp协议不使用序号和确认机制的原因" class="headerlink" title="ppp协议不使用序号和确认机制的原因"></a>ppp协议不使用序号和确认机制的原因</h3><ul><li>在数据链路层出现差错的概率不大时，使用比较简单的ppp协议较为合理。</li><li>在因特网环境下，ppp的信息字段放入的数据是ip数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列FCS字段可保证无差错接受。</li></ul><h3 id="ppp协议工作状态"><a href="#ppp协议工作状态" class="headerlink" title="ppp协议工作状态"></a>ppp协议工作状态</h3><ol><li>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接</li><li>PC机向路由器发送一系列的LCP分组(封装成多个ppp帧)。<br>这些分组及其响应选择一些ppp参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。</li><li>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址，接着，LCP释放数据链路层连接，最后释放的时物理层的连接。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字传输系统与宽带接入技术</title>
    <link href="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h1><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路的电话。由于历史原因，PCM有两个互不兼容的国际标准，即<strong>北美的24路PCM(简称为T1)</strong>和<strong>欧洲的30路PCM(简称为E1)</strong>，我国采用的是欧洲的E1标准。<br>E1的速率是2.048mb/s，而T1的速率是1.544Mb/s。<br>当需要有更高的数据率时，可采用复用的方法。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="400px" height="200px">&lt;/img&gt;<br>将用户的声波进行8000次采样，然后统计规整每个码元得到二进制代码。<br>E1电路(时分复用)<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="400px" height="200px"><br>T1电路<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)<br>例如</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="400px" height="200px">&lt;/img&gt;<br>标准模拟电话信号的频带被限制在300-3400hz范围内，但用户线本身实际可通过的信号频率仍然超过1Mhz。<br>xDSL技术就是把0-4Khz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h2><p>DMT调制技术采用频分复用的方法，将40kHZ以上一直到1.1MHz的高端频谱划分成许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道。<br>每个子信道占据4Khz带宽，并使用不同的载波(即不同的音调)进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p><p>频谱分布<br><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="光纤同轴混合网HFC-Hybrid-Fiber-Coax"><a href="#光纤同轴混合网HFC-Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网HFC(Hybrid Fiber Coax)"></a>光纤同轴混合网HFC(Hybrid Fiber Coax)</h2><p>HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除了可传送CATV外还提供电话，数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输，而HFC网则需要对CATV网进行改造。每个用户要安装一个用户接口盒。<br>优点 ： 具有很宽的频带，能够利用已有相当大的覆盖面的有线电视网</p><p><img src="/2020/02/07/%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="400px" height="200px"></p><h2 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h2><p>FTTx(光纤到…)也是一种实现宽带居民接入网的方案。<br>光纤到家FTTH(Fiber To The Home):光纤一直铺设到用户家庭可能是居民接入网最后的解决办法(155Mb/s).<br>光纤到大楼FTTB(Fiber To The Building): 光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br>光纤到路边FTTC(Fiber To The Curb): 从路边到各用户可使用星型结构双绞线作为传输媒体(155mb/s)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输媒体与信道复用技术</title>
    <link href="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><h2 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h2><ul><li>双绞线<ul><li>屏蔽双绞线STP</li><li>无屏蔽双绞线UTP</li></ul></li><li>同轴电缆<ul><li><strong>50Ω同轴电缆</strong>用于数字传输，由于多用于基带传输，也叫基带同轴电缆。</li><li><strong>75Ω同轴电缆</strong>用于模拟传输，即宽带同轴电缆。</li></ul></li><li>光缆<ul><li>光缆是一定数量的光纤按照一定方式组成缆心，外包有护套，有的还包覆外护层，用以实现光信号传输的一种通信线路。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><blockquote><p>导向传输媒体中，电磁波沿着固体媒体传播。</p><h2 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h2><p>非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。<br>无线传输使用的频段很广，例如以下两种：</p></blockquote><ul><li>短波通信主要靠电离层的反射，但短波通信的通信质量较差。</li><li>微波在空间主要是直线传播，例如地面微波接力通信，卫星通信。</li></ul><h3 id="电信领域使用的电磁波的频谱"><a href="#电信领域使用的电磁波的频谱" class="headerlink" title="电信领域使用的电磁波的频谱"></a>电信领域使用的电磁波的频谱</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><h3 id="网线"><a href="#网线" class="headerlink" title="网线"></a>网线</h3><ul><li>直通线<ul><li>主机到交换机或集线器<ul><li>路由器到交换机或集线器</li></ul></li></ul></li><li>交叉电缆<ul><li>交换机到交换机</li><li>集线器到集线器</li><li>主机到主机</li><li>集线器到交换机</li><li>路由器直连到主机</li></ul></li></ul><h4 id="线序制作方法"><a href="#线序制作方法" class="headerlink" title="线序制作方法"></a>线序制作方法</h4><ul><li>直通线：双绞线夹线顺序两边一致，1.橙白、2.橙、3.绿白、4.蓝、5.蓝白、6.绿、7.棕白、8.棕，两端都是同样的线序且一一对应，即568B标准，也就是正线或标准线、直通线。</li><li>交叉电缆: 1、2号线与3、6号线交叉传送，也就是568A标准。<blockquote><p>568A: 绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</p></blockquote></li></ul><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>单模光纤，只能传输一种电磁波模式，光纤细，传播特性好，有线电视网络中使用的都是单模光纤，带宽可达10GHZ，可以在一根光纤中传输60套PAL—D电视节目。</li><li>多模光纤，只可以传输多个电磁波模式，光纤粗。</li></ul><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>工作特点：它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。<br>最大传输距离： 100m</p><blockquote><p>集线器是一个大的冲突域。</p></blockquote><hr><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h3 id="基础模型图"><a href="#基础模型图" class="headerlink" title="基础模型图"></a>基础模型图</h3><p><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>频分复用FDM(Frequency Division Multiplexing),用户分配到一定的频带后，在通信过程中始终占用这个频带。频带复用的所有用户在同样的时间占用不同的带宽资源(这里带宽指频率带宽不是数据发送速率)。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="300px" height="150px">&lt;/img&gt;<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>时分复用TDM(Time Division Multiplexing),将时间划分为一段段等长的时分复用帧(TDM)帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性出现的(周期就是TDM帧的长度对应的时间)。<br>TDM信号也称为等时信号，时分复用的所有用户是在不同的时间占用相同的频带宽度。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>统计时分复用STDM(Statistic TDM)，由于时分复用可能造成线路资源浪费，使用时分复用系统传输计算机数据时，由于计算机数据突发性，用户对分配的子信道利用率一般不高，所以用统计时分复用去解决，也就是给每一个用户的信息加标记去区分用户的信息。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用WDM(Wavalength Division Multiplexing)，波分复用也就是光的频分复用。<br><img src="/2020/01/29/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/10.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信道的基本概念</title>
    <link href="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="信道简介"><a href="#信道简介" class="headerlink" title="信道简介"></a>信道简介</h2><p>信道一般表示向一个方向传送信息的媒体。所以通信线路往往包含一条发送信息的信号和一条接收信息的信道</p><ul><li>单向通信(单工通信)，只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信，通信的双方都可以发送信息，但不能同时发送和接受信息</li><li>双向同时通信，通信的双方可以同时发送和接受信息</li></ul><h2 id="基带信号和带通信号"><a href="#基带信号和带通信号" class="headerlink" title="基带信号和带通信号"></a>基带信号和带通信号</h2><ul><li>基带信号(baseband，即基本频带信号)，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如说话的声波就是基带信号。</li><li>带通信号(bandpass)，把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段，以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li></ul><p>因此在传输距离较近时，计算机网络采用基带传输方式，因为近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p><h3 id="几种最基本的调制方法"><a href="#几种最基本的调制方法" class="headerlink" title="几种最基本的调制方法"></a>几种最基本的调制方法</h3><ul><li>调幅(AM): 载波的振幅随基带数字信号而变化。</li><li>调频(FM): 载波的频率随基带数字信号而变化。</li><li>调相(PM): 载波的初始相位随基带数字信号而变化。</li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>单极性不归零码<ul><li>只使用一个电压值，用高电平表示1，没电压表示0.</li></ul></li><li>双极性不归零码<ul><li>用正电平和负电平分别表示二进制数据的1和0，正负幅值相等。</li></ul></li><li>单极性归零码<ul><li>以高电平和零电平分别表示二进制码1和0，而且在发送吗1时高电平在整个码元期间T只持续一段时间γ，其余时间返回零电平</li></ul></li><li>双极性归零码<ul><li>正负零三个电平，信号本身携带同步信息。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.png" srcset="/img/loading.gif" width="300px" height="150px"></p><ul><li>曼彻斯特编码<ul><li>位中间有信号时，低电位变高电位为0，高电位变低电位为1。</li><li>采用这种编码，一个时钟周期只可表示一个位，并且必须通过两次采样才能得到一个位的值，但它能携带时钟信号，且可表示没有数据传输。</li></ul></li><li>差分曼彻斯特编码<ul><li>bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0.bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1.</li><li>差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性强于曼彻斯特编码。</li></ul></li></ul><p><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.png" srcset="/img/loading.gif" width="300px" height="150px"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>发送的信号波形通过实际的信道时会受到带宽、噪音、干扰等影响而失真，如果失真较小依旧可以识别并且纠正，如果失真较大则无法识别。</p><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>1924年，Nyquist推导出著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的识别成为不可能。<br>如果信道的频带越宽，也就是能通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>Shannon用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。<br>信道的极限信息传输速率C可以表示为<br>C = W log2(1+S/N) b/s log以2为底</p><ul><li>W为信道的带宽(单位hz)</li><li>S为信道内所传信号的平均功率</li><li>N为信道内部的高斯噪声功率</li></ul><blockquote><ul><li>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li><li>若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率C也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香浓的极限传输速率低不少。<h3 id="奈氏准则和香农公式的应用范围"><a href="#奈氏准则和香农公式的应用范围" class="headerlink" title="奈氏准则和香农公式的应用范围"></a>奈氏准则和香农公式的应用范围</h3>奈氏准则表示没有信号干扰，码元的传输速率有上限。<br>香浓公式表示有信号干扰，无差错传输速率的理论极限。<br><img src="/2020/01/29/%E4%BF%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.png" srcset="/img/loading.gif" width="300px" height="150px"></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层概念与数据通信基础</title>
    <link href="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。<br>物理层的主要任务描述为： 确定传输媒体的接口的一些特性即：</p><ul><li>机械特性：例接口形状，大小，引线数目</li><li>电气特性：例规定电压范围（-5v，+5v）</li><li>功能特性：例规定-5v表示0，+5v表示1</li><li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>链接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>数据通信领域中，数字信道所能传送的最高数据率，单位b/s，kb/s，mb/s，gb/s。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>即在单位时间内通过某个网络的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li>发送时延 = 数据块长度(bit)/信道带宽(bit/s) 信号波完全传播完</li><li>传播时延 传播的过程所用时间</li><li>处理时延 收到信号波后处理时间</li><li>排队时延 多个信号排队等待时间</li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 = 传播时延 * 带宽 （传播时线路上有多少bit）</p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>从发送方发送数据开始，到发送方收到接收方确认</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul><li>信道利用率 = 有数据通过时间/有无数据通过时间</li><li>网络利用率 = 信道利用率加权平均值<br>D = D0 / （1-U） D0:网络空闲时的时延，D:网络当前时延，U: 信道利用率</li></ul><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基本模型"><a href="#数据通信基本模型" class="headerlink" title="数据通信基本模型"></a>数据通信基本模型</h3><p><img src="/2020/01/21/%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/1.png" srcset="/img/loading.gif" width="350px" height="150px"></p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>数据(data)— 运送消息的实体</li><li>信号(signal)—数据的电气或电磁的表现</li><li>“模拟信号”—代表消息的参数的取值是连续的。</li><li>“数字信号”—代表消息的参数的取值是离散的。</li><li>码元(code)—在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度，1码元可以携带nbit的信息量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高斯约旦消元法</title>
    <link href="/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/"/>
    <url>/2020/01/16/%E9%AB%98%E6%96%AF%E7%BA%A6%E6%97%A6%E6%B6%88%E5%85%83%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h1><p>矩阵更准确的说是对线性系统的描述，所谓的线性系统指的是例如3x + 4y + z = 8之类的线性方程组，未知数只能是一次方项。而非线性方程则例如sin(x) = Π等坐标图上呈曲线的方程组。</p><h2 id="消元法解线性方程"><a href="#消元法解线性方程" class="headerlink" title="消元法解线性方程"></a>消元法解线性方程</h2><p>在小学初中我们学过如何用消元法解线性方程组，例如x + y = 2；2x + 3y = 12；的线性方程组，我们可以用第二个方程减去二倍的第一个方程，然后便可以消去x，得到y的值，然后将y带入第一个方程，我们便可以得到x与y的值，即线性方程组的解。</p><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>学习矩阵的概念之后，我们可以将方程组的系数拿下来组成系数矩阵，然后基于矩阵的操作去得到线性方程组的解，例如x + y + z = 6；2x + y + z = 7；x + y + 2z = 9;将其系数拿下来之后，我们可以得到矩阵<br>1 1 1<br>2 1 1<br>1 1 2<br>将方程组的结果也拿下来可以得到该矩阵的增广矩阵<br>1 1 1 | 6<br>2 1 1 | 7<br>1 1 2 | 9<br>经过第二行减二倍的第一行后，我们可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>1 1 2 | 9<br>然后用第三行减去第一行，可以得到<br>1 1 1 | 6<br>0 -1 -1 |-5<br>0 0 1 | 3<br>将第二行乘以-1，可以得到最终的矩阵<br>1 1 1 | 6<br>0 1 1 | 5<br>0 0 1 | 3<br>此矩阵最后一行的1则代表z的值，通过回代，便可得到x与y的值。通过观察，我们可以发现结果矩阵的对角线元素都为1，而矩阵的下一行总比上一行多一个0，我们将每一行的第一个1称为此行的主元，我们把第i-1行根据第i行的主元进而不断消去一个未知数的方法称为高斯消元法。</p><h2 id="高斯约旦消元法"><a href="#高斯约旦消元法" class="headerlink" title="高斯约旦消元法"></a>高斯约旦消元法</h2><p>通过以上的消元,最终我们只能得到最后一个未知数的值，上述矩阵，可以写成以下方程组<br>x + y + z =6;<br>y + z = 5;<br>z = 3;<br>通过回代的方式，可以得到x，y，z的值，但还是有一些麻烦。针对此矩阵，我们还可以在进行变换，将第二行减去第三行可得<br>1 1 1 | 6<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第三行可得<br>1 1 0 | 3<br>0 1 0 | 2<br>0 0 1 | 3<br>将第一行减去第二行可得<br>1 0 0 | 1<br>0 1 0 | 2<br>0 0 1 | 3<br>进行这样的变换后，便可以直观的看出x，y，z的值，而坐标的系数矩阵则化成了单位矩阵，这种向下消元然后向上消元的方法被称为高斯约旦法。主要分为两个过程：</p><h3 id="前向过程-从上到下"><a href="#前向过程-从上到下" class="headerlink" title="前向过程(从上到下)"></a>前向过程(从上到下)</h3><ol><li>选择最上的主元，化为1</li><li>主元下面的所有行减去主元所在行的某个倍数，使得主元下面所有元素都为0</li></ol><h3 id="后向过程-从下到上"><a href="#后向过程-从下到上" class="headerlink" title="后向过程(从下到上)"></a>后向过程(从下到上)</h3><ol><li>选择最下的主元</li><li>主元上面的所有行减去主元所在行的某个倍数，使得主元上面所有元素都为0</li></ol><h3 id="python代码演示"><a href="#python代码演示" class="headerlink" title="python代码演示"></a>python代码演示</h3><pre><code>from .Matrix import Matrixfrom .Vector import Vectorclass LinearSystem:    def __init__(self,A,b):        assert A.row_num() == len(b),&quot;row number of A must be equal to the length&quot;        self._m = A.row_num()        self._n = A.col_num()        assert self._m == self._n # TODO: no this restriction        self.Ab = [Vector(A.row_vector(i).underlying_list()+[b[i]])                   for i in range(self._m)]    def _max_row(self,index,n):        best,ret = self.Ab[index][index],index        for i in range(index + 1,n):            if self.Ab[i][index] &lt; best:                best,ret = self.Ab[i][index],i        return ret    def _forward(self):        n = self._m        for i in range(n):            # Ab[i][i]为主元            max_row = self._max_row(i,n)            self.Ab[i],self.Ab[max_row] = self.Ab[max_row],self.Ab[i]            # 将主元归一            self.Ab[i] = self.Ab[i] / self.Ab[i][i] #TODO: self.Ab[i][i] == 0            for j in range(i+1,n):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def _backward(self):        n = self._m        for i in range(n-1,-1,-1):            for j in range(i-1,-1,-1):                self.Ab[j] = self.Ab[j] - self.Ab[j][i] * self.Ab[i]    def gauss_jordan_elimination(self):        self._forward()        self._backward()    def fancy_print(self):        for i in range(self._m):            print(&quot; &quot;.join(str(self.Ab[i][j]) for j in range(self._n)),end=&quot; &quot;)            print(&quot;|&quot;,self.Ab[i][-1])</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code>from playLA.Matrix import Matrixfrom playLA.Vector import Vectorfrom playLA.LinearSystem import LinearSystemif __name__ == &quot;__main__&quot;:    A = Matrix([[1,1,1],[2,1,1],[1,1,2]])    b = Vector([6,7,9])    Ab = LinearSystem(A,b)    Ab.gauss_jordan_elimination()    Ab.fancy_print()</code></pre><h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h3><p>课程名称: 专给程序员设计的线性代数<br>作者: bobo老师 —ACM亚洲区奖牌获得者</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础与OSI参考模型</title>
    <link href="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="局域网与广域网"><a href="#局域网与广域网" class="headerlink" title="局域网与广域网"></a>局域网与广域网</h2><h3 id="局域网："><a href="#局域网：" class="headerlink" title="局域网："></a><strong>局域网</strong>：</h3><p>局域网是一种私有网络，一般在一座建筑物内或建筑物附近，比如家庭、办公室或工厂。局域网络被广泛用来连接个人计算机和消费类电子设备，使它们能够共享资源和交换信息。当局域网被用于公司时，它们就称为企业网络。</p><blockquote><p>特点：覆盖范围小，设备自己购买，带宽固定，自己维护。</p></blockquote><h3 id="广域网："><a href="#广域网：" class="headerlink" title="广域网："></a><strong>广域网</strong>：</h3><p>在一个区域范围里超过集线器所连接的距离时，必须要通过路由器来连接，这种网上类型称为广域网。如果有北、中、南等分公司，甚至海外分公司，把这些分公司以专线方式连接起来，即称为“广域网”，广域网由各大运行商进行维护和建设，覆盖范围广，给用户提供服务。</p><blockquote><p>解释：ISP(Internet Service Provider)：互联网服务提供商。每个运行商都有自家的机房，各互联网公司通过租用运行商机房里的服务器，搭建自己的公司网站，所以电信网络访问在电信机房的网站就会快很多。为了避免因服务器所属不同产生的网络访问慢的问题，也有了双线机房的诞生，即多个运行商共有一个机房。</p></blockquote><h3 id="Internet："><a href="#Internet：" class="headerlink" title="Internet："></a><strong>Internet</strong>：</h3><p>internet表示的意思是互联网，又称网际网路，根据音译也被叫做因特网(Internet)、英特网，是网络与网络之间所串连成的庞大网络。这些网络以一组通用的协议相连，形成逻辑上的单一且巨大的全球化网络，在这个网络中有交换机、路由器等网络设备、各种不同的连接链路、种类繁多的服务器和数不尽的计算机、终端。</p><blockquote><p>中国互联网由电信，移动，联通，网通等等运行商组成，用户可以通过各地运行商提供的接口进而访问到全国互联网，并且各运行商提供与国外互联网的接口，进而访问全球互联网.</p></blockquote><h2 id="互联网如何进行数据的传输？"><a href="#互联网如何进行数据的传输？" class="headerlink" title="互联网如何进行数据的传输？"></a>互联网如何进行数据的传输？</h2><h3 id="数据帧与数据包"><a href="#数据帧与数据包" class="headerlink" title="数据帧与数据包"></a>数据帧与数据包</h3><p>每个网络都有属于自己的ip地址，每台设备也有唯一的Mac地址。当用户访问网站时，需要将域名传输给DNS，然后DNS返回相应的IP地址，然后将数据和本机IP地址以及目标IP地址进行打包(数据包)，为了将数据包通过路由器进行传输，还需要将当前mac地址以及下一个路由器的mac地址同样打包进去(数据帧),通过不断改变mac地址，进而将数据传输给服务器。</p><blockquote><p>DNS:域名解析服务器</p></blockquote><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><ul><li>应用层 所有能产生网络流量的程序</li><li>表示层 在传输之前是否进行加密或压缩处理，二进制或ASCII表示</li><li>会话层 浏览器与网站服务器建立会话，确保服务器传输来的信息渲染相对的页面 可以通过对话查木马 netstat -n</li><li>传输层 可靠传输 流量控制 不可靠传输(不需要建立会话，一个数据包便可完成交流)</li><li>网络层 负责选择最佳路径，规划IP地址</li><li>数据链路层 帧的开始和结束如何定义 透明传输 差错校验</li><li>物理层 接口标准(网线) 电器标准 如何在物理链路上传输更快的速度</li></ul><h3 id="OSI参考模型对网络排错指导"><a href="#OSI参考模型对网络排错指导" class="headerlink" title="OSI参考模型对网络排错指导"></a>OSI参考模型对网络排错指导</h3><ol><li>物理层故障 查看连接状态 发送和接受数据包</li><li>数据链路层故障 MAC冲突 ADSL欠费 网速没办法协商一致 计算机连接到错误的VLAN</li><li>网络层故障 配置错误的IP地址 子网掩码 配置错误的网关 路由器没有配置到达目标网络的路由</li><li>应用层故障 应用程序配置错误</li></ol><h3 id="OSI参考模型和网络安全"><a href="#OSI参考模型和网络安全" class="headerlink" title="OSI参考模型和网络安全"></a>OSI参考模型和网络安全</h3><ol><li>物理层安全</li><li>数据链路层安全 ADSL账号密码 VLAN交换机端口绑定MAC地址</li><li>网络层安全 在路由器上使用ACL控制数据包流量</li><li>应用层安全 开发的应用程序没有漏洞</li></ol><h3 id="OSI参考模型与TCP-IP"><a href="#OSI参考模型与TCP-IP" class="headerlink" title="OSI参考模型与TCP_IP"></a>OSI参考模型与TCP_IP</h3><p><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/1.png" srcset="/img/loading.gif" width="300px" height="150px">&lt;/img&gt;<br><img src="/2020/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" width="300px" height="150px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubantu配置django开发环境</title>
    <link href="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><ol><li>Ubantu镜像</li><li>Python3</li><li>pip3</li><li>pymysql</li><li>Django2.2</li><li>Mysql数据库</li><li>virtualenv虚拟环境</li></ol><h3 id="在VirtualBox上安装Ubantu操作系统"><a href="#在VirtualBox上安装Ubantu操作系统" class="headerlink" title="在VirtualBox上安装Ubantu操作系统"></a>在VirtualBox上安装Ubantu操作系统</h3><p>新建虚拟机，选择类型linux,选择版本ubantu64-bit，分配内存4gb，选择创建虚拟硬盘，配置好之后，在设置里，设置显存大小128m，启动3d加速.<br><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2.png" srcset="/img/loading.gif" width="400px" height="250px"><br>应用设置，并启动系统，再开始界面选择需要导入的ios镜像，进入ubantu安装界面，并完成安装指导，建议自己分区。<br>ubantu系统内已配置python3，所以只需要安装后续软件即可。<br>进入系统后打开terminal，首先输入dpkg -l 查看已安装软件，是否有python，如果有则不需要再安装python。</p><h3 id="安装pip3"><a href="#安装pip3" class="headerlink" title="安装pip3"></a>安装pip3</h3><pre><code>sudo apt-get update        //更新软件源sudo apt-get install python3-pip  pip3 --version  //查看版本sudo pip3 list //查看已安装的lib</code></pre><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><pre><code>sudo apt-get install mysql-server mysql-clientsudo service mysql restartmysql -uroot -p        //进入mysql命令界面</code></pre><p><img src="/2020/01/15/ubantu%E9%85%8D%E7%BD%AEdjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/3.png" srcset="/img/loading.gif" width="400px" height="250px"></p><h3 id="安装pymysql"><a href="#安装pymysql" class="headerlink" title="安装pymysql"></a>安装pymysql</h3><pre><code>pip3 install pymysql</code></pre><h3 id="安装virtualenv与virtualenvwrapper"><a href="#安装virtualenv与virtualenvwrapper" class="headerlink" title="安装virtualenv与virtualenvwrapper"></a>安装virtualenv与virtualenvwrapper</h3><pre><code>sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper</code></pre><p>安装好virtualenvwrapper后还无法使用，创建目录存放虚拟环境</p><pre><code>mkdir $HOME/.virtualenvs</code></pre><p>在~/.bashrc中添加</p><pre><code>export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh</code></pre><p>运行</p><pre><code>source ~/.bashrc</code></pre><p>创建python3虚拟环境</p><pre><code>mkvirtualenv -p 路径 /usr/bin/pythonX删除:rmvirtualenv 虚拟环境名称进入: workon 虚拟环境名称</code></pre><p>其他命令</p><pre><code>python -v  //进度python命令终端deactivate //退出虚拟环境pip freeze 查看虚拟环境安装的包</code></pre><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><pre><code>pip install Django==1.11.7django-admin startproject xxx 创建项目python manage.py startapp xxx 创建一个应用</code></pre><p>执行 python manage.py runserver 访问localhost:8000,看到it works则项目启动成功！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>英语短语整理</title>
    <link href="/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/"/>
    <url>/2020/01/15/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="英语短语整理"><a href="#英语短语整理" class="headerlink" title="英语短语整理"></a>英语短语整理</h2><hr><h3 id="1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan"><a href="#1-Queen-Agrees-to-Period-of-Transition-for-Harry-and-Meghan" class="headerlink" title="1.Queen Agrees to Period of Transition for Harry and Meghan."></a>1.Queen Agrees to Period of Transition for Harry and Meghan.</h3><ul><li>forge a new life 创造新生活</li><li>period of transistion 过渡期</li><li>following a day of … 什么事情之后的一天</li><li>thrown … into turmoil 引起骚乱</li><li>Britain’s monarchy 英国君主制</li><li>dominated the headlines for days 占据头条</li><li>remote prospect 机会渺茫</li><li>carve out 创造雕刻</li><li>back away from 躲开</li><li>in the coming days 在未来几天</li><li>make clear that 明确表示</li><li>be reliant on 依赖</li><li>on the lookout 注意，留心</li><li>cash in 从中牟利，捞到好处</li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冯诺依曼体系</title>
    <link href="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/"/>
    <url>/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-zNiymjWj" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="477417503" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="冯诺依曼简介"><a href="#冯诺依曼简介" class="headerlink" title="冯诺依曼简介"></a>冯诺依曼简介</h2><p>约翰·冯·诺依曼，美籍匈牙利数学家、计算机科学家、物理学家，毕业于苏黎世联邦工业大学，他是现代电子计算机与博弈论的重要创始人，被后人称为现代计算机之父、博弈论之父，并且他还改善了著名的蒙特卡洛算法。<br>1945年6月约翰·冯·诺依曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”。在报告中冯·诺伊曼明确提出了计算机的体系架构。从1951年第一台电子计算机EDVAC开始，计算机经历了多次的更新换代，不管是最原始的、还是最先进的计算机，使用的仍然是冯·诺依曼最初设计的计算机体系结构。因此冯·诺依曼被世界公认为“计算机之父”，他设计的计算机系统结构，称为“冯诺依曼体系结构”。</p><h2 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h2><p>冯诺依曼体系结构主要由五大部分组成，分别是控制器，运算器，存储器，输入设备和输出设备。至今为止，基本上所有的计算机也是遵循冯诺依曼体系所设计的，例如我们经常使用的手机，电脑，平板等等。<br>冯诺依曼提出的两个重要的思想，一个是存储程序的思想，另一个是二进制的思想，这两个思想在如今的计算机领域影响深远。<br>世界上第一台计算机EDVAC，采用了上千个电子管所设计的，体积十分庞大，设计者采用十进制对指令和数据进行计算处理，但执行过程复杂，运行效率慢。十进制与二进制的区别在哪？冯诺依曼为何提出二进制的存储思想呢？因为在早期的计算机电子元件设计中，通常使用高低电压来表示信息，即高电压为1，低电压为0.所以如果要采用十进制进行数据的计算，将二进制信息转换成我们日常所熟悉的十进制后再去进行处理，大大增加了计算机指令的设计难度，而使用二进制则解决了这一问题，后世很多科学家也提出了二进制浮点数的计算，以及反码补码阶码的概念，使二进制成为了计算机设计的中心。所以在今后的计算机中无论是指令还是数据都采用二进制的方式进行存储和计算。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/1.jpg" srcset="/img/loading.gif" width="375px" height="220px"><br>通常我们使用的计算机主要功能是负责运算，所以在冯诺依曼体系中以运算器为中心，而存储器负责存放指令和数据，指令和数据的计算和存储以及外部设备的连接也需要通过控制器进行控制。让我们排除输入输出设备之后，其实运算器，存储器和控制器才是整个计算机的核心，我们可以将三者看作一个黑箱子。当我们输入数据时，数据通过黑箱子，然后输出我们想要的结果，这便是图灵机的简单模型。</p><h2 id="冯诺依曼体系的特点"><a href="#冯诺依曼体系的特点" class="headerlink" title="冯诺依曼体系的特点"></a>冯诺依曼体系的特点</h2><ol><li>计算机由五大部件组成，运算器，存储器，控制器，输入设备，输出设备。</li><li>指令和数据采用二进制方式进行存储。</li><li>指令由地址码和操作码组成。</li><li>运算器为中心。</li><li>存储程序为主要思想。</li><li>指令和数据都以同等地位存入存储器，并且可按地址访问。</li></ol><h2 id="冯诺依曼体系结构的改进"><a href="#冯诺依曼体系结构的改进" class="headerlink" title="冯诺依曼体系结构的改进"></a>冯诺依曼体系结构的改进</h2><p>如上图所示，输入设备如果需要从存储器中存储信息，必须经过运算器，因此运算器可能成为计算机速度的瓶颈，如果可以使输入设备不经过运算器，直接访问存储器，可以减少运算器的工作量，因此有了以下以存储器为中心的结构。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/2.png" srcset="/img/loading.gif" width="375px" height="220px">&lt;/img&gt;<br>由于现代计算机分为运算器，控制器，存储器，输入设备，输出设备。运算器(ALU)与控制器(CU)合并为CPU，存储器分为主存与辅存，CPU与存储器构成主机部分，主机与IO设备构成计算机硬件，可以根据计算机的层次进行设计。<br><img src="/2020/01/14/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB/3.png" srcset="/img/loading.gif" width="375px" height="220px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心情随笔</title>
    <link href="/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/01/12/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="aplayer-nomsZhcg" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1352045760" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近越来越喜欢写博客了，感觉就是自己向自己倾诉一样，或许这也是一些感情的寄托吧。自从参加了两次数学建模比赛，也发现自己的写作能力开始慢慢变强了，同时也明白了为什么有一些人喜欢写日记，因为这也是记录自己点点滴滴的一种方式吧，能让自己感觉到存在的意义。<br>自从大学以后感觉更加孤独了，学技术是寂寞的，枯燥的，只有做出一些作品，才会带给自己很多真实的成就感。这种感觉很奇妙，能让自己感觉到充实，感觉自己是活着的，感觉自己的人生是有意义的。</p><h2 id="倾诉"><a href="#倾诉" class="headerlink" title="倾诉"></a>倾诉</h2><p>最近学校放寒假了，也回家了。回家后避免不了受到父母的各种唠叨，以及亲戚朋友各种“友善”的人生建议，感觉活着越来越累了，想要变的优越一些，但又克服不了那些臭毛病，想要脱单，但心里没有什么喜欢的人，也没人喜欢，自卑在心底已经生根发芽了，最终想想罢了，还是回归现实吧。<br>回家后听到亲戚朋友闲聊，听说别人家的孩子现在创办了公司，一年盈利几百万。听说别人家的孩子最近考上了研究生，毕业以后也不用担心了。听说别人家的孩子，今年高考考进了名牌大学。听说别人家的孩子最近又出国了。听说别人家的孩子……<br>而自己呢？<br>越来越焦虑了，其实我只想当一个普通人罢了，但现在普通人的标准貌似也越来越高了，学习计算机对于父母而言，只不过是整日坐在电脑旁边虚度光阴罢了。挣扎着想要反驳一些什么，想想觉得还是算了，只会让自己更累。</p><blockquote><p>二十而立，三十不惑，四十知天命，如今自己刚过二十岁年纪，却感觉心里已经更老了十岁，人生就是这样，得过且过，顺其自然吧</p></blockquote><hr><p>抱怨就到这里，谈谈未来的人生规划和目标。</p><hr><ol><li>努力学习，考研计算机方向</li><li>毕业后好好工作，乐观生活</li><li>有一套属于自己的小房子</li><li>养一只猫</li><li>吃好喝好</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研的想法</title>
    <link href="/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2020/01/11/%E8%80%83%E7%A0%94%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇博客只是阐述以下我最近的想法，估计大部分人也不会看我的博客。如果有人不幸看到了的话，可以给我一些建议，谢谢。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>由于高考失利，加上地区政策要合并二三本等等，高考失败后没有复读，而是去选择上民办的三本学校（虽然现在已经没三本了），然后选择了计算机科学专业，因为我本身也是比较喜欢编程的，开学后就开始自学编程语言，做一些小程序。</p><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>刚开始我并没有考研的想法，只想着努力学技术，毕业后靠技术吃饭，我一直认为IT这个行业跟学历的关系并不大，只要你的技术强硬，一些大厂总有机会进去，工资也会很高。于是我就去学安卓，学网站等等，自学了不少东西，也做过一些demo。但由于只学专业课，我数学英语都不怎么好，四级也没过，只有专业课还凑合。</p><h2 id="考研想法的由来"><a href="#考研想法的由来" class="headerlink" title="考研想法的由来"></a>考研想法的由来</h2><p>目前大二上学期已经结束了，前一段时间跟我的专业课老师交流，他跟我聊他以前做的很多项目，那些项目都需要用一些复杂的算法去实现，还需要对计算机的深入理解，都是一些偏底层的东西，比如有关卫星，燃气，有色金属等等的项目。<br>然后我问他关于毕业工作的问题，需要学习多少技术，毕业后需不需要再去培训。<br>他给我分析了目前社会上的一些培训班，他们培训的东西都是一些java的电商项目，web前端等等，连微服务都涉及不到，至于培训python与人工智能的，大部分也是涉及较浅，用处不大。而且这些新技术、新框架过时的也很快。这些东西完全可以自学没必要报培训班。<br>建议我如果深入学计算机，想未来爬的高一点，还是需要考研的。</p><h2 id="如何考研？"><a href="#如何考研？" class="headerlink" title="如何考研？"></a>如何考研？</h2><p>在此之后我考研的念头就萌发了，这些天我一直在想一个问题，作为一个好歹算是科班出身的毕业生，我并不想学了四年结果毕业后和培训班一年出来的人一样的水准，甚至还不如。所以我毅然决定考研，如今遇到以下问题。</p><ul><li>1.三本学生如何选择考研学校？</li><li>2.基础薄弱怎么规划自己的学习?</li><li>3.现阶段应该怎么准备？</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>由于我也是比较现实的人，对自己的能力有所认知，所以我并不打算去考一些985，211名校，但也希望尽量上一个cs专业强一点的普通一本并争一争211学校的名额。<br>希望学长学姐以及有过考研经验的人可以给我一些帮助和建议，谢谢！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵转换</title>
    <link href="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵转换"><a href="#矩阵转换" class="headerlink" title="矩阵转换"></a>矩阵转换</h2><p>矩阵可以看作是一个向量的函数，则矩阵可以表示变换。<br>假设有以下向量(x,y),如何让该向量每个点横坐标扩大a倍，纵坐标扩大b倍，根据矩阵的点乘性质，则可以推出<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz1.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>假设矩阵还可以表示一个图形，那么如何将图形关于x轴翻转，也可以通过点乘另一个矩阵进行转换。例如<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz2.png" srcset="/img/loading.gif" width="400px" height="100px"><br>由此也可以推广出更多的转换。</p><hr><p>关于y轴的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz3.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>关于原点的翻转<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz4.png" srcset="/img/loading.gif" width="400px" height="100px"><br>沿x方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz5.png" srcset="/img/loading.gif" width="400px" height="100px">&lt;/img&gt;<br>沿y方向错切<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz6.png" srcset="/img/loading.gif" width="400px" height="100px"><br>关于原点进行旋转sitar角度<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz7.png" srcset="/img/loading.gif" width="400px" height="100px"></p><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>如果一个矩阵点乘另一个矩阵，矩阵的每一个元素没有发生任何变化，则称这种矩阵为单位矩阵。<br><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz8.png" srcset="/img/loading.gif" width="250px" height="130px"></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>单位矩阵的主对角线全为1.</li><li>单位矩阵一定是方阵.</li><li>假设单位矩阵为I，另一个矩阵为A，则I · A = A，A · I = A</li></ul><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在数字系统中，除了0之外，X * 1/X = 1.<br>那么在矩阵中，设矩阵A，B。如果A · B = B · A = I，则称B为A的逆矩阵，记作B = 1/A.</p><h3 id="性质与推广"><a href="#性质与推广" class="headerlink" title="性质与推广"></a>性质与推广</h3><ul><li>在矩阵系统中，有一些矩阵并没有逆矩阵。如果矩阵A存在逆矩阵，则称A为可逆矩阵，或者叫非奇异矩阵(non-singular)，相反如果矩阵不可逆，则称为不可逆矩阵，或者奇异矩阵(singular)。</li><li>如果存在矩阵A，B，C，B·A = I，则称B是A的左逆矩阵。如果A·C = I，则称C是A的右逆矩阵。</li><li>如果一个矩阵A既存在左逆矩阵B，又存在右逆矩阵C，则B=C。</li><li>对于矩阵A,如果存在逆矩阵B，则B唯一。</li><li>可逆矩阵一定为方阵，非方阵一定不可逆。</li><li>A的0次方 = I，A的-1次方为A的逆。</li><li>矩阵的逆的转置等于矩阵的转置的逆。</li><li><img src="/2020/01/03/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/wz9.png" srcset="/img/loading.gif" width="250px" height="130px"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于javaSwing数据绑定及刷新</title>
    <link href="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/"/>
    <url>/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近学校期末了，正在进行java实训，实训要做一个图书管理系统。对于实现mysql数据库数据在JTable上的绑定，以及数据更新后界面的刷新时，遇到了问题。由于我对于JavaSwing完全不了解 ，实训时也是现学现卖，所以不清楚如何将数据绑定到JTable上。看了很多CSDN的博客，最后采用了以下方法。</p><h3 id="关于数据绑定的实现"><a href="#关于数据绑定的实现" class="headerlink" title="关于数据绑定的实现"></a>关于数据绑定的实现</h3><p>首先创建针对数据的模型类,以下的模型类是基于自定义Book表的简单示范</p><pre><code>/*book_list*/public class book_list extends javax.swing.table.DefaultTableModel{Class[] types = new Class[] { java.lang.Object.class, java.lang.String.class,            java.lang.String.class}; public book_list() {        super(new Object[][] {}, new String[] { &quot;bookname&quot;, &quot;booktype&quot;});}}</code></pre><p>然后对数据表进行填充，创建book对象，读取数据库中的数据后进行对象的赋值。利用循环将所有数据存入List中，而后利用循环从List中依次取得对象，并将各属性存入boo_list创建的对象中。然后创建JTable实体用model进行填充。这样可以将数据库的信息转换成可以填充JTable的对象。从而完成数据绑定的操作。</p><pre><code>    //图书表的创建    public static book_list model2 = new book_list();    public static JTable table2 = new JTable(model2);    ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;();    try {        sqlBookcod sql = new sqlBookcod();        ResultSet rs = sql.searchBook();        while (rs.next()) {            Book book = new Book();            book.setName(rs.getString(&quot;bookname&quot;));            book.setBookType(rs.getString(&quot;booktype&quot;));            list.add(book);        }    }catch(SQLException e) {        e.printStackTrace();    }    for (int i = 0; i &lt; list.size(); i++) {        Book b = (Book) list.get(i);        model2.addRow(new Object[] {b.getName(),b.getBookType()});    }}</code></pre><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>当时进行数据绑定后，直接将table添加到panel中，当数据更新后，table中的数据已经被定死了。所以我采用了简单粗暴的方法，通过监听菜单栏的点击事件，直接删除table中的所有数据，然后重新进行填充，并删除panel中的table控件，重新添加table，从而实现数据表的更新。</p><pre><code>//图书表清空数据public static void delmodel2() {    model2 = new book_list();    table2 = new JTable(model2);}public void stateChanged(ChangeEvent e) {                    if(tabbedPane.getSelectedIndex() == 0) {        panel1.remove(p1);                    //删除panel1中原有的组件            tablepan.delmodel1();                //删除数据表内容                            p1 = tablepan.createTextPanel1();    //重新填充数据表        panel1.add(p1);        panel1.repaint();                     //对panel1本身进行重绘    }}</code></pre><hr><h3 id="界面如下"><a href="#界面如下" class="headerlink" title="界面如下"></a>界面如下</h3><p><img src="/2020/01/02/%E5%85%B3%E4%BA%8EjavaSwing%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%B7%E6%96%B0/wz1.png" srcset="/img/loading.gif" width="400px" height="250px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019个人总结</title>
    <link href="/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/01/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2019总结与反省"><a href="#2019总结与反省" class="headerlink" title="2019总结与反省"></a>2019总结与反省</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>当初带着坚定学习的决心，来到了大学校园，或许很多人并不清楚自己的目标是什么，我也一样。 我曾经不止一次问过自己，我为什么要学习计算机。 到最后也没有一个合适的理由说服自己，大概因为我什么也不会，除了带着点对计算机的兴趣与热爱之外，我不清楚自己还爱好着什么，也不知道自己将来要面对什么，也正如大多数人一样，只是为了生活去奋斗罢了。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>当初想着靠学技术到毕业工作，也努力学习了很多新技术，不再只会用c/c++敲黑窗口程序。图形界面程序从windowSdk到mfc又到winform，从winform到pythonGUI再到javaSwing。期间接触了很多编程语言，数据库技术，还有web前端技术以及一些网络的知识，服务器知识等。也了解过几种框架，入门过游戏引擎，做出了一些努力，但也曾有一段时间沉迷游戏，荒废时间。</p><h2 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h2><p>数学英语等课程依旧是这么差，技术水平增长缓慢也令我焦虑。当初只想搞技术的我，为其花费了大量的时间，导致我英语跟数学等科目没有跟上进度，现在悔悟基础课是多么重要。<br>当初坚定不打算考研的我，也在今年慢慢动摇，并决定考研一战。<br>感觉2019有收获也有后悔，自己所做出的努力在别人眼中或许根本不算努力，但总之没有自甘堕落，还有着目标和执行力。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="经历"><a href="#经历" class="headerlink" title="经历:"></a>经历:</h3><ul><li>年初参加蓝桥杯编程比赛拿到省三等奖。</li><li>肝封印者达到450w战力后弃坑。</li><li>假期学习unity做过几个小demo。</li><li>参加数学建模校赛，拿到三等奖，并得到333元奖金。</li><li>在学校创办兼职，写过python脚本程序处理excel。</li><li>担任学校计算机协会团支书并且给大一学生讲课。</li><li>买了服务器，但只玩了聊天室。</li><li>举办社团活动给学校师生修电脑。</li><li>学习Linux。</li><li>入坑古剑奇谭并且版本毕业。</li><li>看完了几本小说。</li><li>思考人生ing。</li><li>参加全国大学生数学建模比赛，拿到省一等奖。</li><li>入坑Django，重新复习前端。</li><li>莫名其妙进了学校实验班。</li><li>个人博客坏了一次，所有的文章丢失，又重新搭了博客网站并用了现在的主题。</li></ul><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><ul><li>依旧单身，没什么想法！</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是普普通通的一年，回想起来也没发生什么大事。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>学习英语数学以及计算机基础课，决定考研。</li><li>撰写博客同步发布到个人网站方便总结和复习。</li><li>勤写博客，勤刷题，每天坚持记英语单词。</li><li>继续进行基础知识的学习和练习。</li><li>深入学习框架并尝试进行项目实战。</li><li>稳住急躁的情绪，稳扎稳打。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵学习1</title>
    <link href="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/"/>
    <url>/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>向量是对数的拓展，一个向量表示一组数。<br>而矩阵是对向量的拓展，一个矩阵表示一组向量。<br>行数与列数相等的矩阵称为方阵。<br>一个矩阵可以拆分为n个行向量或者n个列向量，称矩阵为N x N矩阵。<br>矩阵可以表示成一个系统，例如在经济系统中，对于IT，电子，矿产，房产的投入，<br>可以表示成多个方程组，而方程组的系数则可用矩阵表示。</p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>行变成列，列变成行。</p><h3 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h3><p><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x1.png" srcset="/img/loading.gif" width="200px" height="80px"></p><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>每一个对应元素相加得到新矩阵</p><h3 id="矩阵的数量乘法"><a href="#矩阵的数量乘法" class="headerlink" title="矩阵的数量乘法"></a>矩阵的数量乘法</h3><p>标量去乘矩阵的每一个元素得到新矩阵</p><h3 id="矩阵的基本运算性质"><a href="#矩阵的基本运算性质" class="headerlink" title="矩阵的基本运算性质"></a>矩阵的基本运算性质</h3><p>A + B = B + A<br>(A + B) + C = A + (B + C)<br>存在矩阵O，满足：A + O = A<br>存在矩阵-A,满足：A + (-A) = O<br>-A 唯一, -A = -1 * A<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x2.png" srcset="/img/loading.gif" width="250px" height="70px"></p><h3 id="矩阵和向量的乘法"><a href="#矩阵和向量的乘法" class="headerlink" title="矩阵和向量的乘法"></a>矩阵和向量的乘法</h3><p>矩阵的列数必须和向量的元素个数一致。<br>矩阵与向量点乘，实际上将向量a转换成了向量b，所以矩阵可以理解为向量的函数。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x3.png" srcset="/img/loading.gif" width="350px" height="100px">&lt;/img&gt;<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x4.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵和矩阵的乘法"><a href="#矩阵和矩阵的乘法" class="headerlink" title="矩阵和矩阵的乘法"></a>矩阵和矩阵的乘法</h3><p>矩阵A和矩阵B的每一个列向量相乘，要求矩阵A的列数必须和矩阵B的行数一致。<br>矩阵的乘法不遵守交换律。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x5.png" srcset="/img/loading.gif" width="350px" height="100px">&lt;/img&gt;<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x6.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p>只有方阵才有矩阵的幂。<br><img src="/2019/12/31/%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A01/x7.png" srcset="/img/loading.gif" width="350px" height="100px"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线代个人理解</title>
    <link href="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线性代数是从从研究一个数，到研究一组数的数学。<br>一组数的基本表示方法为向量，而向量也是线性代数研究的基本元素。<br>向量可以在多个维度表示一个Object的基本属性，方便我们数学的研究。<br>向量一般分为行向量与列向量，但在通常的教材和论文中，向量一般默认指列向量。<br>ps ： 由于印刷问题，列向量可以表示为(num1,num2)T。</p><h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><h3 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h3><p>如果两个向量(num1,num2) + (num3,num4),那么得到的结果为(num1+num3,num2+num4)。<br>向量的加法可以表示为在n维坐标中，继续增加n维度的单位。<br>例如(5,2)T + (2,5)T.<br>表示先在x维度上增加5个单位，在y维度上增加2个单位。再在x维度上增加2个单位，再在y维度上增加5个单位。那么在x维度总共有7个单位，在y维度总共也有7个单位，进而得到的向量的结果为(7,7).<br>它可以表示object在两个维度上的信息。</p><h3 id="向量的数量乘法"><a href="#向量的数量乘法" class="headerlink" title="向量的数量乘法"></a>向量的数量乘法</h3><p>简单来说乘法只是加法的推广和延申，那么向量的乘法同样也表示在n维度的坐标中，重复增加n维度个单位。</p><h3 id="向量运算的基本性质"><a href="#向量运算的基本性质" class="headerlink" title="向量运算的基本性质"></a>向量运算的基本性质</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/xl.png" srcset="/img/loading.gif" width="350px" height="100px"></p><h3 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h3><p>二范数的概念：表示向量每个维度的平方相加再开二次方。例如勾股定理<br>那么向量的长度实际上就是求向量的二范数,也可以叫做求向量的模</p><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><p>单位向量是指这个向量去乘这个向量的模分之一，也就是保持向量的长度为1.所以单位向量的模永远为1，它只表示方向。<br>根据向量u求出单位向量u1的过程，也被称为是归一化，规范化(normalize)。<br>二维空间中，有两个特殊的单位向量 e1 = (1,0),e2 = (0,1)。<br>只由0，1组成的单位向量叫做，标准为单位向量(Standard Unit Vector)。<br>n维空间有n个标准为单位向量。</p><h3 id="两个向量相乘"><a href="#两个向量相乘" class="headerlink" title="两个向量相乘"></a>两个向量相乘</h3><p><img src="/2019/12/29/%E7%BA%BF%E4%BB%A3%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/x2.png" srcset="/img/loading.gif" width="700px" height="150px"><br>两个向量相乘，结果为一个标量，这个标量代表两个向量的模相乘，再乘向量夹角的Cos值。这种乘法更严格的来说是两个向量的点乘，或者两个向量的内积。<br>向量的点乘也可以看作只有一行元素的矩阵与向量相乘。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
