<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>CppPrimer阅读笔记 ~ inaho</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.7/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><style type="text/css">.banner-bg{background-image:url(/img/bg1.jpg);background-position:center;background-repeat:repeat-y;background-size:cover;background-attachment:fixed}</style><meta name="generator" content="Hexo 4.2.1"></head><body class="banner-bg"><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>阴月有晴</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2 rgba-black-slight" id="background"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期六, 十一月 28日 2020, 4:00 下午</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">7.3k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">28 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main id="mainContent" class="rgba-black-slight"><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><h2 id="第一章笔记"><a href="#第一章笔记" class="headerlink" title="第一章笔记"></a>第一章笔记</h2><ol><li>main函数返回类型必须为int。</li><li>大多数系统中main的返回值被用来指示状态，如0代表成功，其他数字通常指出错误类型。</li><li>一个流就是一个字符序列。</li><li>“&lt;&lt;” 运算符左侧运算对象为ostream对象，右侧为要打印的值，运算符将给定的值写给定的ostream对象中，返回其左侧运算对象。</li><li>“&gt;&gt;” 运算符接受一个istream作为左侧运算对象，接受一个对象作为右侧运算对象，从给定的istream读入数据，存入给定对象中，返回其左侧运算对象作为其计算的结果。</li><li>endl 是一个被称为“操纵符”的特殊值，写入endl结束该行，将与设备关联的缓冲区内容刷到设备中，可以保证目前为止程序产生的所有输出都写入到输出流中，而不是在内存中等待写入流。</li><li>当使用一个istream对象作为条件时，其效果是检测流的状态，当遇到文件结束符或遇到无效输入，istream对象状态会变为无效，无效的istream会使条件为假。</li><li>默认情况cin会刷新cout，程序非正常终止也会刷新cout。</li></ol><h2 id="第二章笔记"><a href="#第二章笔记" class="headerlink" title="第二章笔记"></a>第二章笔记</h2><ol><li>在c++语言中，一个字节至少要能容纳机器基本字符集中的字符。</li><li>为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，类型决定了数据所占比特数以及如何解释这些比特的内容。</li><li>类型char在一些机器上有符号，另一些机器又是无符号的。</li><li><p>无符号数作为循环变量可能导致死循环。</p><pre><code> for (int i = 10; i &gt;= 0 ; --i){
     std::cout &lt;&lt; i&lt;&lt; std::endl;
 }
 for (unsigned u = 10; u &gt;= 0; --u){        //可能死循环
     std::cout &lt;&lt; i&lt;&lt; std::endl;
 }
</code></pre></li><li><p>带符号数会自动转换为无符号数。</p></li><li>十进制字面值默认是带符号数，但十进制字面值不会是负数，负号不在字面值之内。</li><li>字符字面值为单引号括起来的值，字符串字面值为双引号括起来的值，字符串字面值实际长度要比它的内容多1，因为编译器会在其末尾添加空字符’\0’。</li><li>变量提供一个具名、可供程序操作的存储空间。</li><li>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</li><li>在c++语言中，初始化和赋值是两个完全不同的操作。</li><li><p>初始化的方式：</p><pre><code>int value = 0;
int value = { 0 };
int value{ 0 };
int value(0);
</code></pre></li><li><p>作为c++11的新标准，花括号初始化得到广泛应用，但当其用于内置类型变量时，如果使用列表初始化且初始值存在丢失信息的风险，编译器将报错：</p><pre><code>long double ld = 3.1415926;
int a{ld}, b = {ld};    //编译器报错
</code></pre></li><li>定义于任何函数体之外的变量被初始化为0，函数体内的内置类型对象如果没有初始化，则其值未定义，每个类各自决定其初始化对象的方式。</li><li><p>声明规定了变量的类型和名字，而定义还为变量申请存储空间或赋初值。</p><pre><code>//如果想声明一个变量而非定义则：extern int i;
//而包含显示初始化的声明即成为定义。  
//函数体内无法初始化由extern标记的变量
</code></pre></li><li>每个名字都会指向特定的实体，而同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在作用域末端为结束。</li><li><p>使用作用域操作符来覆盖默认的作用域规则，当作用域操作符左侧为空，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p><pre><code>int i = 100, sum = 0;
int main() {
for (int i = 0; i != 10; ++i) {
    sum += ::i;                    //调用全局变量i
}
cout &lt;&lt; i &lt;&lt; &quot;  &quot; &lt;&lt; sum &lt;&lt; endl;
return 0;
}
</code></pre></li><li><p>引用并非对象，引用必须初始化，且不能定义引用的引用。</p><pre><code>int a = 5;
int &amp;b = a, &amp;c = b, &amp;d = c, &amp;e = d;
cout &lt;&lt; e &lt;&lt; endl;                //输出5
</code></pre></li><li><p>引用与指针的类型要和与之绑定的对象严格匹配，引用只能绑定在对象上，不能与字面值或表达式的计算结果绑定，但有些特殊情况：</p><pre><code>初始化常量引用时允许用任意表达式作为初始值，只要其结果能转化成引用类型即可，允许常量引用绑定非常量对象。
允许令一个指向常量的指针指向一个非常量对象，指向常量的指针仅仅要求不能通过该指针改变对象的值。
</code></pre></li><li>使用nullptr来得到空指针，nullptr是一种特殊类型字面值，它可以被转化为任意其他指针类型。</li><li>如果指针的值为0，条件取false，其他取true，比较指针是比较它们所存地址值是否相等。</li><li>void* 是特殊指针类型，可用于存放任意对象的地址，但无法访问内存空间中的对象。</li><li><p>为了理解类型，从右向左阅读其定义，距变量名最近的符号对变量类型有最直接的影响。</p><pre><code>int *&amp;r;        //r是一个引用
int &amp;*r;        //不存在指向引用的指针
</code></pre></li><li>const对象一旦创建后其值无法更改，所以const对象必须初始化。</li><li>以编译初始化的方式定义const对象时，编译器将在编译过程中将用到该变量的地方替换成对应的值。</li><li>默认情况下，const对象被设定为仅在文件内有效。</li><li><p>只在一个文件中定义const，而在多个其他文件中声明并使用它，对于其声明还是定义都添加extern关键字。</p><pre><code>extern const int value = 10/2;        //file.cc文件
extern const int value;                //file.h文件
</code></pre></li><li>引用绑定到const对象上，称为对常量的引用，不能修改它所绑定的对象。</li><li><p>对于下列代码是非法的。</p><pre><code>double dval = 3.14;
const int &amp;ri = dval;                //非法
编译器将其转化为：
const int temp = dval;
const int &amp;ri = dval;
// ri实际上绑定了一个临时量，而程序员一般会想用ri去改变dval对象，不会将引用绑定到临时量上，因此c++规定其非法。
</code></pre></li><li><p>对const的引用可能引用一个并非const的对象，常量引用仅对引用可参与的操作做出限定。</p><pre><code>int i = 42;
int &amp;r1 = i;
const int &amp;r2 = i;
r1 = 0;                //允许
r2 = 0;                //错误
</code></pre></li><li><p>指向常量的指针不能用于改变其所指对象的值，只能使用指向常量的指针存放常量对象的地址。</p><pre><code>const double pi = 3.14159;
const double *cptr = &amp;pi;    //正确
</code></pre></li><li><p>允许把指针本身定义为常量，其必须初始化，初始化后其的值(地址)无法改变。</p><pre><code>int errNumb = 0;
int *const curErr = &amp;errNumb;        //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &amp;pi;        //pip是一个指向常量对象的常量指针
</code></pre></li><li>顶层const表示指针本身是个常量或表示任意的对象是常量。<br>底层const表示指针所指对象是一个常量，底层const与指针和引用等复合类型的基本类型部分有关。<br>用于声明引用的const都是底层const，非常量可以转化为常量，反之不行。</li><li>常量表达式指值不会改变并且编译过程中就能得到计算结果的表达式，由数据类型和初始值决定。</li><li>允许将变量声明为constexpr类型，声明为constexpr的变量一定是一个常量，必须用常量表达式初始化，新标准允许定义特殊的constexpr函数，这种函数应该足够简单以使得编译时就可计算结果，这样能用constexpr函数初始化其值。</li><li><p>算术类型、引用、指针都属于字面值类型，自定义的类则不是。</p><pre><code>例如constexpr指针和constexpr引用
constexpr int *q = nullptr;     //constexpr限定符仅对指针本身有效，也就是将其置为顶层const。
</code></pre></li><li><p>类型别名，typedef和别名声明(c++11)使用using。</p><pre><code>using bookptr = string;
typedef int NUM;
</code></pre></li><li><p>对于typedef的理解。</p><pre><code>typedef char* pstring
const pstring cstr = 0;        //pstring是char*的别名，指向char的指针，所以const修饰pstring，cstr是指向char的常量指针。
const pstring *ps;            //ps是指向char常量指针的指针。
</code></pre></li><li>auto通过变量初始值推断变量类型，auto定义的变量必须有初始值。</li><li><p>当anto初始值为引用时，auto会忽略顶层const，保留底层const。</p><pre><code>const auto f = ci;            //显示指出希望推断类型为顶层const
</code></pre></li><li><p>decltype，选择并返回操作数的数据类型，编译器仅分析其类型，不计算表达式的值。</p><pre><code>decltype(f()) sum = x;
decltype处理顶层const与auto不同，它会返回变量的类型，包括顶层const和引用在内。
const int ci = 0, &amp;cj = ci;
decltype(ci) x = 0;    x的类型是const int
decltype(cj) y = x;    y的类型是const int&amp;
如果decltype使用的表达式不是一个变量，decltype返回表达式结果对应的类型。
如果表达式内容是解引用操作，则decltype将得到引用类型。
如果给变量加了一层或多层括号，编译器会将其当成一个表达式。
decltype ((i)) d;        //d是int&amp;类型    ！！
</code></pre></li><li>赋值是产生引用的一类典型表达式。</li><li>头文件一般包含只能被定义一次的实体，例如类、const、constexpr等。</li><li>“#define”指令将一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真，检查结果为真时，执行后续操作知道遇到#endif指令为止。</li><li>为避免与程序中其他实体发生名字冲突，一般将预处理变量名字全部大写。</li><li>c++11允许在声明类的数据成员时同时提供初始值，必须在等号右侧或花括号内。</li></ol><h2 id="第三章笔记"><a href="#第三章笔记" class="headerlink" title="第三章笔记"></a>第三章笔记</h2><ol><li>头文件不应包含using声明。</li><li><p>string的初始化方式。</p><pre><code> string s4(n,&#39;c&#39;);        //把s4初始化为连续n个字符c组成的串
</code></pre></li><li>string.size()返回的是一个string::size_type类型的值(无符号整数类型)。</li><li><p>string对象与字符字面值混在一条语句使用时，必须确保+两侧至少有一个是string对象。</p><pre><code> string s2 = (s1 + &quot;,&quot;) + &quot;word&quot;;
</code></pre></li><li>string下标运算符[]接收的参数是string::size_type类型的值。</li><li><p>模板本身不是类或函数，编译器根据模板创建类或函数的过程称为实例化。</p><pre><code> vector&lt;string&gt; svec(10,&quot;hi&quot;);    //10个string类型的元素都被初始化为hi
 vector&lt;int&gt; ivec(10);            //10个重复执行值初始化的对象
</code></pre></li><li>列表初始化会尽可能把花括号内的值当成元素初始值的列表处理</li><li><p>如果初始化使用花括号的形式但提供的值不能用来列表初始化，就要考虑用这样的值来构造vector对象。</p><pre><code> vector&lt;string&gt; vstr{10,&quot;hi&quot;};    //10个string类型的元素都被初始化为hi
</code></pre></li><li>如果循环内包含有向vector对象添加元素的语句，则不能使用范围for循环，范围for语句体内不应改变其所遍历序列的大小。</li><li>cbegin和cend返回const_iterator类型的迭代器，it-&gt;mem与(*it).mem表达的意思相同。</li><li>循环体内任何一种可能改变vector对象容量的操作，都会使该对象的迭代器失效。</li><li>两个迭代器之差的类型为difference_type的带符号整型数。</li><li><p>const迭代器指允许读，不允许写</p><pre><code>vector&lt;int&gt;::const_iterator it3;    //只能读元素，不能写元素
string::const_iterator it2;            //只能读字符，不能写字符
</code></pre></li><li>数组的维度必须是常量表达式，不允许用auto由初始值推断类型。</li><li><p>用字符串字面值初始化char数组，末尾由空字符。</p><pre><code>int (*parray)[10] = &amp;arr;    //parray指向一个含有10个整数的数组
int (&amp;arrRef)[10] = arr;    //arrRef引用一个含有10个整数的数组
</code></pre></li><li>使用auto推断数组类型时，得到的是指针，而用decltype时，其返回的就是数组类型。</li><li><p>指针也是迭代器。</p><pre><code>int ia[] = {0,1,2,3,4,5,6};
int *beg = begin(ia);
int *last = end(ia);
</code></pre></li><li>两指针相减是ptrdiff_t类型和size_t一样是定义在cstddef头文件中的机器相关类型。</li><li><p>标准库类型限定下标必须是无符号类型，而内置下标运算无此要求。</p><pre><code>int *p = &amp;ia[2];
int j = p[1];
int k = p[-2];
</code></pre></li><li><p>允许使用空字符结束的字符数组来初始化string对象或为其赋值，允许使用空字符结束的字符数组作为其中一个运算对象。</p><pre><code>char *str = s;                //s是string对象，尝试用string对象初始化字符指针是错误的
const char *str = s.c_str();//正确，string提供c_str()函数返回c风格的字符串,也就是一个指针。
</code></pre></li><li><p>可以用数组初始化vector对象：</p><pre><code>int int_arr[] = {0,1,2,3,4,5};
vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));
vector&lt;int&gt; subVec(int_arr + 1,int_arr + 4);
</code></pre></li><li><p>范围for语句处理数组。</p><pre><code>size_t cnt = 0;
for (auto &amp;row : ia)
    for (auto &amp;col : row){
        col = cnt;
        ++cnt;
    }
</code></pre></li><li><p>使用范围for时，除了最内层循环外，其他所有循环的控制变量都应该是引用类型。</p><pre><code>for (auto row : ia)
    for (auto col : row)        //错误
由于row不是引用类型，而ia的每个元素是数组，因此row会将数组元素转换成指向数组首元素的指针
在内循环中，for试图遍历一个指针，这是错误的。
</code></pre></li><li><p>c++11标准使用auto或declyype能尽可能避免在数组前面加指针类型。</p><pre><code>int ia[3][4] = {0};
for (auto p = ia; p != ia + 3; ++p) {
    for (auto q = begin(*p); q != end(*p); ++q) {
        cout &lt;&lt; *q &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; endl;
}
</code></pre></li><li>size_t是一种与机器实现有关的无符号类型，空间足够大，能够表示任意数组的大小。</li></ol><h2 id="第四章笔记"><a href="#第四章笔记" class="headerlink" title="第四章笔记"></a>第四章笔记</h2><ol><li><p>优先级规定了运算对象组合方式，但没有说明运算对象的求值顺序，对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p><pre><code> int i = 0;
 cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; i++ &lt;&lt; endl;    //不知道先求++i的值还是先求i的值
 //****************************************************************************
 int num = 5;
 int f1() {
     return num;
 }
 int f2() {
     num = 6;
     return num;
 }
 void test9() {
     int i = f1() * f2();            //不清楚先求f1()还是f2()的值。
     cout &lt;&lt; i &lt;&lt; endl;
 }
</code></pre></li><li><p>如果m<em>n是整数且n非0，则表达式(m/n)</em>n+m%n的求值结果与m相等。</p><pre><code> 21 % -5 = 1；        21 / -5 = -4；
 -21 % 5 = -1；
</code></pre></li><li>if(val == true)，这种写法的问题是如果val不是bool值，这种比较就失去原来的意义，if(val)更推荐这种写法。</li><li>赋值运算符满足右结合律。</li><li>初始值列表为空，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。</li><li><p>多重赋值语句每个对象，它的类型或者与右边对象类型相同、或者可以类型转换为右边对象的类型。</p><pre><code> int ival，*pval；
 ival = pval = 0；        //错误，但可以单独赋值为0
</code></pre></li><li><p>赋值运算优先级较低，通常需要加括号使其符合我们的意愿。</p><pre><code> int i = get_value();
 while(i != 42){i = get_value();}
 //可以改为
 int i;
 while((i = get_value()) != 42){}
</code></pre></li><li>复合运算符只求值一次，普通运算符则需要求值两次。</li><li><p>递增、递减运算符，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。</p><pre><code> //后置版本需要将原始值存储下来以便返回这个未修改的内容。
 //如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值，运算对象的求值顺序就很重要了
 while(beg != s.end() &amp;&amp; !isspace(*beg))
     *beg = toupper(*it);        //错误
 //编译器可能解释为
 *beg = toupper(*beg)         //先求左值
 *(beg + 1) = toupper(*beg);    //先求右值
</code></pre></li><li><p>条件运算符满足右结合律，靠右边的条件运算构成了靠左边条件运算的分支。</p><pre><code>//优先级非常低，注意加括号
int grade = 85;
cout &lt;&lt; ((grade &gt; 90) ? &quot;high pass&quot; : ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;)) &lt;&lt; endl;
</code></pre></li><li>如果运算对象是带符号的且值为负，此时左移操作可能会改变符号位的值，在符号位如何处理没有明确规定时，应仅将位运算符用于处理无符号类型。</li><li><p>sizeof满足右结合律，返回常量表达式。</p><pre><code>sizeof(Sales_data);            //存储该类型对象所占空间大小
sizeof data;                //data类型大小
sizeof p;                    //p指针大小
sizeof *p;                    //p所指类型的空间大小
sizeof data.revenue;        //成员对应类型的大小
sizeof Sales_data::revenue;    //新标准允许使用域运算符获取类成员的大小。
//对数组执行sizeof运算得到整个数组所占空间的大小
//对容器执行sizeof运算返回该类型固定部分的大小
</code></pre></li><li>逗号运算符规定了运算对象求值的顺序，从左向右。</li><li><p>使用命名的强制类型转换。</p><pre><code> int j = 10, i = 5;
 double slope = static_cast&lt;double&gt;(j) / i;
 //使用static_cast找回存在于void*指针
 void* p=&amp;d;    
 double *dp = static_cast&lt;double*&gt;(p)
 //static_cast、dynamic_cast、const_cast、reinterpret_cast指定执行的是哪一种转换。
</code></pre></li><li>类类型能定义由编译器自动执行的转换，比如IO库定义了从istream向布尔值转换的规则。</li></ol><h2 id="第五章笔记"><a href="#第五章笔记" class="headerlink" title="第五章笔记"></a>第五章笔记</h2><ol><li>for语句的修改发生在每次循环迭代之后。</li><li><p>for的新写法。</p><pre><code> vector&lt;int&gt; v;
 for(int i;cin &gt;&gt; i;)
     v.push_back(i);
</code></pre></li><li>在范围for语句中，预存了end()的值，一旦在序列中修改元素，end函数的值可能变得无效。</li><li>异常类型只定义了what的成员函数，返回一个指向c风格字符串的const char*提供本文信息。</li><li>异常没有被捕捉到时调用terminate函数，终止当前程序的执行。</li></ol><h2 id="第六章笔记"><a href="#第六章笔记" class="headerlink" title="第六章笔记"></a>第六章笔记</h2><ol><li>函数是一个命名了的代码块。</li><li><p>static使局部变量生命周期贯穿调用及之后，在第一次执行时初始化，到程序终止才被销毁。</p><pre><code> //没有显示初始化，将执行值初始化。
 size_t count_calls() {
     static size_t ctr(0);
     return ++ctr;
 }
 int main() {
     for (size_t i = 0; i != 10; ++i) {
         cout &lt;&lt; count_calls() &lt;&lt; endl;
     } return 0;
 }
</code></pre></li><li>当函数无需修改引用形参的值，最好使用常量引用。</li><li>用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传常量对象或非常量对象都可以。</li><li><p>关于主函数的参数，第二个形参是一个数组，指向c风格字符串，第一个形参argc表示数组中字符串数量。</p><pre><code>  //可选实参从argv[1]开始，argc[0]保存程序的名字。
  int main(int argc,char *argv[])
</code></pre></li><li><p>如果函数实参数量未知，但全部实参类型相同，可以使用initializer_list类型的形参。</p><pre><code> void print(std::initializer_list&lt;string&gt; str) {
     for (auto i = str.begin(); i != str.end(); ++i) {
         cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
     }
 }
 int main() {
     print({ &quot;ddsada&quot;, &quot;dsadsadsa&quot;, &quot;dsaadsda&quot;, &quot;dasdsadasdas&quot; });    //必须带大括号
     return 0;
 }
 //initializer_list对象中的元素永远是常量值。
</code></pre></li><li>返回类型是void的函数会隐式执行return;</li><li><p>此函数返回类型与形参都是const string的引用，因此不论调用还是返回结果都不会拷贝string对象。</p><pre><code> const string &amp;shorterString(const string &amp;s1, const string &amp;s2) {
     return s1.size() &lt;= s2.size() ? s1 : s2;
 }
 //无法返回局部对象的引用
</code></pre></li><li>c++11规定，函数可以返回花括号包围的值的列表，如果列表为空，临时量执行值初始化。</li><li><p>允许main函数没有return语句直接结束，cstdlib定义了两个预处理变量，使用这两个变量表示成功或失败。</p><pre><code> return EXIT_FAILURE;
 return EXIT_SUCCESS;
</code></pre></li><li><p>定义返回数组指针的函数，数组维度必须跟在函数名字之后。</p><pre><code>int(*func(int i))[10];
//使用类型别名：
using arrT = int[10];
arrT* func(int i);
</code></pre></li><li><p>使用尾置返回类型。</p><pre><code>auto func(int i) -&gt; int(*)[10];
</code></pre></li><li><p>使用decltype声明返回类型，arrPtr返回指向含有5个整数的数组的指针，decltype的结果是个数组，其不负责将数组类型转换成对应的指针，所以需要加*。</p><pre><code>int odd[] = { 1,3,5,7,9 };
int even[] = { 0,2,4,6,8 };
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &amp;odd : &amp;even;
}
</code></pre></li><li><p>int数组的引用。</p><pre><code>auto printNum(int(&amp;num)[6]) -&gt; int(&amp;)[6] {
    for (auto i = begin(num); i != end(num); ++i) {
        *i += 1;
    }
    return num;
}
int main() {
    int num1[] = { 1,2,3,4,5,6 };
    printNum(num1);
    for (auto i : num1) {
        cout &lt;&lt; i;
    }
    return 0;
}
</code></pre></li><li><p>顶层const不影响传入函数的对象，底层const影响。</p><pre><code>Record lookup(Phone);
Record lookup(const Phone);        //重复声明，顶层const
Record lookup(Phone*)
Record lookup(phone* const);    //重复声明，顶层const
//***************************************************
Record lookup(Account&amp;);
Record lookup(const Account&amp;);    //新函数，底层const
</code></pre></li><li>当传递非常量对象或者指向非常量对象的指针，编译器优先选用非常量版本的函数。</li><li>在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体。</li><li><p>默认实参作为形参的初始值出现在形参列表中，一旦某个形参被赋予了默认值，后面的所有形参都必须有默认值。</p><pre><code>string screen(string::size_type ht=24,string::size_type wid=80,char backgrnd = &#39; &#39;);
//给定作用域中一个形参只能被赋予一次默认实参，后续声明中不能修改一个已存在的默认值，但可以给没有默认值的形参添加默认值。
//局部变量不能当作默认实参，表达式类型能转换成形参所需类型，该表达式就能作为默认实参。
</code></pre></li><li><p>名字的求值过程发生在函数调用，用作默认实参的名字在函数声明所在的作用域内解析。</p><pre><code>using str = string;
str wd = &quot;123&quot;;
char def = &#39; &#39;;
str ht() { return &quot;123&quot;; }
string screen(str a = ht(), str b = wd, char c = def) {
    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;
    return &quot;123&quot;;
}
void f5() {
    def = &#39;*&#39;;                //改变了
    str wd = &quot;456&quot;;            //没改变，该局部变量与传递给screen的默认实参没有关系。
    str window = screen();
}
</code></pre></li><li><p>inline用于声明内联函数，编译过程中会进行内联的展开，避免了原函数调用需要保存寄存器以及后面的恢复等一系列开销。</p><pre><code>//内联机制用于优化规模小、流程直接、频繁调用的函数。
inline auto shorterString(const string &amp;s1,const string &amp;s2) -&gt; const string &amp;{
    return s1.size() &lt;= s2.size() ? s1 : s2;
}
</code></pre></li><li><p>constexpr函数指能用于常量表达式的函数，其返回类型及所有形参类型必须是字面值类型，函数体内必须有且只有一条return语句。</p><pre><code>constexpr int new_sz(){return 42;}
constexpr int foo = new_sz();
constexpr size_t scale(size_t cnt){ return new_sz() * cnt;}    //当实参是常量表达式，返回值也是常量表达式，反之不然！。
//constexpr函数不一定返回常量表达式！！
//内联函数和constexpr函数可以在程序中多次定义，其多个定义必须完全一致，因此这两个函数 通常定义在头文件中。
</code></pre></li><li><p>含有多个形参的函数匹配。</p><pre><code> f(int,int);
 f(double,double);
 //调用函数f(42,2.56);如果按第一个实参来说，f(int,int)是最优匹配，如果按第二个实参来说f(double,double)是最优匹配。
 //编译器最终将因为这个调用具有二义性而拒绝其请求。
</code></pre></li><li><p>所有算术类型转换的级别一样。</p><pre><code> void manip(long);
 void manip(float);
 manip(3.14);        //错误，因为3.14是double类型，其既可转换成long也可转换成float。
</code></pre></li><li><p>函数指针指向的是函数。</p><pre><code> bool lengthCompare(const string &amp;,const string &amp;);
 //该函数类型: bool(const string&amp;,const string&amp;);
 //指向该函数的指针: bool (*pf)(const string&amp;,const string &amp;);
</code></pre></li><li>使用指向重载函数的指针时，指针类型必须与重载函数中的某一个精确匹配。</li></ol><h2 id="第七章笔记"><a href="#第七章笔记" class="headerlink" title="第七章笔记"></a>第七章笔记</h2><ol><li>定义在类内部的函数是隐式的inline函数。</li><li><p>当调用一个成员函数时，用请求该函数的对象地址初始化this。</p><pre><code>  total.isbn() == Sales_data::isbn(&amp;total)    //伪代码
  //成员函数内部，this指针所指的正是本对象，this是一个常量指针。
</code></pre></li><li><p>默认情况下this的类型是指向类类型非常量版本的常量指针，因此不能在常量上调用普通成员函数。</p><pre><code>  //c++允许把const关键字放在成员函数的参数列表之后，紧跟在参数列表后面的const表示this是一个指向常量的指针。
  //这样使用const的成员函数被称为常量成员函数，其不能改变调用它的对象的内容。
</code></pre></li><li>IO类不能被拷贝。</li><li>拷贝类的对象其实拷贝的是对象的数据成员。</li><li>构造函数不能被声明成const，因此构造函数在const对象的构造过程中可以向其写值。</li><li>编译器创建的构造函数又被称为合成的默认构造函数，如果存在类内初始值，用它初始化成员，否则，默认初始化，含有内置类型或复合类则成员的类应该在类的内部初始化这些成员，否则可能得到未定义的值。</li><li>如果需要默认的行为，可以通过在参数列表后写上=default来要求编译器生成构造函数。</li><li>一个类可以包含0或多个访问说明符，对于某个访问说明符出现的次数也没有严格限定。</li><li>struct和class的区别在于，使用struct关键字，其成员默认为public权限，对于class，这些成员默认为private。</li><li>友元声明可以使非类的成员访问类的private成员，只能在类定义的内部声明。</li><li>友元声明仅指定了了访问权限，并不代表函数声明。</li><li>无须在声明和定义的地方同时说明inline。</li><li>关键字mutable声明可变数据成员，即使在const成员函数内也可以改变其值。</li><li>基于const的函数重载，在某个对象调用该函数时，该对象是否是const决定应该调用哪个版本的函数。</li><li><p>一旦一个类的名字出现，它就被认为声明过了。</p><pre><code>class Screen;        //声明，但未定义，可以定义指向这种类型的指针或引用。
</code></pre></li><li>一旦遇到了类名，定义的剩余部分就在类的作用域之内了。</li><li>如果没有在构造函数的初始值列表中显式初始化成员，则该成员将在构造函数体之前执行默认初始化。</li><li>对于类成员是const或者引用，必须通过构造函数初始值进行初始化。</li><li><p>成员初始化顺序与类定义中出现顺序一致。</p><pre><code> class X{
     int i;
     int j;
 public:
     X(int val):j(val),i(j){}        //未定义
 };
</code></pre></li><li><p>委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。</p><pre><code>class Sales_data{
    public:
        //构造函数1
        Sales_data(std::string s,unsigned cnt,double price):bookNo(s),units_sold(cnt),revenue(cnt*price){}
        //委托构造函数

        //构造函数2
        Sales_data():Sales_data(&quot; &quot;,0,0){}                //委托给构造函数1
        //构造函数3
        Sales_data(std::string s):Sales_data(s,0,0){}    //委托给构造函数2
        Sales_data(std::istream &amp;is):Sales_data(){read(is,*this);}        //委托给构造函数3
}
//当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。
</code></pre></li><li><p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p><pre><code> /*编译器只会自动执行一步类类型转换。
 使用explicit阻止构造函数隐式创建Sales_data对象，只对一个实参的构造函数有效。
 多个实参的构造函数不能用于隐式转换。*/
 explicit Sales_data::Sales_data(istream&amp; is){
    read(is,*this);
 }
 //explicit构造函数只能用于直接初始化
</code></pre></li><li>类的静态成员存在于任何对象之外，被所有对象共享，类静态成员函数也不与任何对象绑定，并且不含this指针，不能声明成const，可以使用类的对象、引用或指针来访问静态成员。</li><li>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义该成员。</li></ol><hr><p><strong>笔记仅供自己参考</strong></p><hr></div><br><div><p><span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/c++">c++</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://yoursite.com/2020/11/28/cpp-primer阅读笔记/",this.page.identifier="/2020/11/28/cpp-primer阅读笔记/"},oldLoad=window.onload;window.onload=function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.src="//inaho-top.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a></noscript></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div id="footerContent" class="rgba-black-slight"><footer class="pt-5"><div style="color:#fff" class="text-center py-3"><a style="color:#fff" href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo支持</b></a> <i class="iconfont icon-love"></i> <a style="color:#fff" href="https://disqus.com/" target="_blank" rel="nofollow noopener"><b>Disqus 评论系统 </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>主题Fluid </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://www.pixiv.net/" target="_blank" rel="nofollow noopener"><b>图片 Pixiv</b></a><br>&nbsp;<span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp; &nbsp;<span id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;<br></div></footer></div><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="/lib/popper/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.7/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="/lib/tocbot/tocbot.min.js"></script><script src="/js/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/lib/prettify/prettify.min.js"></script><script>$(document).ready((function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()}))</script><script src="/lib/typed/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","CppPrimer阅读笔记&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready((function(){$(".typed-cursor").addClass("h2"),typed.start()}))</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options={placement:"right",visible:"false"};var el="h1,h2,h3,h4,h5,h6".split(","),res=[];for(item of el)res.push(".markdown-body > "+item);anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each((function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)}))</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });</script><script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">$("#background").removeClass("banner-bg"),$("body").addClass("banner-bg");var postToTopHight=$("#board").offset().top;$(window).scroll((function(){document.body.scrollTop+document.documentElement.scrollTop>=postToTopHight?($("#background").removeClass("rgba-black-slight"),$("#mainContent").removeClass("rgba-black-slight"),$("#footerContent").removeClass("rgba-black-slight")):($("#background").addClass("rgba-black-slight"),$("#mainContent").addClass("rgba-black-slight"),$("#footerContent").addClass("rgba-black-slight"))}))</script></body></html>