<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>寻址方式与RISC技术 ~ inaho</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.7/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><style type="text/css">.banner-bg{background-image:url(/img/bg1.jpg);background-position:center;background-repeat:repeat-y;background-size:cover;background-attachment:fixed}</style><meta name="generator" content="Hexo 4.2.1"></head><body class="banner-bg"><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>阴月有晴</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2 rgba-black-slight" id="background"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期一, 五月 18日 2020, 10:29 上午</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">2.2k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">7 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main id="mainContent" class="rgba-black-slight"><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>寻址方式确定本条指令的操作数地址，或者下一条要执行指令的指令地址，指令的地址码字段往往不是操作数真实的地址，而是形式地址，用A表示。形式地址结合指令的寻址方式可以计算出操作数的真实地址，称为有效地址用EA表示。<br>(PC)表示寄存器PC的数值，不加括号表示存储介质或编码。<br>寻址方式分为指令寻址和数据寻址。</p><ul><li>确定指令存放位置的过程称为指令寻址方式</li><li>确定操作数存放位置的过程称为数据寻址方式</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>找到下一条将要执行指令的地址，称为指令寻址，指令基本上按执行顺序存放在主存中，执行过程中，指令总是从内存单元被取到指令寄存器IR中。</p><ul><li>顺序寻址，(PC)+1-&gt;PC</li><li>跳跃寻址，由转移指令指出<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/1.png" srcset="/img/loading.gif" width="450px" height="230px"></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>找到当前正在执行指令的数据地址，称为数据寻址。起始数据被存放在内存中，在指令执行的过程中，内存的数据可能被装入其他地方，所以数据的寻址涉及寄存器、内存单元、堆栈、I\O端口、立即数的访问。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/2.png" srcset="/img/loading.gif" width="350px" height="50px"></p><p>形式地址：指令字中的地址<br>有效地址：操作数的真实地址<br>约定 指令字长=存储子长=机器字长</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>这个寻址方式直接给出操作数，不需要给出地址去其他地方找操作数。<br>优点：只需要取出指令，便可立即获得操作数，采用立即寻址特征的指令只需要取指令时访问存储器，而在执行阶段不必再访问存储器。<br>缺点：由于A表示的就是立即数 ，因此A的位数限制了立即数表示的范围，例如，A占8位，则立即数的表示范围为-128-127，因为立即数都是补码表示的。<br>立即寻址方式通常用于对某寄存器或内存单元赋初值。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/3.png" srcset="/img/loading.gif" width="300px" height="100px"></p><ul><li>形式地址A就是操作数</li><li>指令执行阶段不访存</li><li>A的位数限制了立即数的范围</li></ul><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>通过直接寻址给出的地址取到操作数，然后再将操作数送往运算器或其他地方。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/4.png" srcset="/img/loading.gif" width="300px" height="100px"></p><ul><li>EA=A,有效地址由形式地址直接给出</li><li>执行阶段访问一次存储器</li><li>A的位数决定了该指令操作数的寻址范围</li><li>操作数的地址不易修改，只能修改A</li></ul><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>隐含寻址指指令字中不明显地给出操作数地址，其操作数地址隐含在操作码或某个寄存器中。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/5.png" srcset="/img/loading.gif" width="360px" height="220px"></p><ul><li>操作数地址隐含在操作码中</li><li>指令字中少了一个地址字段，可缩短指令字长</li></ul><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>直接寻址的地址码字段A的位数较小，因此寻址范围较小，间接寻址可以解决这个问题。<br>直接寻址是直接给出操作数的有效地址，即直接可以通过该地址找到操作数，但间接寻址指令给出的地址是操作数的有效地址的地址。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/6.png" srcset="/img/loading.gif" width="360px" height="220px"></p><ul><li>EA=(A)，有效地址由形式地址间接提供</li><li>执行指令阶段2次访存</li><li>可扩大寻址范围</li><li>便于编制程序</li></ul><h4 id="间接寻址编程举例"><a href="#间接寻址编程举例" class="headerlink" title="间接寻址编程举例"></a>间接寻址编程举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/7.png" srcset="/img/loading.gif" width="360px" height="220px"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>与直接寻址类似，在直接寻址的指令字中，地址码字段给出的是主存的地址，而在寄存器寻址的指令字中，地址码字段直接给出了寄存器编号Ri，则操作数的有效地址EA=Ri。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/8.png" srcset="/img/loading.gif" width="250px" height="280px"></p><ul><li>EA=R_i，有效地址即为寄存器编号</li><li>执行阶段不访存，只访问寄存器，执行速度快</li><li>寄存器个数有限，可缩短指令字长</li></ul><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/9.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(R_i)，有效地址在寄存器中</li><li>有效地址在寄存器中，操作数在寄存器中，执行阶段访存</li><li>便于编址循环程序</li></ul><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>操作数的有效地址需要通过某个基础地址来形成，基础地址需要设置一个基址寄存器(BR)，其操作数的有效地址EA等于指令字中的形式地址A与基址寄存器中的内容相加。<br>优点： 扩大操作数的寻址范围，便于解决多道程序问题。</p><h4 id="采用专用寄存器作基址寄存器"><a href="#采用专用寄存器作基址寄存器" class="headerlink" title="采用专用寄存器作基址寄存器"></a>采用专用寄存器作基址寄存器</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/10.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA = (BR)+A，BR为基址寄存器</li><li>可扩大寻址范围</li><li>有利于多道程序</li><li>BR内容由操作系统或管理程序确定</li><li>在程序的执行过程中BR内容不变，形式地址A可变</li></ul><h4 id="采用通用寄存器作基址寄存器"><a href="#采用通用寄存器作基址寄存器" class="headerlink" title="采用通用寄存器作基址寄存器"></a>采用通用寄存器作基址寄存器</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/11.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>由用户指定哪个通用寄存器作为基址寄存器</li><li>基址寄存器的内容由操作系统确定</li><li>在程序的执行过程中R0内容不变，形式地址A可变</li></ul><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>变址寻址的有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和。<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/12.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(IX)+A，IX为变址寄存器(专用)，通用寄存器也可以作为变址寄存器</li><li>可扩大寻址范围</li><li>IX的内容由用户给定</li><li>在程序的执行过程中IX内容可变，形式地址A不变</li><li>便于处理数组问题</li></ul><h4 id="设数据块首地址为D，求N个数的平均值"><a href="#设数据块首地址为D，求N个数的平均值" class="headerlink" title="设数据块首地址为D，求N个数的平均值"></a>设数据块首地址为D，求N个数的平均值</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/13.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/14.png" srcset="/img/loading.gif" width="350px" height="230px"></p><ul><li>EA=(PC)+A，A是相对于当前指令的位移量(可正可负，补码)</li><li>A的位数决定操作数的寻址范围</li><li>程序浮动</li><li>广泛用于转移指令</li></ul><h4 id="相对寻址举例"><a href="#相对寻址举例" class="headerlink" title="相对寻址举例"></a>相对寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/15.png" srcset="/img/loading.gif" width="350px" height="230px"></p><p>M随程序所在存储空间的位置不同而不同，而指令BNE*-3与ADD X，D相对位移量不变.<br>指令BNE*-3操作数的有效地址为EA=(M+3)-3=M</p><h4 id="按字节寻址的相对寻址举例"><a href="#按字节寻址的相对寻址举例" class="headerlink" title="按字节寻址的相对寻址举例"></a>按字节寻址的相对寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/16.png" srcset="/img/loading.gif" width="350px" height="200px"><br>设当前指令地址PC=2000H，转移后的目的地址为2008H，因为取出JMP*+8后，PC=2002H，故JMP*+8指令的第二字节为2008H-2002H=06H。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><h4 id="堆栈的特点"><a href="#堆栈的特点" class="headerlink" title="堆栈的特点"></a>堆栈的特点</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/17.png" srcset="/img/loading.gif" width="350px" height="200px"></p><ul><li>硬堆栈，多个寄存器</li><li>软堆栈，指定的存储空间</li></ul><p>先进后出(一个入出口)，栈顶地址由SP指出<br>进栈(SP)-1-&gt;SP，出栈(SP)+1-&gt;SP</p><h4 id="堆栈寻址举例"><a href="#堆栈寻址举例" class="headerlink" title="堆栈寻址举例"></a>堆栈寻址举例</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/18.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h4 id="SP的修改和主存编址方法有关"><a href="#SP的修改和主存编址方法有关" class="headerlink" title="SP的修改和主存编址方法有关"></a>SP的修改和主存编址方法有关</h4><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/19.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="九种寻址方式总结"><a href="#九种寻址方式总结" class="headerlink" title="九种寻址方式总结"></a>九种寻址方式总结</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/22.png" srcset="/img/loading.gif" width="800px" height="350px"></p><h1 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h1><h2 id="设计指令格式时应考虑的各种因素"><a href="#设计指令格式时应考虑的各种因素" class="headerlink" title="设计指令格式时应考虑的各种因素"></a>设计指令格式时应考虑的各种因素</h2><ul><li>指令系统的兼容性</li><li>其他因素<ul><li>操作类型，包括指令个数及操作的难易程度</li><li>数据类型，确定哪些数据类型可参与操作</li><li>指令格式<ul><li>指令字长是否固定</li><li>操作码位数，是否采用扩展操作码技术</li><li>地址码位数，地址个数、寻址方式类型</li></ul></li><li>寻址方式，指令寻址、操作数寻址</li><li>寄存器个数，寄存器的多少直接影响指令的执行时间</li></ul></li></ul><h3 id="IBM360"><a href="#IBM360" class="headerlink" title="IBM360"></a>IBM360</h3><p><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/20.png" srcset="/img/loading.gif" width="350px" height="230px"></p><h3 id="Intel-8086"><a href="#Intel-8086" class="headerlink" title="Intel 8086"></a>Intel 8086</h3><ol><li>指令字长 1~6个字节<br>INC AX 1字节<br>MOV WORD PTR[0204],0138 6字节</li><li>地址格式<br><img src="/2020/05/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8ERISC%E6%8A%80%E6%9C%AF/21.png" srcset="/img/loading.gif" width="350px" height="230px"></li></ol><h1 id="RISC技术"><a href="#RISC技术" class="headerlink" title="RISC技术"></a>RISC技术</h1><h2 id="RISC的产生和发展"><a href="#RISC的产生和发展" class="headerlink" title="RISC的产生和发展"></a>RISC的产生和发展</h2><ul><li>RISC(Reduced Instruction Set Computer)</li><li>CISC(Complex Instruction Set Computer)</li></ul><p>典型程序中80%的语句仅仅使用处理机中20%的指令，执行频度高的简单指令，因复杂指令的存在，执行速度无法提高，于是提出用20%简单指令组合不常用的80%指令功能。</p><h2 id="RISC的主要特性"><a href="#RISC的主要特性" class="headerlink" title="RISC的主要特性"></a>RISC的主要特性</h2><ul><li>选用使用频度较高的一些简单指令，复杂指令的功能由简单指令组合</li><li>指令长度固定，指令格式种类少、寻址方式少</li><li>只能LOAD/STORE指令访存</li><li>CPU中有多个通用寄存器</li><li>采用流水技术 ，一个时钟周期内 完成一条指令</li><li>采用组合逻辑实现控制器</li></ul><h2 id="CISC的主要特征"><a href="#CISC的主要特征" class="headerlink" title="CISC的主要特征"></a>CISC的主要特征</h2><ul><li>系统指令复杂庞大，各种指令使用频度相差大</li><li>指令 长度不固定、指令格式种类多、寻址方式多</li><li>访存 指令 不受限制</li><li>CPU 中设有 专用寄存器</li><li>大多数指令需要 多个时钟周期 执行完毕</li><li>采用 微程序 控制器</li></ul><h2 id="RISC和CISC的比较"><a href="#RISC和CISC的比较" class="headerlink" title="RISC和CISC的比较"></a>RISC和CISC的比较</h2><ol><li>RISC更能充分利用VLSI芯片的面积</li><li>RISC 更能提高计算机运算速度，指令数、指令格式、寻址方式少，通用寄存器多，采用组合逻辑，便于实现指令流水</li><li>RISC便于设计，可降低成本，提高可靠性</li><li>RISC不易实现指令系统兼容</li></ol><hr></div><br><div><p><span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86">计算机组成原理</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://yoursite.com/2020/05/18/寻址方式与RISC技术/",this.page.identifier="/2020/05/18/寻址方式与RISC技术/"},oldLoad=window.onload;window.onload=function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.src="//inaho-top.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a></noscript></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div id="footerContent" class="rgba-black-slight"><footer class="pt-5"><div style="color:#fff" class="text-center py-3"><a style="color:#fff" href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo支持</b></a> <i class="iconfont icon-love"></i> <a style="color:#fff" href="https://disqus.com/" target="_blank" rel="nofollow noopener"><b>Disqus 评论系统 </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>主题Fluid </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://www.pixiv.net/" target="_blank" rel="nofollow noopener"><b>图片 Pixiv</b></a><br>&nbsp;<span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp; &nbsp;<span id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;<br></div></footer></div><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="/lib/popper/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.7/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="/lib/tocbot/tocbot.min.js"></script><script src="/js/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/lib/prettify/prettify.min.js"></script><script>$(document).ready((function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()}))</script><script src="/lib/typed/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","寻址方式与RISC技术&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready((function(){$(".typed-cursor").addClass("h2"),typed.start()}))</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options={placement:"right",visible:"false"};var el="h1,h2,h3,h4,h5,h6".split(","),res=[];for(item of el)res.push(".markdown-body > "+item);anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each((function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)}))</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });</script><script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">$("#background").removeClass("banner-bg"),$("body").addClass("banner-bg");var postToTopHight=$("#board").offset().top;$(window).scroll((function(){document.body.scrollTop+document.documentElement.scrollTop>=postToTopHight?($("#background").removeClass("rgba-black-slight"),$("#mainContent").removeClass("rgba-black-slight"),$("#footerContent").removeClass("rgba-black-slight")):($("#background").addClass("rgba-black-slight"),$("#mainContent").addClass("rgba-black-slight"),$("#footerContent").addClass("rgba-black-slight"))}))</script></body></html>