<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>线性表和树表的查找 ~ inaho</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.7/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><style type="text/css">.banner-bg{background-image:url(/img/bg1.jpg);background-position:center;background-repeat:repeat-y;background-size:cover;background-attachment:fixed}</style><meta name="generator" content="Hexo 4.2.0"></head><body class="banner-bg"><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>阴月有晴</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2 rgba-black-slight" id="background"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期日, 六月 14日 2020, 11:29 上午</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">9k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">33 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main id="mainContent" class="rgba-black-slight"><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><h1 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h1><ul><li><strong>查找表</strong>: 查找表(Search Table)是同一类型数据元素的集合.</li><li><strong>关键字</strong>: 数据元素中某个数据项的值，又称为<strong>键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项，称为<strong>关键码</strong>.如果此关键字可以唯一的标识一个记录，则称此关键字为<strong>主关键字</strong>(Primary Key),对不同地记录，主关键字均不同，主关键字所在地数据项称为<strong>主关键码</strong>.对于可以识别多个数据元素地关键字，称之为<strong>次关键字</strong>(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素地关键字，对应地数据项是<strong>次关键码</strong>。</li><li><strong>查找</strong>: 查找是根据某个给定的值，在查找表中找到一个关键字等于给定值的记录或数据元素，如果表中存在这样的元素，则称<strong>查找成功</strong>，否则<strong>查找失败</strong>。</li><li>动态查找表与静态查找表: 若在查找的同时对表做修改操作，则相应的表称为<strong>动态查找表</strong>，否则称之为<strong>静态查找表</strong>。<ul><li>静态查找表是只作查找操作的查找表，主要操作是查询某个特定数据元素是否在表中，或者检索某个特定的数据元素和各种属性</li><li>动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li></ul></li><li><strong>平均查找长度</strong>: 为确定记录在查找表中的位置，需要和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的<strong>平均查找长度</strong>。</li></ul><h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找的过程为: 从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。<br>数据元素类型定义:</p><pre><code>typedef struct{
    KeyType key;        //关键字域
    InfoType otherinfo;    //其他域
}ElemType;
typedef struct{
    ElemType *R;        //存储空间基地址
    int length;            //当前长度
}SSTable;
</code></pre><p>假设从1位置开始查找，0位置不用，查找算法如下:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    for(i=ST.length;i&gt;=1;--i){
        if(ST.R[i].key == key) return i;
    }
    return 0;
}
</code></pre><p>在上面的算法中，每一步都需要检测整个表是否查找完毕，即需要判断i&gt;=1是否成立，改进此算法，可以增加一个哨兵，例如ST.R[0]关键字赋值key，如下例所示:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    ST.R[0].key = key;
    for(i=ST.length;ST.R[i].key != key;--i);
    return i;        //返回0代表没找到
}
</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>设置监视哨，可以免去查找过程中每一步进行检测整个表是否查找完毕，实践证明，这个改进能使顺序表在大于1000长度的表中，进行一次查找所需的平均时间减半，两个时间复杂度都为O(n)。<br>顺序查找的优点: 算法简单，对表结构无要求。<br>顺序查找的缺点: 平均查找长度较大，查找效率低，当n很大时，不宜使用顺序查找。</p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找也称二分查找，它是一种效率较高的查找方法，但折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="折半查找的过程"><a href="#折半查找的过程" class="headerlink" title="折半查找的过程"></a>折半查找的过程</h3><p>从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功，如果给定值大于或小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，重复操作。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>为了标记查找过程中每一次的查找区间，分别用low和high表示区间的上下限，用mid表示区间的中间位置。</p><ol><li>置查找区间初值，low为1，high为表长。</li><li>当low小于等于high时，循环执行以下操作:<ol><li>mid取值为low和high的中间值</li><li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid</li><li>若不相等则利用中间位置记录将表对分成前、后两个子表，如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1.</li></ol></li><li>循环结束，说明查找区间为空，则查找失败，返回0.</li></ol><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><pre><code>int Search_Bin(SSTable ST,KeyType key){
    low=1;
    high=ST.length;
    while(low &lt;= high){
        mid = (low+high)/2;
        if(key == ST.R[mid].key) return mid;
        else if(key &lt; ST.R[mid].key) high=mid-1;
        else low=mid+1;
    }
    return 0;
}
</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>折半查找的过程可用二叉树描述，树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号，把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/1.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度，具有n个结点的判定树深度为$log_2n+1$,折半查找的时间复杂度为$O(log_2n)$.</p><ul><li>折半查找的优点: 比较次数少，查找效率高</li><li>折半查找的缺点: 只能用于顺序表查找，查找前需要排序。</li></ul><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找是每次将查找区间缩小1/2进行查找，如果要在取值范围0-10000之间100个元素从小到大均匀分布的数组中查找5，我们自然考虑从数组下标较小的开始查找。<br>折半查找代码的$mid=(low+high)/2$经过变换后可以得到$mid=low+1/2(high-low)$,这个等式可以改进为$mid=low+((key-a[low])/(a[high]-a[low])(high-low))$，将$1/2$改为了$(key-a[low])/(a[high]-a[low])$，这种方法就是<strong>插值查找法</strong>。<br>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式。</p><pre><code>mid = low + (high-low) * (key-a[low]) / (a[high]-a[low]);     //修改折半查找的mid
</code></pre><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>折半查找是每次查找总是一分为二，插值查找是对折半查找的改进，使其在数据分布均匀情况下查找效率更高，而斐波那契查找，利用了黄金分割原理来实现，斐波那契数列如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/2.png" srcset="/img/loading.gif" width="500px" height="80px"></p><p>斐波那契搜索就是在折半查找的基础上根据斐波那契数列进行分割的，在平均性能上来说，斐波那契查找要由于折半查找，但在最坏情况下，例如key=1，那么始终处于左侧长半区查找，查找效率就低于折半查找。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>斐波那契查找算法的核心在于:</p><ul><li>key值与第mid=（low+high）/2相等，mid位置的元素即为所求；</li><li>key值大于第mid=（low+high）/2，则令 low=mid+1；</li><li>key值小于第mid=（low+high）/2，则令high=mid-1。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>int Fibonacci_Search(int *a,int n,int key){
    int low,high,mid,i,k;
    low=1;            //最低下标为记录首位
    high=n;            //最高下标为记录末位
    k=0;
    while(n &gt; F[k]-1) k++;    //计算n位于斐波那契数列的位置
    for(i=n;i&lt;F[k]-1;i++) a[i]=a[n];    //将不满的数值补全

    while(low&lt;=high){
        mid = low+F[k-1]-1;        //计算当前分隔的下标
        if(key&lt;a[mid]){
            high = mid-1;
            k=k-1;
        }else if(key &gt; a[mid]){
            low=mid+1;
            k=k-2;
        }else{
            if(mid &lt;= n) return mid;
            else return n;
        }
    }
    return 0;
}
</code></pre><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>前面的几种查找方法都是基于有序的基础之上的，如果数据集增长很快，要保证记录全部按照当中某个关键字有序，时间代价很高，所以这种数据通常按先后顺序存储，对于这种查找表，需要利用索引来快速查找数据。<br>索引是为了加快查找速度而设计的一种数据结构，索引就是把每一个关键字和它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息，索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引的分类: <strong>线性索引</strong>、<strong>树形索引</strong>、<strong>多级索引</strong>，线性索引就是将索引集合组织为线性结构，也成为索引表。</p><h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图所示:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/4.png" srcset="/img/loading.gif" width="350px" height="250px"></p><p>稠密索引要应对的可能是成千上万的数据，因此对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列，索引项有序意味着，在查找关键字时，可以用到折半、插值、斐波那契等查找算法，但如果数据集非常大，意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能需要反复访问磁盘，查找性能大大下降。</p><h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。<br>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p><ul><li>块内无序，即每一块内的记录不要求有序</li><li>块间有序，例如要求第二块的所有记录的关键字均大于第一块中所有记录的关键字，块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引叫做分块索引。</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大。</li><li>存储了块中的记录个数，以便于循环使用。</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找又称为<strong>索引顺序查找</strong>，这是一种性能介于顺序查找和折半查找之间的一种查找方法，在分块索引表中查找，分为两步进行:</p><ol><li>在分块索引表中查找要查关键字所在的块</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。</li></ol><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。<br>索引项的通用结构是次关键码、记录号表，其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。</p><h1 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h1><p>折半查找效率虽然较高，但是由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为了<strong>维护表的有序性</strong>，需要移动表中很多记录，导致额外浪费时间。<br>若要对动态查找表进行高效率的查找，可以采用几种特殊的二叉树作为查找表的组织方式。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。</p><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树:</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/5.png" srcset="/img/loading.gif" width="300px" height="250px"><br>例如上图是对序列{62，88，58，47，35，73，51，99，37，93}进行构造的二叉排序树。</p><h4 id="二叉排序树的二叉链表存储结构"><a href="#二叉排序树的二叉链表存储结构" class="headerlink" title="二叉排序树的二叉链表存储结构"></a>二叉排序树的二叉链表存储结构</h4><pre><code>typedef struct{
    KeyType key;            //关键字项
    InfoType otherinfo;        //其他数据项
}ElemType;
typedef struct BSTNode{
    ElemType data;            //数据域，包括关键字和其他数据项
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;
</code></pre><h3 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h3><p>二叉排序树可以看作一个有序表，因此在二叉排序树上进行查找和折半查找类似。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则查找失败，返回空指针</li><li>若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较:<ul><li>若key等于T-&gt;data.key，则查找成功，返回根结点地址</li><li>若key小于T-&gt;data.key，则递归查找左子树</li><li>若key大于T-&gt;data.key，则递归查找右子树</li></ul></li></ul><h4 id="算法代码示例"><a href="#算法代码示例" class="headerlink" title="算法代码示例"></a>算法代码示例</h4><pre><code>BSTree SearchBST(BSTree T,KeyType key){
    if((!T) || key == T-&gt;data.key)    return T;
    else if(key &lt; T-&gt;data.key) return SearchBST(T-&gt;lchild,key);
    else return SearchBST(T-&gt;rchild,key);
}
</code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>在二叉排序树上查找其关键字等于给定值的结点的过程，恰好是走完了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1(或是结点所在层次数)。<br>和折半查找类似，与给定值比较的关键字个数不超过数的深度，但折半查找长度为n的顺序表的判定树是唯一的，而含n个结点的二叉排序树不唯一。<br>如果给定的含n个记录的序列有序，那么构造二叉排序树时，不断向右子树添加结点，二叉排序树会变成一个深度为n的单支树，其平均查找长度为(n+1)/2，这就是最坏的情况，而最好的情况便是和二分查找的判定树类似，但二叉排序树适合维护，对于经常需要添加删除的序列来说，显然适合使用二叉排序树。</p><h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p>二叉排序树的插入操作以查找为基础的，将一个关键字值为key的结点插入到二叉排序树，需要从根结点向下查找，当树中不存在关键字等于key的结点时，才能进行插入。<br>新结点的插入一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则待插入结点*S作为根结点插入空树中。</li><li>若二叉排序树非空，则将key与根结点的关键字T-&gt;data.key进行比较。<ul><li>若key小于T-&gt;data.key，则将*S插入左子树</li><li>若key大于T-&gt;data.key，则将*S插入右子树</li></ul></li></ul><blockquote><p>中序遍历一棵二叉排序树，可以得到一个结点值递增的有序序列。</p></blockquote><h4 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void InsertBST(BSTree &amp;T,ElemType e){
    if(!T){
        S = new BSTNode;
        S-&gt;data = e;
        S-&gt;lchild = S-&gt;rchild = NULL;
        T = S;            //新结点插入找到的位置
    }
    else if(e.key &lt; T-&gt;data.key) InsertBST(T-&gt;lchild,e);
    else if(e.key &gt; T-&gt;data.key) InsertBST(T-&gt;rchild,e);
}
</code></pre><p>二叉排序树插入的基本过程是查找，所以时间复杂度同查找一养，也是$O(log_2n)$.</p><h3 id="二叉排序树的创建"><a href="#二叉排序树的创建" class="headerlink" title="二叉排序树的创建"></a>二叉排序树的创建</h3><p>二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>将二叉排序树T初始化为空树</li><li>读入一个关键字为key的结点</li><li>如果读入的关键字key不是输入结束标志，则循环执行以下操作<ul><li>将此结点插入二叉排序树T中</li><li>读入一个关键字为key的结点</li></ul></li></ul><h4 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void CreatBST(BSTree &amp;T){
    T = NULL;
    cin &gt;&gt; e;
    while(e.key != ENDFLAG){    //ENDFLAG表示输入结束标志
        InsertBST(T,e);
        cin &gt;&gt; e;    
    }
}
</code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>假设有n个结点，则需要插入n次，而插入一个结点的算法时间复杂度为$O(log_2n)$，则创建二叉排序树的算法时间复杂度为$O(nlog_2n)$.</p><h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>被删除的结点可能是二叉排序树中的任何结点，删除结点后，要根据其位置不同修改双亲结点及相关结点的指针，以保持二叉排序树的特性。</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/7.png" srcset="/img/loading.gif" width="500px" height="350px"></p><p>从二叉排序树的根结点开始查找关键字为key的待删结点，分三种情况讨论:</p><ul><li>若待删结点为叶子结点，由于删除叶子结点不破坏树的整体结构，因此只需要修改其双亲的结点指向空即可。</li><li>若待删结点只有左子树或者只有右子树，只要使其左子树或右子树称为其双亲结点的左子树即可。</li><li>若待删结点的左右子树均不为空，为了保证删除该结点后，其他元素之间的相对位置不变，有以下两种方案:<ul><li>使待删结点的左子树为其双亲结点的左子树，然后待删结点的右子树为其直接前驱的右子树</li><li>令待删结点的直接前驱代替待删结点，然后删除此结点的直接前驱</li></ul></li></ul><p>第二种方案图例如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/6.png" srcset="/img/loading.gif" width="500px" height="230px"></p><p>显然，前一种处理方法可能增加树的深度，而后一种方法是以被删结点左子树中关键字最大的结点(左子树中最大的结点一定没有右子树)代替被删结点，然后从左子树中删除这个结点，这种方法更好。</p><h4 id="算法示例-2"><a href="#算法示例-2" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void DeleteBST(BSTree &amp;T,KeyType key){
    //查找关键字值等于key的结点
    p = T; 
    f = NULL;                    //f保存p的双亲结点
    while(p){
        if(p-&gt;data.key == key) break;
        f = p;
        if(p-&gt;data.key &gt; key) p = p-&gt;lchild;
        else p = p-&gt;rchild;
    }
    if(!p) return;

    //被删结点的左右子树均不为空
    q=p;
    if((p-&gt;lchild) &amp;&amp; (p-&gt;rchild)){
        s = p-&gt;lchild;                        //找到被删结点的直接前驱
        while(s-&gt;rchild){
            q=s;                            //保存待删结点的直接前驱的双亲结点，用于重接
            s=s-&gt;rchild;
        }
        p-&gt;data = s-&gt;data;                    //将待删结点的直接前驱来替换待删结点

        if(q != p){
            q-&gt;rchild = s-&gt;lchild;            //重接q的右子树
        }
        else{
            q-&gt;lchild = s-&gt;lchild;            //重接q的左子树
        }
        delete s;
        return;
    }else if(!p-&gt;rchild){                    //被删结点无右子树
        p = p-&gt;lchild;
    }else if(!p-&gt;lchild){                    //被删结点无左子树
        p = p-&gt;rchild;
    }

    //p指向的子树挂接到其双亲结点的对应位置
    if(!f) T=p;                                //被删结点为根结点
    else if(q == f-&gt;lchild) f-&gt;lchild = p;
    else f-&gt;rchild = p;
    delete q;
}
</code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>二叉排序树删除的基本过程也是查找，所以算法时间复杂度为$O(log_2n)$.</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>二叉排序树查找算法的性能取决于树的结构，而树的结构取决于给定数据是否有序，对于有序的数据进行构造二叉排序树，树的结构会是一棵深度为数据长度的单支树，查找效率低，事实上，树的高度越小，查找效率越高，为了使二叉排序树的高度尽量小，前苏联数学家提出了<strong>平衡二叉树</strong>的概念，也成为<strong>AVL</strong>树。</p><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/8.png" srcset="/img/loading.gif" width="500px" height="300px"></p><p>平衡二叉树或者是空树，或者是具有下列特征的二叉排序树:</p><ul><li>左子树和右子树的深度之差的绝对值不超过1</li><li>左子树和右子树也是平衡二叉树</li><li>平衡二叉树必须是二叉排序树</li></ul><p>二叉树上结点的平衡因子定义为该结点左子树与右子树的深度只差。</p><h3 id="AVL的平衡调整方法"><a href="#AVL的平衡调整方法" class="headerlink" title="AVL的平衡调整方法"></a>AVL的平衡调整方法</h3><p>在二叉排序树构造的过程中，如果新加入的结点破环了平衡二叉树的特性，就需要对树进行调整，调整方法为: 找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为<strong>最小不平衡子树</strong>，可将重新平衡的范围局限于这棵子树。</p><p>假设有一个数组a[10]={3,2,1,4,5,6,7,10,9,8}需要构建二叉排序树，在没有了解二叉平衡树之前，根据二叉排序树的特性会构建成如下图1的样子，树的深度为8，查找效率是很低的。当我们学了平衡二叉树之后会构建成如下图2的样子，树的深度只有4，效率提高了一倍。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/9.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>首先根据二叉排序树的特性插入结点”3”，然后再插入”2”，此时结点”3”的bf为1，再插入”1”，此时结点”2”的bf值变为2，如图1所示，树已经不平衡了所以需要调整树，因为bf值为正，所以需要将整个树进行右旋，此时结点”2”成为根结点，结点”3”成为2的右孩子，如图2所示，然后再插入结点”4”，bf并没有发生改变。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/10.png" srcset="/img/loading.gif" width="450px" height="150px"></p><p>插入结点”5”之后，结点”3”,”4”,”5”组成了最小不平衡子树，此时结点”3”的bf值为-2，由于bf值是负值，所以需要对这棵最小不平衡子树进行左旋，如图5，此时整棵树又达到平衡。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/11.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>继续插入结点”6”，此时根结点”2”的bf值变为-2，所以需要对根结点进行左旋，但由于本来结点3是4的左孩子，旋转后需要满足二叉排序树的特性，因此它成了结点2的右孩子，如图7所示。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/12.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>插入结点”7”,发现结点”5”的bf值为-2，左旋由结点”5”,”6”,”7”组成的最小不平衡子树，如图9所示，此时整棵树达到平衡。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/13.png" srcset="/img/loading.gif" width="400px" height="150px"></p><p>当插入结点”10”时，结构无变化 ，再增加结点”9”，此时结点”7”的bf值变为-2，理论上只需要旋转最小不平衡子树”7”,”9”,”10”即可，但左旋转后，结点”9”成了结点”10”的右孩子，不符合二叉排序树的特性，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/14.png" srcset="/img/loading.gif" width="400px" height="180px"></p><p>通过观察发现，结点”7”的bf值为-2，但结点”10”的bf值为1，它们的bf值政府不统一，而前几次的旋转，最小不平衡子树的根结点和它的子结点符号都是相同的，因此需要先使符号统一，所以对结点”9”和结点”10”进行右旋，使结点”10”成为”9”的右子树，结点”9”的bf值为-1，此时不平衡子树的根结点与子结点符号统一，再对结点”7”进行左旋，得到图”13”，然后再加入结点”8”<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/15.png" srcset="/img/loading.gif" width="400px" height="200px"></p><p>此时结点”6”的bf值为-2，结点”9”的bf值为1，符号不统一，因此需要首先以9为根结点，进行右旋得到图15，此时结点”6”与结点”7”的bf值都为负，再以6为根结点左旋，最终得到最后的平衡二叉树如图16所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/16.png" srcset="/img/loading.gif" width="400px" height="180px"></p><h4 id="调整AVL的四种情况"><a href="#调整AVL的四种情况" class="headerlink" title="调整AVL的四种情况"></a>调整AVL的四种情况</h4><p>假设不平衡子树的根结点为A</p><ul><li>在A左子树根结点的左子树上插入结点，需要进行一次右旋</li><li>在A右子树根结点的右子树上插入结点，需要进行一次左旋</li><li>在A左子树根结点的右子树上插入结点，需要先对子树进行逆时针左旋使bf符号相同，然后再顺时针右旋。</li><li>在A右子树根结点的左子树上插入结点，需要先对子树进行顺时针右旋使bf符号相同，然后再逆时针左旋。</li></ul><h3 id="AVL代码示例"><a href="#AVL代码示例" class="headerlink" title="AVL代码示例"></a>AVL代码示例</h3><h4 id="存储结构代码示例"><a href="#存储结构代码示例" class="headerlink" title="存储结构代码示例"></a>存储结构代码示例</h4><p>在树结点结构中增加一个bf代表平衡因子，平衡因子的绝对值如果大于2，说明树不平衡，需要进行调整。</p><pre><code>typedef struct BiTNode{
    int  data;                            //结点数据
    int bf;                                //结点的平衡因子
    struct BiTNode *lchild,*rchild;        //左右孩子指针
}BiTNode,*BiTree;
</code></pre><h4 id="旋转代码示例"><a href="#旋转代码示例" class="headerlink" title="旋转代码示例"></a>旋转代码示例</h4><p><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/17.png" srcset="/img/loading.gif" width="500px" height="200px"></p><p>右旋操作时，当传入一个二叉排序树p，将它的左孩子结点定义为L，将L的右子树变成p的左子树，然后将p改为L的右子树，最后将L替换p成为根结点，这样就完成了一次右旋操作，如下图所示，N为插入结点，左旋操作大同小异。</p><pre><code>void R_Rotate(BiTree *p){        //右旋操作
    BiTree L;
    L = (*p)-&gt;lchild;
    (*p)-&gt;lchild=L-&gt;rchild;
    L-&gt;rchild = (*p);
     *p = L;
}
void L_Rotate(BiTree *p){        //左旋操作
    BiTree R;
    R = (*p)-&gt;rchild;
    (*p)-&gt;rchild = R-&gt;lchild;
    R-&gt;lchild = (*p);
    *p = R;
}
</code></pre><h4 id="平衡调整代码示例"><a href="#平衡调整代码示例" class="headerlink" title="平衡调整代码示例"></a>平衡调整代码示例</h4><pre><code>#define LH +1    //左高
#define EH 0    //等高
#define RH -1    //右高
void LeftBalance(BiTree *T){    //T是不平衡子树，对T进行左平衡旋转处理，且左子树高度大于右子树高度
    BiTree L,Lr;
    L = (*T)-&gt;lchild;        //左孩子赋给L
    switch(L-&gt;bf){
        case LH:            //新结点插入在T的左孩子的左子树上
            (*T)-&gt;bf = L-&gt;bf = EH;    //将bf值改为0
            R_Rotate(T);            //进行右旋操作
            break;
        case RH:            //新结点插入在T的左孩子的右子树上
            Lr = L-&gt;rchild;
            //修改bf值
            switch(Lr-&gt;bf){
                case LH: 
                    (*T)-&gt;bf = RH;
                    L-&gt;bf = EH;
                    break;
                case EH: 
                    (*T)-&gt;bf = L-&gt;bf = EH;
                    break;
                case RH:
                    (*T)-&gt;bf = EH;
                    L-&gt;bf = LH;
                    break;
            }
            Lr-&gt;bf = EH;
            //进行双旋操作，先对左子树左旋，再对根右旋
            L_Rotate(&amp;(*T)-&gt;lchild);
            R_Rotate(T);
    }
}
void RightBalance(BiTree *T){        //右平衡
    BiTree R,Rr;
    R = (*T)-&gt;rchild;
    switch(R-&gt;bf){
        case LH:            //新结点插入在右孩子的右子树上
            (*T)-&gt;bf = R-&gt;bf = EH;
            L_Rotate(T);    //左旋操作
            break;
        case RH:            //新结点插入在右孩子的左子树上
            Rr = R-&gt;lchild;
            //修改bf值
            switch(Rr-&gt;bf){
                case LH: 
                    (*T)-&gt;bf = RH;
                    R-&gt;bf = EH;
                    break;
                case EH: 
                    (*T)-&gt;bf = R-&gt;bf = EH;
                    break;
                case RH:
                    (*T)-&gt;bf = EH;
                    R-&gt;bf = LH;
                    break;
            }
            Rr-&gt;bf = EH;
            R_Rotate(&amp;(*T)-&gt;rchild);    //先右旋
            L_Rotate(T);                //再左旋
    }
}
</code></pre><h4 id="AVL树的插入操作"><a href="#AVL树的插入操作" class="headerlink" title="AVL树的插入操作"></a>AVL树的插入操作</h4><pre><code>//若在平衡二叉排序树中不存在和e有相同关键字的结点，则插入此结点。
//taller反映T长高与否
Status InsertAVL(BiTree *T,int e,Status *taller){
    //创建根结点
    if(!*T){
        *T = (BiTree)malloc(sizeof(BiTNode));
        (*T)-&gt;data = e;
        (*T)-&gt;lchild = (*T)-&gt;rchild = NULL;
        (*T)-&gt;bf = EH;
        *taller = TRUE;
    }
    else{
        if(e == (*T)-&gt;data){        //如果树中存在和e关键字相同的结点则插入失败
            *taller = FALSE;        //没长高
            return FALSE;
        }
        if(e &lt; (*T)-&gt;data){            //在T的左子树中搜索
            if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))    return FALSE;

            if(taller){                //已经插入T的左子树，且左子树长高
                //检查T是否平衡
                switch((*T)-&gt;bf){
                    case LH:        //原本左高右低，先又增左，需要左平衡处理
                        LeftBalance(T);
                        *taller = FALSE;
                        break;
                    case EH:        //原本等高，现在左子树增高，树也要增高
                        (*T)-&gt;bf = LH;
                        *taller = TRUE;
                        break;
                    case RH:        //原本右高左低，现在等高
                        (*T)-&gt;bf = EH;
                        *taller = FALSE;
                        break;
                }
            }
        }
        else{                        //在T的右子树中搜索
            if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) return FALSE;
            if(*taller){
                switch((*T)-&gt;bf){
                    case LH:        //原本左高右低，现在等高
                        (*T)-&gt;bf = EH;
                        *taller = FALSE;
                        break;
                    case EH:        //原本等高，现在右高，树也高
                        (*T)-&gt;bf = RH;
                        *taller = TRUE;
                    case RH:        //原本右高，现在增右，需要右平衡处理
                        RightBalance(T);
                        *taller = FALSE;
                        break;
                }
            }
        }
    }
    return TRUE;
}

// 测试代码
int main(){
    int i;
    int a[10] = {3,2,1,4,5,6,7,10,9,8};
    BiTree T = NULL;
    Status taller;
    for(i = 0;i &lt; 10;i++){
        InsertAVL(&amp;T,a[i],&amp;taller);
    }
    return 0;
}
</code></pre><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>因为AVL树上任何结点的左右子树深度之差不超过1，因此其查找的时间复杂度为$O(log_2n)$.</p><h2 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h2><p>之前介绍的查找方法用于存储在计算机内存中较小的文件，统称为内查找法。如果文件很大，且存放于外存进行查找，涉及到这样的外部存储设备，关于时间复杂度的计算会发生变化，需要考虑对硬盘等外部设备的访问时间以及访问次数，之前所谈的树，都是一个结点可以有多个孩子，但它自身只存储一个元素，在元素非常多时，树的度就会非常大，为此引入了<strong>多路查找树</strong>的概念。<br>多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><ul><li>2-3树其中每一个结点都能具有两个孩子(称为2结点)或者三个孩子(称为3结点)。</li><li>一个2结点包含一个元素和两个孩子(或无孩子)，且与二叉排序树类似 ，左子树包含的元素小于该元素，右子树包含的元素大于该元素，但结点只能有2或3个孩子，或者无孩子。</li><li>一个3结点包含一小一大两个元素和三个孩子(或无孩子)，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</li></ul><p>2-3树中所有的叶子都在同一层次，如下图所示:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/18.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h4 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h4><p>2-3树插入一个元素的过程可能会对该树的其余结点产生连锁反应。</p><ul><li>对于空树，插入一个2结点即可</li><li>插入一个结点到一个2结点的叶子上，需要将其升级为3结点即可，如下图所示，将结点”3”插入结点”1”所在位置，需要将结点”1”升级为3结点。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/19.png" srcset="/img/loading.gif" width="500px" height="100px"></li><li>往3结点中插入一个新元素，因为3结点本身是最大容量，因此需要拆分。</li></ul><p>如果要向左图插入元素”5”，它应该要插入到拥有6、7元素的3结点位置，但元素已满，无法添加，但其双亲结点是一个2结点，所以将其双亲升级为3结点，使4、6称为此结点的元素，”5”成为它的中间孩子，”7”为它的右孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/20.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>如果要插入结点和其双亲结点都为3结点，但其双亲的双亲结点”8”是个2结点，因此将9、10拆分，12、14也拆分，结点”8”升级为3结点，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/21.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>如果要插入结点和其之上所有双亲结点都是3结点，需要将1、3拆分，4、6拆分，8、12也拆分，形成如下图所示的树<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/22.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>由此可见，2-3树插入的传播效应导致了根结点的拆分，因此树的高度增加。</p><h4 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h4><ul><li>所删元素位于一个3结点的叶子结点上，只需要在该结点处删除该元素即可，不影响树的整体结构，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/23.png" srcset="/img/loading.gif" width="500px" height="100px"></li><li>所删元素位于一个2结点上，但如果删除此结点，2结点只拥有一个孩子，不满足定义，因此需要分为四种情况处理</li></ul><p>此结点的双亲也是2结点，且拥有一个3结点的右孩子，删除结点1需要左旋处理，6成为双亲，4成为6的左孩子17是6的右孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/24.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>此结点的双亲是2结点，它的右孩子也是2结点，此时删除结点1，如果直接左旋会造成没有右孩子，因此需要让结点7变成3结点，因此使元素8下来，让元素9补充8的位置，然后再用左旋的方式，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/25.png" srcset="/img/loading.gif" width="500px" height="100px"></p><p>此结点的双亲是一个3结点，如果删除此结点，不满足2-3树的特性，因此需要将结点进行拆分，使12、13合并成为左孩子，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/26.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>如果当前树是一个满二叉树，需要将2-3树的层数减少，将8的双亲和左子树6合并为一个3结点，将14和9合并为一个3结点，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/27.png" srcset="/img/loading.gif" width="350px" height="100px"></p><ul><li>所删除的元素位于非叶子的分支结点，通常将树按中序遍历后得到此元素的前驱或后继元素，然后考虑让它们补位。</li></ul><p>如果要删除的分支结点4是2结点，它的前驱是1后继是6，由于6、7是3结点，所以需要用6来补位，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/28.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>如果要删除的分支结点是3结点的某个元素，需要将3结点的左孩子10上升到删除位置合适，如下图所示<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/29.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>2-3树的删除是有规律的，其他情况不一一解释。</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是2-3树的一个扩展，多了一个4结点的使用，一个4结点包含小中大三个元素和4个孩子(或无孩子)，一个4结点要么无孩子，要么具有4个孩子。<br>4结点的左子树包含小于最小元素的元素，第二子树包含大于最小元素小于第二元素的元素，第三子树包含大于第二元素小于最大元素的元素，右子树包含大于最大元素的元素。<br>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程如下:<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/30.png" srcset="/img/loading.gif" width="500px" height="200px"></p><p>2-3-4树的删除过程，删除顺序是1、6、3、4、5、2、9<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/31.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树(B-tree)是一种平衡的多路查找树，2-3树与2-3-4树都是B树的特例，结点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树。</p><h4 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B-树的定义"></a>B-树的定义</h4><p>一棵m阶的B-树，或为空树，或为满足下列性质的m叉树:</p><ul><li>若根结点不是叶子结点，则至少有两棵子树</li><li>一个非根的分支结点都有k-1个元素和k个孩子，其中$[m/2]\leq k\leq m$，每个叶子结点n都有k-1个元素，其中$[m/2]\leq k\leq m$.</li><li>所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点(失败结点不存在，指向其指针为空，引入失败结点便于分析B-树的查找性能)</li><li>所有分支结点包含下列信息<script type="math/tex">(n,A_0,K_1,A_1,K_2,A_2...K_n,A_n)</script>，其中<script type="math/tex">K_i(i=1,2,...,n)</script>为关键字，且<script type="math/tex">K_i<K_{i+1}</script>，<script type="math/tex">A_i(i=0,1,2,..,n)</script>为指向子树根结点的指针，且指针$A_{i-1}$所指子树中所有结点的关键字均小于<script type="math/tex">K_i(i=1,2,...,n)</script>，$A_n$所指子树中所有结点的关键字均大于$K_n$，<script type="math/tex">n([m/2]-1\leq n\leq m-1)</script>为关键字的个数(或n+1为子树的个数)。</li></ul><p>下图为一个4阶的B-树<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/32.png" srcset="/img/loading.gif" width="500px" height="200px"></p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B-树的查找"></a>B-树的查找</h4><p>在一个典型的B-树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B-树进行调整，使得B-树的阶数(或结点的元素)与硬盘存储的页面大小相匹配。<br>例如一棵B-树的阶为1001(即1个结点包含1000个关键字)，高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。<br>最坏情况下，对于n个关键字的m阶B树，第一层至少有1个结点，由于除根结点外每个分支结点至少有$[m/2]$棵子树，则第三层至少有$2\times [m/2]$个结点，第k+1层至少有<script type="math/tex">2\times ([m/2])^{k-1}</script>个结点，也就是叶子结点，若m阶B-树有n个关键字，因此<script type="math/tex">n+1\geq 2\times [m/2]</script>,即在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过<script type="math/tex">k\leq log_{m/2}\{(n+1)/2\}+1</script></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>对于树结构来说，可以用中序遍历来顺序查找树中的元素，但在B树结构中，往返于每个结点之间，也就是在硬盘的页面之间进行多次访问，如下图所示，假设每个结点都属于不同的页面，中序遍历所有元素时需要重复访问页面1，为了让遍历时每个元素只访问一次，所以在原有的B树结构基础上，加了新的元素组织方式，称为B+树。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/33.png" srcset="/img/loading.gif" width="450px" height="200px"></p><p>B+树是一种B-树的变形树,更适用于文件索引系统，但它以及不算是定义的树了，如下图所示，灰色关键字即是根结点中的关键字在叶子结点再次列出，所有叶子结点都链接在一起。<br><img src="/2020/06/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/34.png" srcset="/img/loading.gif" width="500px" height="150px"></p><h4 id="B-树与B-树的差异"><a href="#B-树与B-树的差异" class="headerlink" title="B+树与B-树的差异"></a>B+树与B-树的差异</h4><ul><li>有n棵子树的结点中包含n个关键字</li><li>所有叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li><li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。</li></ul><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><p>如果要随机查找，从根结点出发与B-树查找方式相同，但即使在分支结点找到了待查的关键字，也是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。<br>如果从最小关键字进行从小到大顺序查找，可以从最左侧的叶子结点出发，不经过分支结点，而是沿着指向下一叶子的指针即可遍历所有关键字。<br>B+树不仅能有效查找单个关键字，而且更适合查找某个范围内的所有关键字。</p><hr></div><br><div><p><span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://yoursite.com/2020/06/14/线性表和树表的查找/",this.page.identifier="/2020/06/14/线性表和树表的查找/"},oldLoad=window.onload;window.onload=function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.src="//inaho-top.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a></noscript></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div id="footerContent" class="rgba-black-slight"><footer class="pt-5"><div style="color:#fff" class="text-center py-3"><a style="color:#fff" href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo支持</b></a> <i class="iconfont icon-love"></i> <a style="color:#fff" href="https://disqus.com/" target="_blank" rel="nofollow noopener"><b>Disqus 评论系统 </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>主题Fluid </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://www.pixiv.net/" target="_blank" rel="nofollow noopener"><b>图片 Pixiv</b></a><br>&nbsp;<span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp; &nbsp;<span id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;<br></div></footer></div><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="/lib/popper/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.7/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="/lib/tocbot/tocbot.min.js"></script><script src="/js/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/lib/prettify/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()})</script><script src="/lib/typed/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","线性表和树表的查找&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });</script><script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">$("#background").removeClass("banner-bg"),$("body").addClass("banner-bg");var postToTopHight=$("#board").offset().top;$(window).scroll(function(){var o=document.body.scrollTop+document.documentElement.scrollTop;postToTopHight<=o?($("#background").removeClass("rgba-black-slight"),$("#mainContent").removeClass("rgba-black-slight"),$("#footerContent").removeClass("rgba-black-slight")):($("#background").addClass("rgba-black-slight"),$("#mainContent").addClass("rgba-black-slight"),$("#footerContent").addClass("rgba-black-slight"))})</script></body></html>