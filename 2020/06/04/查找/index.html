<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>查找(持续更新) ~ inaho</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.7/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><style type="text/css">.banner-bg{background-image:url(/img/bg1.jpg);background-position:center;background-repeat:repeat-y;background-size:cover;background-attachment:fixed}</style><meta name="generator" content="Hexo 4.2.0"></head><body class="banner-bg"><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>阴月有晴</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2 rgba-black-slight" id="background"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期四, 六月 4日 2020, 8:29 晚上</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">5.1k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">18 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main id="mainContent" class="rgba-black-slight"><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><h1 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h1><ul><li><strong>查找表</strong>: 查找表(Search Table)是同一类型数据元素的集合.</li><li><strong>关键字</strong>: 数据元素中某个数据项的值，又称为<strong>键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项，称为<strong>关键码</strong>.如果此关键字可以唯一的标识一个记录，则称此关键字为<strong>主关键字</strong>(Primary Key),对不同地记录，主关键字均不同，主关键字所在地数据项称为<strong>主关键码</strong>.对于可以识别多个数据元素地关键字，称之为<strong>次关键字</strong>(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素地关键字，对应地数据项是<strong>次关键码</strong>。</li><li><strong>查找</strong>: 查找是根据某个给定的值，在查找表中找到一个关键字等于给定值的记录或数据元素，如果表中存在这样的元素，则称<strong>查找成功</strong>，否则<strong>查找失败</strong>。</li><li>动态查找表与静态查找表: 若在查找的同时对表做修改操作，则相应的表称为<strong>动态查找表</strong>，否则称之为<strong>静态查找表</strong>。<ul><li>静态查找表是只作查找操作的查找表，主要操作是查询某个特定数据元素是否在表中，或者检索某个特定的数据元素和各种属性</li><li>动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li></ul></li><li><strong>平均查找长度</strong>: 为确定记录在查找表中的位置，需要和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的<strong>平均查找长度</strong>。</li></ul><h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找的过程为: 从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。<br>数据元素类型定义:</p><pre><code>typedef struct{
    KeyType key;        //关键字域
    InfoType otherinfo;    //其他域
}ElemType;
typedef struct{
    ElemType *R;        //存储空间基地址
    int length;            //当前长度
}SSTable;
</code></pre><p>假设从1位置开始查找，0位置不用，查找算法如下:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    for(i=ST.length;i&gt;=1;--i){
        if(ST.R[i].key == key) return i;
    }
    return 0;
}
</code></pre><p>在上面的算法中，每一步都需要检测整个表是否查找完毕，即需要判断i&gt;=1是否成立，改进此算法，可以增加一个哨兵，例如ST.R[0]关键字赋值key，如下例所示:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    ST.R[0].key = key;
    for(i=ST.length;ST.R[i].key != key;--i);
    return i;        //返回0代表没找到
}
</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>设置监视哨，可以免去查找过程中每一步进行检测整个表是否查找完毕，实践证明，这个改进能使顺序表在大于1000长度的表中，进行一次查找所需的平均时间减半，两个时间复杂度都为O(n)。<br>顺序查找的优点: 算法简单，对表结构无要求。<br>顺序查找的缺点: 平均查找长度较大，查找效率低，当n很大时，不宜使用顺序查找。</p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找也称二分查找，它是一种效率较高的查找方法，但折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="折半查找的过程"><a href="#折半查找的过程" class="headerlink" title="折半查找的过程"></a>折半查找的过程</h3><p>从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功，如果给定值大于或小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，重复操作。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>为了标记查找过程中每一次的查找区间，分别用low和high表示区间的上下限，用mid表示区间的中间位置。</p><ol><li>置查找区间初值，low为1，high为表长。</li><li>当low小于等于high时，循环执行以下操作:<ol><li>mid取值为low和high的中间值</li><li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid</li><li>若不相等则利用中间位置记录将表对分成前、后两个子表，如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1.</li></ol></li><li>循环结束，说明查找区间为空，则查找失败，返回0.</li></ol><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><pre><code>int Search_Bin(SSTable ST,KeyType key){
    low=1;
    high=ST.length;
    while(low &lt;= high){
        mid = (low+high)/2;
        if(key == ST.R[mid].key) return mid;
        else if(key &lt; ST.R[mid].key) high=mid-1;
        else low=mid+1;
    }
    return 0;
}
</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>折半查找的过程可用二叉树描述，树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号，把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/1.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度，具有n个结点的判定树深度为$log_2n+1$,折半查找的时间复杂度为$O(log_2n)$.</p><ul><li>折半查找的优点: 比较次数少，查找效率高</li><li>折半查找的缺点: 只能用于顺序表查找，查找前需要排序。</li></ul><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找是每次将查找区间缩小1/2进行查找，如果要在取值范围0-10000之间100个元素从小到大均匀分布的数组中查找5，我们自然考虑从数组下标较小的开始查找。<br>折半查找代码的$mid=(low+high)/2$经过变换后可以得到$mid=low+1/2(high-low)$,这个等式可以改进为$mid=low+((key-a[low])/(a[high]-a[low])(high-low))$，将$1/2$改为了$(key-a[low])/(a[high]-a[low])$，这种方法就是<strong>插值查找法</strong>。<br>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式。</p><pre><code>mid = low + (high-low) * (key-a[low]) / (a[high]-a[low]);     //修改折半查找的mid
</code></pre><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>折半查找是每次查找总是一分为二，插值查找是对折半查找的改进，使其在数据分布均匀情况下查找效率更高，而斐波那契查找，利用了黄金分割原理来实现，斐波那契数列如下:<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/2.png" srcset="/img/loading.gif" width="500px" height="80px"></p><p>斐波那契搜索就是在折半查找的基础上根据斐波那契数列进行分割的，在平均性能上来说，斐波那契查找要由于折半查找，但在最坏情况下，例如key=1，那么始终处于左侧长半区查找，查找效率就低于折半查找。<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>斐波那契查找算法的核心在于:</p><ul><li>key值与第mid=（low+high）/2相等，mid位置的元素即为所求；</li><li>key值大于第mid=（low+high）/2，则令 low=mid+1；</li><li>key值小于第mid=（low+high）/2，则令high=mid-1。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>int Fibonacci_Search(int *a,int n,int key){
    int low,high,mid,i,k;
    low=1;            //最低下标为记录首位
    high=n;            //最高下标为记录末位
    k=0;
    while(n &gt; F[k]-1) k++;    //计算n位于斐波那契数列的位置
    for(i=n;i&lt;F[k]-1;i++) a[i]=a[n];    //将不满的数值补全

    while(low&lt;=high){
        mid = low+F[k-1]-1;        //计算当前分隔的下标
        if(key&lt;a[mid]){
            high = mid-1;
            k=k-1;
        }else if(key &gt; a[mid]){
            low=mid+1;
            k=k-2;
        }else{
            if(mid &lt;= n) return mid;
            else return n;
        }
    }
    return 0;
}
</code></pre><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>前面的几种查找方法都是基于有序的基础之上的，如果数据集增长很快，要保证记录全部按照当中某个关键字有序，时间代价很高，所以这种数据通常按先后顺序存储，对于这种查找表，需要利用索引来快速查找数据。<br>索引是为了加快查找速度而设计的一种数据结构，索引就是把每一个关键字和它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息，索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引的分类: <strong>线性索引</strong>、<strong>树形索引</strong>、<strong>多级索引</strong>，线性索引就是将索引集合组织为线性结构，也成为索引表。</p><h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图所示:<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>稠密索引要应对的可能是成千上万的数据，因此对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列，索引项有序意味着，在查找关键字时，可以用到折半、插值、斐波那契等查找算法，但如果数据集非常大，意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能需要反复访问磁盘，查找性能大大下降。</p><h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。<br>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p><ul><li>块内无序，即每一块内的记录不要求有序</li><li>块间有序，例如要求第二块的所有记录的关键字均大于第一块中所有记录的关键字，块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引叫做分块索引。</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大。</li><li>存储了块中的记录个数，以便于循环使用。</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找又称为<strong>索引顺序查找</strong>，这是一种性能介于顺序查找和折半查找之间的一种查找方法，在分块索引表中查找，分为两步进行:</p><ol><li>在分块索引表中查找要查关键字所在的块</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。</li></ol><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。<br>索引项的通用结构是次关键码、记录号表，其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。</p><h1 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h1><p>折半查找效率虽然较高，但是由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为了<strong>维护表的有序性</strong>，需要移动表中很多记录，导致额外浪费时间。<br>若要对动态查找表进行高效率的查找，可以采用几种特殊的二叉树作为查找表的组织方式。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。</p><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树:</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/5.png" srcset="/img/loading.gif" width="300px" height="250px"><br>例如上图是对序列{62，88，58，47，35，73，51，99，37，93}进行构造的二叉排序树。</p><h4 id="二叉排序树的二叉链表存储结构"><a href="#二叉排序树的二叉链表存储结构" class="headerlink" title="二叉排序树的二叉链表存储结构"></a>二叉排序树的二叉链表存储结构</h4><pre><code>typedef struct{
    KeyType key;            //关键字项
    InfoType otherinfo;        //其他数据项
}ElemType;
typedef struct BSTNode{
    ElemType data;            //数据域，包括关键字和其他数据项
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;
</code></pre><h3 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h3><p>二叉排序树可以看作一个有序表，因此在二叉排序树上进行查找和折半查找类似。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则查找失败，返回空指针</li><li>若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较:<ul><li>若key等于T-&gt;data.key，则查找成功，返回根结点地址</li><li>若key小于T-&gt;data.key，则递归查找左子树</li><li>若key大于T-&gt;data.key，则递归查找右子树</li></ul></li></ul><h4 id="算法代码示例"><a href="#算法代码示例" class="headerlink" title="算法代码示例"></a>算法代码示例</h4><pre><code>BSTree SearchBST(BSTree T,KeyType key){
    if((!T) || key == T-&gt;data.key)    return T;
    else if(key &lt; T-&gt;data.key) return SearchBST(T-&gt;lchild,key);
    else return SearchBST(T-&gt;rchild,key);
}
</code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>在二叉排序树上查找其关键字等于给定值的结点的过程，恰好是走完了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1(或是结点所在层次数)。<br>和折半查找类似，与给定值比较的关键字个数不超过数的深度，但折半查找长度为n的顺序表的判定树是唯一的，而含n个结点的二叉排序树不唯一。<br>如果给定的含n个记录的序列有序，那么构造二叉排序树时，不断向右子树添加结点，二叉排序树会变成一个深度为n的单支树，其平均查找长度为(n+1)/2，这就是最坏的情况，而最好的情况便是和二分查找的判定树类似，但二叉排序树适合维护，对于经常需要添加删除的序列来说，显然适合使用二叉排序树。</p><h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p>二叉排序树的插入操作以查找为基础的，将一个关键字值为key的结点插入到二叉排序树，需要从根结点向下查找，当树中不存在关键字等于key的结点时，才能进行插入。<br>新结点的插入一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>若二叉排序树为空，则待插入结点*S作为根结点插入空树中。</li><li>若二叉排序树非空，则将key与根结点的关键字T-&gt;data.key进行比较。<ul><li>若key小于T-&gt;data.key，则将*S插入左子树</li><li>若key大于T-&gt;data.key，则将*S插入右子树</li></ul></li></ul><blockquote><p>中序遍历一棵二叉排序树，可以得到一个结点值递增的有序序列。</p></blockquote><h4 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void InsertBST(BSTree &amp;T,ElemType e){
    if(!T){
        S = new BSTNode;
        S-&gt;data = e;
        S-&gt;lchild = S-&gt;rchild = NULL;
        T = S;            //新结点插入找到的位置
    }
    else if(e.key &lt; T-&gt;data.key) InsertBST(T-&gt;lchild,e);
    else if(e.key &gt; T-&gt;data.key) InsertBST(T-&gt;rchild,e);
}
</code></pre><p>二叉排序树插入的基本过程是查找，所以时间复杂度同查找一养，也是$O(log_2n)$.</p><h3 id="二叉排序树的创建"><a href="#二叉排序树的创建" class="headerlink" title="二叉排序树的创建"></a>二叉排序树的创建</h3><p>二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>将二叉排序树T初始化为空树</li><li>读入一个关键字为key的结点</li><li>如果读入的关键字key不是输入结束标志，则循环执行以下操作<ul><li>将此结点插入二叉排序树T中</li><li>读入一个关键字为key的结点</li></ul></li></ul><h4 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void CreatBST(BSTree &amp;T){
    T = NULL;
    cin &gt;&gt; e;
    while(e.key != ENDFLAG){    //ENDFLAG表示输入结束标志
        InsertBST(T,e);
        cin &gt;&gt; e;    
    }
}
</code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>假设有n个结点，则需要插入n次，而插入一个结点的算法时间复杂度为$O(log_2n)$，则创建二叉排序树的算法时间复杂度为$O(nlog_2n)$.</p><h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>被删除的结点可能是二叉排序树中的任何结点，删除结点后，要根据其位置不同修改双亲结点及相关结点的指针，以保持二叉排序树的特性。</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><p><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/7.png" srcset="/img/loading.gif" width="500px" height="350px"></p><p>从二叉排序树的根结点开始查找关键字为key的待删结点，分三种情况讨论:</p><ul><li>若待删结点为叶子结点，由于删除叶子结点不破坏树的整体结构，因此只需要修改其双亲的结点指向空即可。</li><li>若待删结点只有左子树或者只有右子树，只要使其左子树或右子树称为其双亲结点的左子树即可。</li><li>若待删结点的左右子树均不为空，为了保证删除该结点后，其他元素之间的相对位置不变，有以下两种方案:<ul><li>使待删结点的左子树为其双亲结点的左子树，然后待删结点的右子树为其直接前驱的右子树</li><li>令待删结点的直接前驱代替待删结点，然后删除此结点的直接前驱</li></ul></li></ul><p>第二种方案图例如下:<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/6.png" srcset="/img/loading.gif" width="500px" height="230px"></p><p>显然，前一种处理方法可能增加树的深度，而后一种方法是以被删结点左子树中关键字最大的结点(左子树中最大的结点一定没有右子树)代替被删结点，然后从左子树中删除这个结点，这种方法更好。</p><h4 id="算法示例-2"><a href="#算法示例-2" class="headerlink" title="算法示例"></a>算法示例</h4><pre><code>void DeleteBST(BSTree &amp;T,KeyType key){
    //查找关键字值等于key的结点
    p = T; 
    f = NULL;                    //f保存p的双亲结点
    while(p){
        if(p-&gt;data.key == key) break;
        f = p;
        if(p-&gt;data.key &gt; key) p = p-&gt;lchild;
        else p = p-&gt;rchild;
    }
    if(!p) return;

    //被删结点的左右子树均不为空
    q=p;
    if((p-&gt;lchild) &amp;&amp; (p-&gt;rchild)){
        s = p-&gt;lchild;                        //找到被删结点的直接前驱
        while(s-&gt;rchild){
            q=s;                            //保存待删结点的直接前驱的双亲结点，用于重接
            s=s-&gt;rchild;
        }
        p-&gt;data = s-&gt;data;                    //将待删结点的直接前驱来替换待删结点

        if(q != p){
            q-&gt;rchild = s-&gt;lchild;            //重接q的右子树
        }
        else{
            q-&gt;lchild = s-&gt;lchild;            //重接q的左子树
        }
        delete s;
        return;
    }else if(!p-&gt;rchild){                    //被删结点无右子树
        p = p-&gt;lchild;
    }else if(!p-&gt;lchild){                    //被删结点无左子树
        p = p-&gt;rchild;
    }

    //p指向的子树挂接到其双亲结点的对应位置
    if(!f) T=p;                                //被删结点为根结点
    else if(q == f-&gt;lchild) f-&gt;lchild = p;
    else f-&gt;rchild = p;
    delete q;
}
</code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>二叉排序树删除的基本过程也是查找，所以算法时间复杂度为$O(log_2n)$.</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><h1 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h1><hr></div><br><div><p><span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://yoursite.com/2020/06/04/查找/",this.page.identifier="/2020/06/04/查找/"},oldLoad=window.onload;window.onload=function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.src="//inaho-top.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a></noscript></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div id="footerContent" class="rgba-black-slight"><footer class="pt-5"><div style="color:#fff" class="text-center py-3"><a style="color:#fff" href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo支持</b></a> <i class="iconfont icon-love"></i> <a style="color:#fff" href="https://disqus.com/" target="_blank" rel="nofollow noopener"><b>Disqus 评论系统 </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>主题Fluid </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://www.pixiv.net/" target="_blank" rel="nofollow noopener"><b>图片 Pixiv</b></a><br>&nbsp;<span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp; &nbsp;<span id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;<br></div></footer></div><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="/lib/popper/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.7/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="/lib/tocbot/tocbot.min.js"></script><script src="/js/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/lib/prettify/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()})</script><script src="/lib/typed/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","查找(持续更新)&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });</script><script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">$("#background").removeClass("banner-bg"),$("body").addClass("banner-bg");var postToTopHight=$("#board").offset().top;$(window).scroll(function(){var o=document.body.scrollTop+document.documentElement.scrollTop;postToTopHight<=o?($("#background").removeClass("rgba-black-slight"),$("#mainContent").removeClass("rgba-black-slight"),$("#footerContent").removeClass("rgba-black-slight")):($("#background").addClass("rgba-black-slight"),$("#mainContent").addClass("rgba-black-slight"),$("#footerContent").addClass("rgba-black-slight"))})</script></body></html>