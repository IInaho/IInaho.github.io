<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>查找(持续更新) ~ inaho</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.7/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><style type="text/css">.banner-bg{background-image:url(/img/bg1.jpg);background-position:center;background-repeat:repeat-y;background-size:cover;background-attachment:fixed}</style><meta name="generator" content="Hexo 4.2.0"></head><body class="banner-bg"><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>阴月有晴</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">主页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2 rgba-black-slight" id="background"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期四, 六月 4日 2020, 8:29 晚上</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">3k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">11 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main id="mainContent" class="rgba-black-slight"><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><h1 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h1><ul><li><strong>查找表</strong>: 查找表(Search Table)是同一类型数据元素的集合.</li><li><strong>关键字</strong>: 数据元素中某个数据项的值，又称为<strong>键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项，称为<strong>关键码</strong>.如果此关键字可以唯一的标识一个记录，则称此关键字为<strong>主关键字</strong>(Primary Key),对不同地记录，主关键字均不同，主关键字所在地数据项称为<strong>主关键码</strong>.对于可以识别多个数据元素地关键字，称之为<strong>次关键字</strong>(Secondary Key)，次关键字可以理解为是不以唯一标识一个数据元素地关键字，对应地数据项是<strong>次关键码</strong>。</li><li><strong>查找</strong>: 查找是根据某个给定的值，在查找表中找到一个关键字等于给定值的记录或数据元素，如果表中存在这样的元素，则称<strong>查找成功</strong>，否则<strong>查找失败</strong>。</li><li>动态查找表与静态查找表: 若在查找的同时对表做修改操作，则相应的表称为<strong>动态查找表</strong>，否则称之为<strong>静态查找表</strong>。<ul><li>静态查找表是只作查找操作的查找表，主要操作是查询某个特定数据元素是否在表中，或者检索某个特定的数据元素和各种属性</li><li>动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li></ul></li><li><strong>平均查找长度</strong>: 为确定记录在查找表中的位置，需要和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的<strong>平均查找长度</strong>。</li></ul><h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找的过程为: 从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。<br>数据元素类型定义:</p><pre><code>typedef struct{
    KeyType key;        //关键字域
    InfoType otherinfo;    //其他域
}ElemType;
typedef struct{
    ElemType *R;        //存储空间基地址
    int length;            //当前长度
}SSTable;
</code></pre><p>假设从1位置开始查找，0位置不用，查找算法如下:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    for(i=ST.length;i&gt;=1;--i){
        if(ST.R[i].key == key) return i;
    }
    return 0;
}
</code></pre><p>在上面的算法中，每一步都需要检测整个表是否查找完毕，即需要判断i&gt;=1是否成立，改进此算法，可以增加一个哨兵，例如ST.R[0]关键字赋值key，如下例所示:</p><pre><code>int Search_Seq(SSTable ST,KeyType key){
    ST.R[0].key = key;
    for(i=ST.length;ST.R[i].key != key;--i);
    return i;        //返回0代表没找到
}
</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>设置监视哨，可以免去查找过程中每一步进行检测整个表是否查找完毕，实践证明，这个改进能使顺序表在大于1000长度的表中，进行一次查找所需的平均时间减半，两个时间复杂度都为O(n)。<br>顺序查找的优点: 算法简单，对表结构无要求。<br>顺序查找的缺点: 平均查找长度较大，查找效率低，当n很大时，不宜使用顺序查找。</p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找也称二分查找，它是一种效率较高的查找方法，但折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="折半查找的过程"><a href="#折半查找的过程" class="headerlink" title="折半查找的过程"></a>折半查找的过程</h3><p>从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功，如果给定值大于或小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，重复操作。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>为了标记查找过程中每一次的查找区间，分别用low和high表示区间的上下限，用mid表示区间的中间位置。</p><ol><li>置查找区间初值，low为1，high为表长。</li><li>当low小于等于high时，循环执行以下操作:<ol><li>mid取值为low和high的中间值</li><li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid</li><li>若不相等则利用中间位置记录将表对分成前、后两个子表，如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1.</li></ol></li><li>循环结束，说明查找区间为空，则查找失败，返回0.</li></ol><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><pre><code>int Search_Bin(SSTable ST,KeyType key){
    low=1;
    high=ST.length;
    while(low &lt;= high){
        mid = (low+high)/2;
        if(key == ST.R[mid].key) return mid;
        else if(key &lt; ST.R[mid].key) high=mid-1;
        else low=mid+1;
    }
    return 0;
}
</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>折半查找的过程可用二叉树描述，树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号，把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/1.png" srcset="/img/loading.gif" width="350px" height="200px"></p><p>折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度，具有n个结点的判定树深度为$log_2n+1$,折半查找的时间复杂度为$O(log_2n)$.</p><ul><li>折半查找的优点: 比较次数少，查找效率高</li><li>折半查找的缺点: 只能用于顺序表查找，查找前需要排序。</li></ul><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找是每次将查找区间缩小1/2进行查找，如果要在取值范围0-10000之间100个元素从小到大均匀分布的数组中查找5，我们自然考虑从数组下标较小的开始查找。<br>折半查找代码的$mid=(low+high)/2$经过变换后可以得到$mid=low+1/2(high-low)$,这个等式可以改进为$mid=low+((key-a[low])/(a[high]-a[low])(high-low))$，将$1/2$改为了$(key-a[low])/(a[high]-a[low])$，这种方法就是<strong>插值查找法</strong>。<br>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式。</p><pre><code>mid = low + (high-low) * (key-a[low]) / (a[high]-a[low]);     //修改折半查找的mid
</code></pre><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>折半查找是每次查找总是一分为二，插值查找是对折半查找的改进，使其在数据分布均匀情况下查找效率更高，而斐波那契查找，利用了黄金分割原理来实现，斐波那契数列如下:<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/2.png" srcset="/img/loading.gif" width="500px" height="80px"></p><p>斐波那契搜索就是在折半查找的基础上根据斐波那契数列进行分割的，在平均性能上来说，斐波那契查找要由于折半查找，但在最坏情况下，例如key=1，那么始终处于左侧长半区查找，查找效率就低于折半查找。<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>斐波那契查找算法的核心在于:</p><ul><li>key值与第mid=（low+high）/2相等，mid位置的元素即为所求；</li><li>key值大于第mid=（low+high）/2，则令 low=mid+1；</li><li>key值小于第mid=（low+high）/2，则令high=mid-1。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>int Fibonacci_Search(int *a,int n,int key){
    int low,high,mid,i,k;
    low=1;            //最低下标为记录首位
    high=n;            //最高下标为记录末位
    k=0;
    while(n &gt; F[k]-1) k++;    //计算n位于斐波那契数列的位置
    for(i=n;i&lt;F[k]-1;i++) a[i]=a[n];    //将不满的数值补全

    while(low&lt;=high){
        mid = low+F[k-1]-1;        //计算当前分隔的下标
        if(key&lt;a[mid]){
            high = mid-1;
            k=k-1;
        }else if(key &gt; a[mid]){
            low=mid+1;
            k=k-2;
        }else{
            if(mid &lt;= n) return mid;
            else return n;
        }
    }
    return 0;
}
</code></pre><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>前面的几种查找方法都是基于有序的基础之上的，如果数据集增长很快，要保证记录全部按照当中某个关键字有序，时间代价很高，所以这种数据通常按先后顺序存储，对于这种查找表，需要利用索引来快速查找数据。<br>索引是为了加快查找速度而设计的一种数据结构，索引就是把每一个关键字和它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息，索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引的分类: <strong>线性索引</strong>、<strong>树形索引</strong>、<strong>多级索引</strong>，线性索引就是将索引集合组织为线性结构，也成为索引表。</p><h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图所示:<br><img src="/2020/06/04/%E6%9F%A5%E6%89%BE/3.png" srcset="/img/loading.gif" width="350px" height="100px"></p><p>稠密索引要应对的可能是成千上万的数据，因此对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列，索引项有序意味着，在查找关键字时，可以用到折半、插值、斐波那契等查找算法，但如果数据集非常大，意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能需要反复访问磁盘，查找性能大大下降。</p><h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。<br>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p><ul><li>块内无序，即每一块内的记录不要求有序</li><li>块间有序，例如要求第二块的所有记录的关键字均大于第一块中所有记录的关键字，块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引叫做分块索引。</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大。</li><li>存储了块中的记录个数，以便于循环使用。</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找又称为<strong>索引顺序查找</strong>，这是一种性能介于顺序查找和折半查找之间的一种查找方法，在分块索引表中查找，分为两步进行:</p><ol><li>在分块索引表中查找要查关键字所在的块</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。</li></ol><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。<br>索引项的通用结构是次关键码、记录号表，其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。</p><h1 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><h1 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h1><hr></div><br><div><p><span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://yoursite.com/2020/06/04/查找/",this.page.identifier="/2020/06/04/查找/"},oldLoad=window.onload;window.onload=function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.src="//inaho-top.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a></noscript></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div id="footerContent" class="rgba-black-slight"><footer class="pt-5"><div style="color:#fff" class="text-center py-3"><a style="color:#fff" href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo支持</b></a> <i class="iconfont icon-love"></i> <a style="color:#fff" href="https://disqus.com/" target="_blank" rel="nofollow noopener"><b>Disqus 评论系统 </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>主题Fluid </b></a><i class="iconfont icon-love"></i> <a style="color:#fff" href="https://www.pixiv.net/" target="_blank" rel="nofollow noopener"><b>图片 Pixiv</b></a><br>&nbsp;<span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp; &nbsp;<span id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;<br></div></footer></div><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="/lib/popper/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.7/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="/lib/tocbot/tocbot.min.js"></script><script src="/js/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/lib/prettify/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()})</script><script src="/lib/typed/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","查找(持续更新)&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });</script><script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript">$("#background").removeClass("banner-bg"),$("body").addClass("banner-bg");var postToTopHight=$("#board").offset().top;$(window).scroll(function(){var o=document.body.scrollTop+document.documentElement.scrollTop;postToTopHight<=o?($("#background").removeClass("rgba-black-slight"),$("#mainContent").removeClass("rgba-black-slight"),$("#footerContent").removeClass("rgba-black-slight")):($("#background").addClass("rgba-black-slight"),$("#mainContent").addClass("rgba-black-slight"),$("#footerContent").addClass("rgba-black-slight"))})</script></body></html>